<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>线程池原理浅析</title>
      <link href="/2019/06/13/java-thread-pool-principle/"/>
      <url>/2019/06/13/java-thread-pool-principle/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用，在线程池中，总会有活跃的线程在占用，但是线程池中也会存在没有占用的线程，这些线程处于空闲状态，当有任务的时候会从池子里面拿去一个线程来进行使用，当完成工作后，并没有销毁线程，而是将将线程放回到池子中去。</p><blockquote><p>线程池主要解决两个问题：</p><p>一是当执行大量异步任务时线程池能够提供很好的性能。</p><p>二是线程池提供了一种资源限制和管理的手段，比如可以限制现成的个数，动态新增线程等。</p><p>​                                                                                                                                            -《Java并发编程之美》</p></blockquote><p>上面内容出自《Java并发编程之美》这本书，第一个问题上面已经提到过，线程的频繁创建和销毁是很损耗性能的，但是线程池中的线程是可以复用的，可以较好的提升性能问题，线程池内部是采用了阻塞队列来维护Runnable对象。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>JDK为我们封装了一套操作多线程的框架Executors，帮助我们可以更好的控制线程池，Executors下提供了一些线程池的工厂方法：</p><ul><li>newFixedThreadPool：返回固定长度的线程池，线程池中的线程数量是固定的。</li><li>newCacheThreadPool：该方法返回一个根据实际情况来进行调整线程数量的线程池，空余线程存活时间是60s</li><li>newSingleThreadExecutor：该方法返回一个只有一个线程的线程池。</li><li>newSingleThreadScheduledExecutor：该方法返回一个<code>SchemeExecutorService</code>对象，线程池大小为1，<code>SchemeExecutorService</code>接口在<code>ThreadPoolExecutor</code>类和 <code>ExecutorService</code>接口之上的扩展，在给定时间执行某任务。</li><li>newSchemeThreadPool：该方法返回一个<code>SchemeExecutorService</code>对象，可指定线程池线程数量。</li></ul><p>对于核心的线程池来说，它内部都是使用了<code>ThreadPoolExecutor</code>对象来实现的，只不过内部参数信息不一样，我们先来看两个例子：<code>nexFixedThreadPool</code>和<code>newSingleThreadExecutor</code>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的线程池的创建过程可以看到它们都是<code>ThreadPoolExecutor</code>的封装，接下来我们来看一下<code>ThreadPoolExecutor</code>的参数说明：</p><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td>corePoolSize</td><td>指定线程池线程的数量</td></tr><tr><td>maximumPoolSize</td><td>指定线程池中线程的最大数量</td></tr><tr><td>keepAliveTime</td><td>当线程池线程的数量超过corePoolSize的时候，多余的空闲线程存活的时间，如果超过了corePoolSize，在keepAliveTime的时间之后，销毁线程</td></tr><tr><td>unit</td><td>keepAliveTime的单位</td></tr><tr><td>workQueue</td><td>工作队列，将被提交但尚未执行的任务缓存起来</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，不指定为默认线程工厂DefaultThreadFactory</td></tr><tr><td>handler</td><td>拒绝策略</td></tr></tbody></table><p>其中workQueue代表的是提交但未执行的队列，它是BlockingQueue接口的对象，用于存放Runable对象，主要分为以下几种类型：</p><ol><li>直接提交的队列：<code>SynchronousQueue</code>队列，它是一个没有容量的队列，前面我有对其进行讲解，当线程池进行入队offer操作的时候，本身是无容量的，所以直接返回false，并没有保存下来，而是直接提交给线程来进行执行，如果没有空余的线程则执行拒绝策略。</li><li>有界的任务队列：可以使用<code>ArrayBlockingQueue</code>队列，因为它内部是基于数组来进行实现的，初始化时必须指定容量参数，当使用有界任务队列时，当有任务进行提交时，线程池的线程数量小于corePoolSize则创建新的线程来执行任务，当线程池的线程数量大于corePoolSize的时候，则将提交的任务放入到队列中，当提交的任务塞满队列后，如果线程池的线程数量没有超过maximumPoolSize，则创建新的线程执行任务，如果超过了maximumPoolSize则执行拒绝策略。</li><li>无界的任务队列：可以使用<code>LinkedBlockingQueue</code>队列，它内部是基于链表的形式，默认队列的长度是<code>Integer.MAX_VALUE</code>，也可以指定队列的长度，当队列满时进行阻塞操作，当然线程池中采用的是<code>offer</code>方法并不会阻塞线程，当队列满时则返回false，入队成功则则返回true，当使用<code>LinkedBlockingQueue</code>队列时，有任务提交到线程池时，如果线程池的数量小于corePoolSize，线程池会产生新的线程来执行任务，当线程池的线程数量大于corePoolSize时，则将提交的任务放入到队列中，等待执行任务的线程执行完之后进行消费队列中的任务，若后续仍有新的任务提交，而没有空闲的线程时，它会不断往队列中入队提交的任务，直到资源耗尽。</li><li>优先任务队列：t有限任务队列是带有执行优先级的队列，他可以使用<code>PriorityBlockingQueue</code>队列，可以控制任务的执行先后顺序，它是一个无界队列，该队列可以根据任务自身的优先级顺序先后执行，在确保性能的同时，也能有很好的质量保证。</li></ol><p>上面讲解了关于线程池内部都是通过<code>ThreadPoolExecutor</code>来进行实现的，那么下面我以一个例子来进行源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>), <span class="keyword">new</span> CustomThreadFactory());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"由线程："</span> + Thread.currentThread().getName() + <span class="string">"执行任务完成"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个线程池，线程池初始化的corePoolSize为5，也就是线程池中线程的数量为5，最大线程maximumThreadPoolSize为10，空余的线程存活的时间是60s，使用LinkedBlockingQueue来作为阻塞队列，这里还发现我自定义了<code>ThreadFactory</code>线程池工厂，这里我真是针对线程创建的时候输出线程池的名称，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程池构造工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        String name = namePrefix + threadNumber.getAndIncrement();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                name,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程池创建，线程名称为："</span> + name);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码和<code>DefaultThreadFactory</code>一样，只是在<code>newThread</code>新建线程的动作的时候输出了线程池的名称，方便查看线程创建的时机，上面<code>main</code>方法中提交了15个任务，调用了<code>execute</code>方法来进行提交任务，在分析<code>execute</code>方法之前我们先了解一下线程的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Integer类型是32位的二进制表示。</span></span><br><span class="line"><span class="comment">//高3位代表线程池的状态，低29位代表的是线程池的数量</span></span><br><span class="line"><span class="comment">//默认是RUNNING状态，线程池的数量为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//线程个数位数，表示的Integer中除去最高的3位之后剩下的位数表示线程池的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程池的线程的最大数量</span></span><br><span class="line"><span class="comment">//这里举例是32为机器，表示为00011111111111111111111111111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程池的状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//11100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//接受新任务并且处理阻塞队列里面任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//00000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//拒绝新任务但是处理阻塞队列的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//00100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//拒接新任务并且抛弃阻塞队列里面的任务，同时会中断正在处理的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//01000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//所有任务都执行完(包括阻塞队列中的任务)后当线程池活动线程数为0，将要调用terminated方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//01100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//终止状态，terminated方法调用完成以后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>通过上面内容可以看到ctl其实存放的是线程池的状态和线程数量的变量，默认是<code>RUNNING</code>，也就是<code>11100000000000000000000000000000</code>，这里我们来假设运行的机器上的Integer的是32位的，因为有些机器上可能Integer并不是32位，下面COUNT_BITS来控制位数，也就是先获取Integer在该平台上的位数，比如说是32位，然后32位-3位=29位，也就是低29位代表的是现成的数量，高3位代表线程的状态，可以清晰看到下面的线程池的状态都是通过低位来进行向左位移的操作的，除了上面的变量，还提供了操作线程池状态的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作ctl变量，主要是进行分解或组合线程数量和线程池状态。</span></span><br><span class="line"><span class="comment">// 获取高3位，获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取低29位，获取线程池中线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 组合ctl变量，rs=runStatue代表的是线程池的状态，wc=workCount代表的是线程池线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//指定的线程池状态c小于状态s</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定的线程池状态c至少是状态s</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程池是否运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS增加线程池线程数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS减少线程池线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将线程池的线程数量进行较少操作，如果竞争失败直到竞争成功为止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来我们看一下<code>ThreadPoolExecutor</code>对象下的<code>execute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断提交的任务是不是为空，如果为空则抛出NullPointException异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 获取线程池的状态和线程池的数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">// 如果线程池的数量小于corePoolSize，则进行添加线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="comment">//添加线程修改线程数量并且将command作为第一个任务进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 获取最新的状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果线程池的状态是RUNNING，将命令添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="comment">//二次检查线程池状态和线程数量</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">      <span class="comment">//线程不是RUNNING状态，从队列中移除当前任务，并且执行拒绝策略。</span></span><br><span class="line">      <span class="comment">//这里说明一点，只有RUNNING状态的线程池才会接受新的任务，其余状态全部拒绝。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">      <span class="comment">//如果线程池的线程数量为空时，代表线程池是空的，添加一个新的线程。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果队列是满的，或者是SynchronousQueue队列时，则直接添加新的线程执行任务，如果添加失败则进行拒绝</span></span><br><span class="line">  <span class="comment">//可能线程池的线程数量大于maximumPoolSize则采取拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析execute方法总结以下几点：</p><ol><li>当线程池中线程的数量小于<code>corePoolSize</code>时，直接添加线程到线程池并且将当前任务做为第一个任务执行。</li><li>如果线程池的状态的是<code>RUNNING</code>，则可以接受任务，将任务放入到阻塞队列中，内部进行二次检查，有可能在运行下面内容时线程池状态已经发生了变化，在这个时候如果线程池状态变成不是<code>RUNNING</code>，则将当前任务从队列中移除，并且进行拒绝策略。</li><li>如果阻塞队列已经满了或者<code>SynchronousQueue</code>这种特殊队列无空间的时候，直接添加新的线程执行任务，当线程池的线程数量大于<code>maximumPoolSize</code>时相应拒绝策略。</li><li>入队操作用的是<code>offer</code>方法，该方法不会阻塞队列，如果队列已经满时或超时导致入队失败，返回false，如果入队成功返回true。</li></ol><p>针对上面例子源码我们来做一下分析，我们源码中阻塞队列采用的是<code>ArrayBlockingQueue</code>队列，并且指定队列的长度是5，我们看下面提交的线程池的任务是15个，而且corePoolSize设置的是5个核心线程，最大线程数（maximumPoolSzie）是10个，假设所有任务都同时提交到了线程池中，其中有5个任务会被提交到线程中作为第一个任务进行执行，会有5个任务被添加到阻塞队列中，还有5个任务提交到到线程池中的时候发现阻塞队列已经满了，这时候会直接提交任务，发现当前线程数是5小于最大线程数，可以进行新建线程来执行任务。</p><p><img src="/2019/06/13/java-thread-pool-principle/1.png" alt="1"></p><p>这里我们只是假设任务全部提交，因为我们在任务中添加了Thread.sleep睡眠一会，在for循环结束提交任务之后可能才会结束掉任务的睡眠执行任务后面内容，所以可以看做是全部提交任务，但是没有任务完成，如果有任务完成的话，可能就不会是触发最大的线程数，有可能就是一个任务完成后从队列取出来，然后另一个任务来的时候可以添加到队列中，上图中可以看到，有5个核心core线程在执行任务，任务队列中有5个任务在等待空余线程执行，而还有5个正在执行的线程，核心线程是指在corePoolSize范围的线程，而非核心线程指的是大于corePoolSize但是小于等于MaximumPoolSize的线程，就是这些非核心线程并不是一直存活的线程，它会跟随线程池指定的参数来进行销毁，我们这里指定了60s后如果没有任务提交，则会进行销毁操作，当然工作线程并不指定那些线程必须回收那些线程就必须保留，是根据从队列中获取任务来决定，如果线程获取任务时发现线程池中的线程数量大于corePoolSize，并且阻塞队列中为空时，则阻塞队列会阻塞60s后如果还有没有任务就返回false，这时候会释放线程，调用<code>processWorkerExit</code>来处理线程的退出，接下来我们来分析下<code>addWorker</code>都做了什么内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获取线程池的状态和线程池线程的数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">//单独获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查队列是否只在必要时为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<span class="comment">//线程池的状态是SHUTDOWN、STOP、TIDYING、TERMINATED</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;<span class="comment">//可以看做是rs!=SHUTDOWN,线程池状态为STOP、TIDYING、TERMINATED</span></span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;<span class="comment">//可以看做firstTask!=null，并且rs=SHUTDOWN</span></span><br><span class="line">               ! workQueue.isEmpty()))<span class="comment">//可以看做rs=SHUTDOWN，并且workQueue.isEmpty()队列为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//循环CAS增加线程池中线程的个数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">//获取线程池中线程个数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">          <span class="comment">//如果线程池线程数量超过最大线程池数量，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                <span class="comment">//如果指定使用corePoolSize作为限制则使用corePoolSize，反之使用maximumPoolSize，最为工作线程最大线程线程数量，如果工作线程大于相应的线程数量则直接返回。</span></span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//CAS增加线程池中线程的数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">              <span class="comment">//跳出增加线程池数量。</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">          <span class="comment">//如果修改失败，则重新获取线程池的状态和线程数量</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">          <span class="comment">//如果最新的线程池状态和原有县城出状态不一样时，则跳转到外层retry中，否则在内层循环重新进行CAS</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工作线程是否开始启动标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//工作线程添加到线程池成功与否标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建一个Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      <span class="comment">//获取worker中的线程，这里线程是通过ThreadFactory线程工厂创建出来的，详细看下面源码信息。</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">      <span class="comment">//判断线程是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//添加独占锁，为添加worker进行同步操作，防止其他线程同时进行execute方法。</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池的状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"><span class="comment">//如果线程池状态为RUNNING或者是线程池状态为SHUTDOWN并且第一个任务为空时，当线程池状态为SHUTDOWN时，是不允许添加新任务的，所以他会从队列中获取任务。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                  <span class="comment">//添加worker到集合中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  <span class="comment">//跟踪最大的线程池数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  <span class="comment">//添加worker成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//如果添加worker成功就启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有启动，w不为空就已出worker，并且线程池数量进行减少。</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面<code>addWorker</code>方法可以分为两个部分来进行讲解，第一部分是对线程池中线程数量的通过CAS的方式进行增加，其中第一部分中上面有个if语句，这个地方着重分析下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">    ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">       firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       ! workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>可以看成下面的样子，将<code>！</code>放到括号里面，变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">     (rs != SHUTDOWN ||</span><br><span class="line">       firstTask != <span class="keyword">null</span> ||</span><br><span class="line">       workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><ul><li>线程池的状态是SHUTDOWN、STOP、TIDYING、TERMINATED<ul><li>当线程池状态是STOP、TIDYING、TERMINATED时，这些状态的时候不需要进行线程的添加和启动操作，因为如果是上面的状态，其实线程池的线程正在进行销毁操作，意味着线程调用了shutdownNow等方法。</li><li>如果线程池状态为SHUTDOWN并且第一个任务不为空时，不接受新的任务，直接返回false，也就是说SHUTDOWN的状态，不会接受新任务，只会针对队列中未完成的任务进行操作。</li><li>当线线程池状态为SHUTDOWN并且队列为空时，直接返回不进行任务添加。</li></ul></li></ul><p>上半部分分为内外两个循环，外循环对线程池状态的判断，用于判断是否需要添加工作任务线程，通过上面讲的内容进行判断，后面内循环则是通过CAS操作增加线程数，如果指定了<code>core</code>参数为true，代表线程池中线程的数量没有超过<code>corePoolSize</code>，当指定为false时，代表线程池中线程数量达到了<code>corepPoolSize</code>，并且队列已经满了，或者是<code>SynchronousQueue</code>这种无空间的队列，但是还没有达到最大的线程池<code>maximumPoolSize</code>，所以它内部会根据指定的<code>core</code>参数来判断是否已经超过了最大的限制，如果超过了就不能进行添加线程了，如果没有超过就增加线程数量。</p><p>第二部分主要是把任务添加到worker中，并启动线程，这里我们先来看一下Worker对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里发现它是实现了AQS，是一个不可重入的独占锁模式</span></span><br><span class="line"><span class="comment">// 并且它还集成了Runable接口，实现了run方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 执行任务的线程，通过ThreadFactory创建 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 初始化第一个任务*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个线程完成任务的数量 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先现将state值设置为-1，因为在AQS中state=0代表的是锁没有被占用，而且在线程池中shutdown方法会判断能否争抢到锁，如果可以获得锁则对线程进行中断操作，如果调用了shutdownNow它会判断state&gt;=0会被中断。</span></span><br><span class="line"><span class="comment">     * firstTask第一个任务，如果为空则会从队列中获取任务，后面runWorker中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 委托调用外部的runWorker方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"><span class="comment">//这里就是上面shutdownNow中调用的线程中断的方法，getState()&gt;=0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Worker是一个实现了AQS的锁，它是一个不可重入的独占锁，并且他也实现了Runable接口，实现了<code>run</code>方法，在构造函数中将AQS的<code>state</code>设置为-1，为了避免线程还没有进入<code>runWorker</code>方法前，就调用了<code>shutdown</code>或<code>shutdownNow</code>方法，会被中断，设置为-1则不会被中断。后面我们看到<code>run</code>方法，它调用的是<code>ThreadPoolExecutor</code>的<code>runWorker</code>方法，我们这里回想一下，在<code>addWorker</code>方法中，添加<code>worker</code>到<code>HashSet&lt;Worker&gt;</code>中后，他会将<code>workerAdded</code>设置为true，代表添加<code>worker</code>成功，后面有调用了下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">    t.start();</span><br><span class="line">    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个t代表的就是在Worker构造函数中的使用<code>ThreadFactory</code>创建的线程，并且将自己（Worker自己）传递了当前线程，创建的线程就是任务线程，任务线程启动的时候会调用<code>Worker</code>下的<code>run</code>方法，<code>run</code>方法内部又委托给外部方法<code>runWorker</code>来进行操作，它的参数传递的是调用者自己，<code>Worker</code>中的<code>run</code>方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">//this指Worker对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单画一张图来表示下调用的逻辑。</p><p><img src="/2019/06/13/java-thread-pool-principle/2.png" alt="2"></p><p>整体的逻辑是先进行创建线程，线程将Worker设置为Runable对象，并将线程塞到Worker中，然后再addWorker中将Worker中的线程取出来，进行启动操作，启动后他会调用Worker中的run方法，然后run方法中将调用ThreadPoolExecutor的runWorker，然后runWorker又会调用Worker中的任务firstTask，这个fistTask是要真正执行的任务，也是用户自己实现的代码逻辑。</p><p>接下来我们就要看一下runWorker方法里面具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用者也就是Worker中的线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取Worker中的第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">  <span class="comment">//将Worker中的任务清除代表执行了第一个任务了，后面如果再有任务就从队列中获取。</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//这里还记的我们在new Worker的时候将AQS的state状态设置为-1，这里先进行解锁操作，将state设置为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//循环进行获取任务，如果第一个任务不为空，或者是如果第一个任务为空，从任务队列中获取任务，如果有任务则返回获取的任务信息，如果没有任务可以获取则进行阻塞，阻塞也分两种第一种是阻塞直到任务队列中有内容，第二种是阻塞队列一定时间之后还是没有任务就直接返回null。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//先获取worker的独占锁，防止其他线程调用了shutdown方法。</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池正在停止，确保线程是被中断的，如果没有则确保线程不被中断操作。</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || <span class="comment">//如果线程池状态为STOP、TIDYING、TERMINATED直接拒绝任务中断当前线程</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//执行任务之前做一些操作，可进行自定义</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//运行任务在这里喽。</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//执行任务之后做一些操作，可进行自定义</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//将任务清空为了下次任务获取</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">              <span class="comment">//统计当前Worker完成了多少任务</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">              <span class="comment">//独占锁释放</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//处理Worker的退出操作，执行清理工作。</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(runStateAtLeast(ctl.get(), STOP) &amp;&amp;</span><br><span class="line">     (Thread.interrupted() ||</span><br><span class="line">      runStateAtLeast(ctl.get(), STOP))) ||</span><br><span class="line">    wt.isInterrupted())</span><br><span class="line">    wt.interrupt();</span><br></pre></td></tr></table></figure><p>我们看到如果Worker是第一次被启动，它会从Worker中获取firstTask任务来执行，然后执行成功后，它会getTask()来从队列中获取任务，这个地方比较有意思，它是分情况进行获取任务的，我们都直到BlockingQueue中提供了几种从队列中获取的方法，这个getTask中使用了两种方式，第一种是使用poll进行获取队列中的信息，它采用的是过一点时间如果队列中仍没有任务时直接返回null，然后还有一个就是take方法，take方法是如果队列中没有任务则将当前线程进行阻塞，等待队列中有任务后，会通知等待的队列线程进行消费任务，让我们看一下getTask方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">//poll获取超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获取线程池的状态和线程数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">//获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池状态大于等于SHUTDOWN</span></span><br><span class="line">      <span class="comment">//1.线程池如果是大于STOP的话减少工作线程池数量</span></span><br><span class="line">      <span class="comment">//2.如果线程池状态为SHUTDOW并且队列为空时，代表队列任务已经执行完，返回null，线程数量减少1</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//获取线程池数量。</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果allowCoreThreadTimeOut为true，则空闲线程在一定时间未获得任务会清除</span></span><br><span class="line">      <span class="comment">//或者如果线程数量大于corePoolSize的时候会进行清除空闲线程</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"><span class="comment">//1.如果线程池数量大于最大的线程池数量或者对（空余线程进行清除操作并且poll超时了，意思是队列中没有内容了，导致poll间隔一段时间后没有获取内容超时了。</span></span><br><span class="line">      <span class="comment">//2.如果线程池的数量大于1或者是队列已经是空的</span></span><br><span class="line">      <span class="comment">//总之意思就是当线程池的线程池数量大于corePoolSize，或指定了allowCoreThreadTimeOut为true，当队列中没有数据或者线程池数量大于1的情况下，尝试对线程池的数量进行减少操作，然后返回null，用于上一个方法进行清除操作。</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果timed代表的是清除空闲线程的意思</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<span class="comment">//等待一段时间如果没有获取到返回null。</span></span><br><span class="line">                workQueue.take();<span class="comment">//阻塞当前线程</span></span><br><span class="line">          <span class="comment">//如果队列中获取到内容则返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"><span class="comment">//如果没有获取到超时了则设置timeOut状态</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>getTask从队列中进行获取任务</li><li>如果指定了allowCoreThreadTimeOut或线程池线程数量大于corePoolSize则进行清除空闲多余的线程</li><li>如果线程池中线程池数量小于corePoolSize或者allowCoreThreadTimeOut为false默认值，则进行阻塞线程从队列中获取任务，直到队列有任务唤醒线程。</li></ol><p>我们还记得第一张图中有标记出来是core线程和普通线程，其实这样标记不是很准确，准确的意思是如果线程池的数量超过了corePoolSize如果没有特别指定allowCoreThreadTimeOut的情况下，它会清除掉大于corePoolSize的一些线程，但是会小于等于maximumPoolSize，标记出core线程的意思是有corePoolSize不会被清除，但是会清除大于corePoolSize的线程，也就是线程池中的线程对获取任务的时候进行判断，也就是getTask中进行判断，如果当前线程池的线程数量大于corePoolSize就使用poll方式获取队列中的任务，当过一段时间还没有任务就会返回null，返回null之后设置timeOut=true，并且获取getTask也会返回null，到此会跳到调用者runWorker方法中，一直在<code>while (task != null || (task = getTask()) != null)</code>此时的getTask返回null跳出while循环语句，设置completedAbruptly = false，表示不是突然完成的而是正常完成，最后它会执行finally的<code>processWorkerExit(w, completedAbruptly)</code>，执行清理工作。我们来看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// 如果突然完成则调整线程数量</span></span><br><span class="line">        decrementWorkerCount();<span class="comment">// 减少线程数量1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;<span class="comment">//统计整个线程池完成的数量</span></span><br><span class="line">        workers.remove(w);<span class="comment">//将完成任务的worker从HashSet中移除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尝试设置线程池状态为TERMINATED</span></span><br><span class="line">  <span class="comment">//1.如果线程池状态为SHUTDOWN并且线程池线程数量与工作队列为空时，修改状态。</span></span><br><span class="line">  <span class="comment">//2.如果线程池状态为STOP并且线程池线程数量为空时，修改状态。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取线程池的状态和线程池的数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="comment">// 如果线程池的状态小于STOP，也就是SHUTDOWN或RUNNING状态</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">      <span class="comment">//如果不是突然完成，也就是正常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">          <span class="comment">//如果指定allowCoreThreadTimeOut=true(默认false)则代表线程池中有空余线程时需要进行清理操作，否则线程池中的线程应该保持corePoolSize</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">          <span class="comment">//这里判断如果线程池中队列为空并且线程数量最小为0时，将最小值调整为1，因为队列中还有任务没有完成需要增加队列，所以这里增加了一个线程。</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果当前线程数效益核心个数，就增加一个Worker</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码可以得出，如果线程数超过核心线程数后，在<code>runWorker</code>中就不会等待队列中的消息，而是会进行清除操作，上面的清除代码首先是先对线程池的数量进行较少操作，其次是统计整个线程池中完成任务的数量，然后就是尝试修改线程池的状态由<code>SHUTDOWN-&gt;TIDYING-&gt;TERMINATED</code>或者是由<code>STOP-&gt;TIDYING-&gt;TERMINATED</code>，修改线程池状态为<code>TERMINATED</code>，需要有两个条件：</p><ol><li><p>当线程池线程数量和工作队列为空，并且线程池的状态为<code>SHUTDOWN</code>时，才会将状态进行修改，修改的过程是<code>SHUTDOWN-&gt;TIDYING-&gt;TERMINATED</code></p></li><li><p>当线程池的状态为<code>STOP</code>并且线程池数量为空时，才会尝试修改状态，修改过程是<code>STOP-&gt;TIDYING-&gt;TERMINATED</code></p></li></ol><p>如果设置为<code>TERMINATED</code>状态，还需要调用条件变量<code>termination</code>的<code>signalAll()</code>方法来唤醒所有因为调用<code>awaitTermination</code>方法而被阻塞的线程，换句话说当调用<code>awaitTermination</code>后，只有线程池状态变成TERMINATED才会被唤醒。</p><p>接下来我们就来分析一下这个<code>tryTerminate</code>方法，看一下他到底符不符合我们上述说的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 获取线程池的状态和线程池的数量组合状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">//这里单独下面进行分析，这里说明两个问题，需要反向来想这个问题。</span></span><br><span class="line">      <span class="comment">//1.如果线程池状态STOP则不进入if语句</span></span><br><span class="line">      <span class="comment">//2.如果线程池状态为SHUTDOWN并且工作队列为空时，不进入if语句</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">//如果线程池数量不为空时，进行中断操作。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//修改状态为TIDYING，并且将线程池的数量进行清空</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//执行一些逻辑，默认是空的</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//修改状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                  <span class="comment">//唤醒调用awaitTermination方法的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们单独将上面的if语句摘出来进行分析，将上面的第一个if判断进行修改如下，可以看到return在else里面，这时候内部if判断进行转换，转换成如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isRunning(c) &amp;&amp;</span><br><span class="line">    !runStateAtLeast(c, TIDYING) &amp;&amp; <span class="comment">//只能是SHUTDOWN和STOP</span></span><br><span class="line">    (runStateOf(c) != SHUTDOWN ||  workQueue.isEmpty()))&#123;</span><br><span class="line">    <span class="comment">//这里执行逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐一分析分析内容如下：</p><ol><li><p><code>!isRunning(c)</code>代表不是RUNNING，则可能的是<code>SHUTDOWN</code>，<code>STOP</code>，<code>TIDYING</code>，<code>TERMINATED</code>这四种状态</p></li><li><p>中间的连接符是并且的意思，跟着<code>runStateAtLeast(c, TIDYING)</code>这句话的意思是至少是<code>TIDYING</code>，<code>TERMINATED</code>这两个，反过来就是可能是<code>RUNNING</code>，<code>SHUTDOWN</code>，<code>STOP</code>，但是前面已经判断了不能是<code>RUNINNG</code>状态，所以前面两个连在一起就是只能是状态为<code>SHUTDOWN</code>，<code>STOP</code></p></li><li><code>runStateOf(c) != SHUTDOWN ||  workQueue.isEmpty()</code>当前面的状态是<code>SHUTDOWN</code>时，则会出发<code>workQueue.isEmpty()</code>,连在一起就是状态是<code>SHUTDOWN</code>并工作队列为空，当线程池状态为<code>STOP</code>时，则会进入到<code>runStateOf(c) != SHUTDOWN</code>，直接返回true，就代表线程池状态为<code>STOP</code></li></ol><p>后面还有一个语句一个if语句将其转换一下逻辑就是下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerCountOf(c) == <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="comment">//执行下面的逻辑   </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们也进行转换下，就可以看出来当线程池的数量为空时，才会进行下面的逻辑，下面的逻辑就是修改线程池状态为<code>TERMINATED</code>，两个连在一起就是上面分析的修改状态为<code>TERMINATED</code>的条件，这里画一张图来表示线程池状态的信息：</p><p><img src="/2019/06/13/java-thread-pool-principle/3.png" alt="3"></p><p>其实上面图中我们介绍了关于从<code>SHUTDOWN</code>或<code>STOP</code>到<code>TERMINATED</code>的变化，没有讲解关于如何从<code>RUNNING</code>状态转变成<code>SHUTDOWN</code>或<code>STOP</code>状态，其实是调用了<code>shutdown()</code>或<code>shutdownNow</code>方法对其进行状态的变换，下面来看一下<code>shutdown</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//设置线程池状态为SHUTDOWN，如果状态已经是大于等于SHUTDOWN则直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">      <span class="comment">//如果线程没有设置中断标识并且线程没有运行则设置中断标识</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">      <span class="comment">//空的可以实现的内容</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//尝试修改线程池状态为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先对当前线程进行权限检测，查看是否设置了安全管理器，如果设置了则要看当前调用shutdown的线程有没有权限都关闭线程的权限，如果有权限还要看是否有中断工作现成的权限，如果没有权限则抛出<code>SecurityException</code>或<code>NullPointException</code>异常。</li><li>设置线程池状态为SHUTDOWN，如果状态已经是大于等于SHUTDOWN则直接返回</li><li>如果线程没有设置中断标识并且线程没有运行则设置中断标识</li><li>尝试修改线程池状态为TERMINATED</li></ol><p>接下来我们来看一下<code>advanceRunState</code>内容如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获取线程池状态和线程池的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||<span class="comment">//如果线程池的状态&gt;=SHUTDOWN</span></span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))<span class="comment">//设置线程池状态为SHUTDOWN</span></span><br><span class="line">          <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当线程池的状态&gt;=SHUTDOWN，直接返回</li><li>如果线程池状态为RUNNING，设置线程池状态为SHUTDOWN，设置成功则返回</li></ol><p><code>interruptIdleWorkers</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取全局锁，同时只能有一个线程能够调用shutdown方法</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//遍历工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">          <span class="comment">//如果当前线程没有设置中断标志并且可以获取Worker自己的锁</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//设置中断标志</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//执行一次，清理空闲线程。</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到当我们调用shutdown方法的时候，只是将空闲的线程给设置了中断标识，也就是活跃正在执行任务的线程并没有设置中断标识，直到将任务全部执行完后才会逐步清理线程操作，我们还记的在getTask中的方法里面有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是状态&gt;=SHUTDOWN，并且队列为空时，将线程池数量进行减少操作，内部进行CAS操作，直到CAS操作成功为止，并且返回null，返回null后，会调用<code>processWorkerExit(w, false);</code>清理Workers线程信息，并且尝试将线程设置为<code>TERMINATED</code>状态，上面是对所有<code>shutdown</code>方法的分析，下面来看一下<code>shutdownNow</code>方法并且比较两个之间的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//设置线程池状态为STOP，如果状态已经是大于等于STOP则直接返回</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">      <span class="comment">//这里是和SHUTDOWN区别的地方，这里是强制进行中断操作</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">      <span class="comment">//将为完成任务复制到list集合中</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//尝试修改线程池状态为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shutdownNow</code>方法返回了未完成的任务信息列表<code>tasks = drainQueue();</code>，其实该方法和<code>shutdown</code>方法主要的区别在于一下几点内容：</p><ol><li><code>shutdownNow</code>方法将线程池状态设置为<code>STOP</code>，而<code>shutdown</code>则将状态修改为<code>SHUTDOWN</code></li><li><code>shutdownNow</code>方法将工作任务进行中断操作，也就是说如果工作线程在工作也会被中断，而<code>shutdown</code>则是先尝试获取锁如果获得锁成功则进行中断标志设置，也就是中断操作，如果没有获取到锁则等待进行完成后自动退出。</li><li><code>shutdownNow</code>方法返回未完成的任务列表。</li></ol><p>下面代码是<code>shutDownNow</code>的<code>interruptWorkers</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">          <span class="comment">//直接进行中断操作。</span></span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了<code>Worker</code>的<code>interruptIfStarted</code>方法，方法内部是针对线程进行中断操作，但是中断的前提条件是AQS的state状态必须大于等于0，如果状态为-1的则不会被中断，但是如果任务运行起来的时候在<code>runWorker</code>中则不会执行任务，因为线程池状态为<code>STOP</code>，如果线程池状态为STOP则会中断线程，下面代码是Worker中的<code>interruptIfStarted</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">  <span class="comment">//当前Worker锁状态大于等于0并且线程没有被中断</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略如下：</p><ol><li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</li><li>CallerRunsPolicy策略：只要线程池没有关闭线程池状态是RUNNING状态，该略略直接调用线程中运行当前被丢弃的任务</li><li>DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的第一个任务，并尝试再次提交任务</li><li>DiscardPolicy策略：该策略默默丢弃无法处理的任务，不予任何处理。</li></ol><p>​<img src="/2019/06/13/java-thread-pool-principle/5.png" alt="5"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先先上一张图，针对这张图来进行总结：</p><p><img src="/2019/06/13/java-thread-pool-principle/4.png" alt="4"></p><ol><li>主线程进行线程池的调用，线程池执行execute方法</li><li>线程池通过<code>addWorker</code>进行创建线程，并将线程放入到线程池中，这里我们看到第二步是将线程添加到核心线程中，其实线程池内部不分核心线程和非核心线程，只是根据corePoolSize和maximumPoolSize设置的大小来进行区分，因为超过corePoolSize的线程会被回收，至于回收那些线程，是根据线程获取任务的时候进行判断，当前线程池数量大于corePoolSize，或者指定了<code>allowCoreThreadTimeOut</code>为true，则他等待一定时间后会返回，不会一直等待</li><li>当线程池的数量达到corePoolSize时，线程池首先会将任务添加到队列中</li><li>当队列中任务也达到了队列设置的最大值时，它会创建新的线程，注意的是此时的线程数量已经超过了corePoolSize，但是没有达到maximumPoolSize最大值。</li><li>当线程池的线程数量达到了maximumPoolSize，则会相应拒绝策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解AQS原理之ReentrantLock详解-公平锁</title>
      <link href="/2019/06/02/reentrantlock-principle-fair/"/>
      <url>/2019/06/02/reentrantlock-principle-fair/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面已经讲解了关于AQS的非公平锁模式，关于<code>NonfairSync</code>非公平锁，内部其实告诉我们谁先争抢到锁谁就先获得资源，下面就来分析一下公平锁<code>FairSync</code>内部是如何实现公平的？如果没有看过非公平锁的先去了解下非公平锁，因为这篇文章前面不会讲太多内部结构，直接会对源码进行分析<br>前文连接地址：<a href="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/">图解AQS原理之ReentrantLock详解-非公平锁</a></p><blockquote><p>本文分析的JDK版本是1.8</p><p>温馨提示：读本文内容建议结合之前写的非公平，前篇设计了很多基础性内容</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在源码分析之前，我们先来看一下<code>ReentrantLock</code>如何切换获取锁的模式呢？其实是在构造器中传递指定的类型变量来控制使用锁的方式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>fair</code>参数指定为true时，代表的是公平锁，如果指定为false则使用的非公平，无参的构造函数默认使用的是非公平模式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们以一个例子来进行后面的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程被中断了"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过源码可以看到这里我们启动了两个线程，两个线程分别进行同步锁操作，这里我并没有释放掉锁，因为方便分析队列的情况，当然你也可以在内部写一个死循环，不释放锁就可以了，我这里简单的不释放锁，使用的是可中断的获取锁操作方法<code>lockInterruptibly</code>，这里内部的原理我们上一篇文章中已经讲解过了，这里并不过多的去分析内部原理，这个<code>ReentrantLock</code>的<code>lockInterruptibly</code>调用内部类<code>AQS</code>的<code>acquireInterruptibly</code>，但是其实是<code>FairSync</code>内部类继承了内部类<code>Sync</code>，而内部类<code>Sync</code>有继承了<code>AbstractQueuedSynchronizer</code>简称AQS，<code>acquireInterruptibly</code>源码信息如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过上一篇文章得知<code>tryAcquire</code>是需要子类去实现的方法，我们在例子中指定了使用的是公平锁，所以<code>tryAcquire</code>方法的实现是在<code>ReentrentLock</code>的<code>FairSync</code>类中，我们来具体看一下这个方法，重点也在这个方法中其他的其实都是一样的，因为用的方法都会一样的非公平和公平锁的调用，唯独不一样的就是子类实现的方法是不相同的，接下来我们就来看一下公平锁的<code>tryAcquire</code>是如何实现的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">//判断是否有等待的线程在队列中</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//尝试争抢锁操作</span></span><br><span class="line">            setExclusiveOwnerThread(current);<span class="comment">//设置当前线程独占锁资源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获得锁成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//当前线程和独占锁资源的线程一致，则可以重入</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//state递增</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);<span class="comment">//设置state状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//获得锁成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//获得锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比非公平锁的<code>NonfairSync</code>类的<code>tryAcquire</code>方法，其实就是在锁可用的情况下增加了一个判断条件，这个判断方法就是<code>hasQueuedPredecessors</code>，从方法的名称来看说的是有等待的线程队列，换句话说已经有人在排队了，新来的线程你就不能加塞，而非公平模式的谁先争抢到锁就是谁的，管你先来不先来，接下来我们具体看一下这个</p><p><code>hasQueuedPredecessors</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// 获得尾节点</span></span><br><span class="line">    Node h = head; <span class="comment">// 获得头节点</span></span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;<span class="comment">//头节点和尾节点相同代表队列为空</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());<span class="comment">//头节点的next节点为空代表头节点，以及s.thread不是当前线程不是自己的话代表队列中存在元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码信息，可以得出其实内部主要就是判断有没有排队等待的节点，队列是否为空，如果为空的话则可以争抢锁，如果队列不为空，伙计你必须老老实实给我排队去，除非占有锁的线程和请求锁的线程是一样的，否则还是老老实实排队去，这就是公平模式的锁操作，还有一个<code>lock</code>方法，公平模式的<code>lock</code>方法，没有直接上来先获取锁，而是先尝试获得锁直接调用<code>AQS</code>的<code>aquire</code>方法进行尝试获取锁，下面是<code>FairSync</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//这里直接调用了aquire并没有尝试修改state状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本内容主要是结合上篇内容的一个续篇，可以结合上篇然后再看下篇会比较清晰些。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解AQS原理之ReentrantLock详解-非公平锁</title>
      <link href="/2019/06/02/reentrantlock-principle-nonfairsync/"/>
      <url>/2019/06/02/reentrantlock-principle-nonfairsync/</url>
      
        <content type="html"><![CDATA[<h1 id="图解AQS原理之ReentrantLock详解-非公平锁"><a href="#图解AQS原理之ReentrantLock详解-非公平锁" class="headerlink" title="图解AQS原理之ReentrantLock详解-非公平锁"></a>图解AQS原理之ReentrantLock详解-非公平锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并发编程中，<code>ReentrantLock</code>的使用是比较多的，包括之前讲的<code>LinkedBlockingQueue</code>和<code>ArrayBlockQueue</code>的内部都是使用的<code>ReentrantLock</code>，谈到它又不能的不说AQS，AQS的全称是<code>AbstractQueuedSynchronizer</code>，这个类也是在<code>java.util.concurrent.locks</code>下面，提供了一个FIFO的队列，可以用于构建锁的基础框架，内部通过原子变量<code>state</code>来表示锁的状态，当<code>state</code>大于0的时候表示锁被占用，如果state等于0时表示没有占用锁，<code>ReentrantLock</code>是一个重入锁，表现在<code>state</code>上，如果持有锁的线程重复获取锁时，它会将<code>state</code>状态进行递增，也就是获得一个信号量，当释放锁时，同时也是释放了信号量，信号量跟随减少，如果上一个线程还没有完成任务，则会进行入队等待操作。</p><blockquote><p>本文分析内容主要是针对jdk1.8版本</p><p>约束：文中图片的ref-xxx代表引用地址</p><p>图片中的内容prve更正为prev，由于文章不是一天写的所以有些图片更正了有些没有。</p></blockquote><h3 id="AQS主要字段"><a href="#AQS主要字段" class="headerlink" title="AQS主要字段"></a>AQS主要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头节点指针，通过setHead进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列的尾指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><h3 id="AQS需要子类实现的方法"><a href="#AQS需要子类实现的方法" class="headerlink" title="AQS需要子类实现的方法"></a>AQS需要子类实现的方法</h3><p>AQS是提供了并发的框架，它内部提供一种机制，它是基于模板方法的实现，整个类中没有任何一个abstract的抽象方法，取而代之的是，需要子类去实现的那些方法通过一个方法体抛出UnsupportedOperationException异常来让子类知道，告知如果没有实现模板的方法，则直接抛出异常。</p><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>tryAcquire</td><td>以独占模式尝试获取锁，独占模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td></tr><tr><td>tryRelease</td><td>尝试独占模式下释放状态</td></tr><tr><td>tryAcquireShared</td><td>尝试在共享模式获得锁，共享模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td></tr><tr><td>tryReleaseShared</td><td>尝试共享模式下释放状态</td></tr><tr><td>isHeldExclusively</td><td>是否是独占模式，表示是否被当前线程占用</td></tr></tbody></table><p>AQS是基于FIFO队列实现的，那么队列的Node节点又是存放的什么呢？</p><h3 id="Node字段信息"><a href="#Node字段信息" class="headerlink" title="Node字段信息"></a>Node字段信息</h3><table><thead><tr><th>字段名</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>SHARED</td><td>Node</td><td>new Node()</td><td>一个标识，指示节点使用共享模式等待</td></tr><tr><td>EXCLUSIVE</td><td>Nodel</td><td>Null</td><td>一个标识，指示节点使用独占模式等待</td></tr><tr><td><code>CANCELLED</code></td><td>int</td><td>1</td><td>节点因超时或被中断而取消时设置状态为取消状态</td></tr><tr><td><code>SIGNAL</code></td><td>int</td><td>-1</td><td>当前节点的后节点被park，当前节点释放时，必须调用unpark通知后面节点，当后面节点竞争时，会将前面节点更新为<code>SIGNAL</code></td></tr><tr><td><code>CONDITION</code></td><td>int</td><td>-2</td><td>标识当前节点已经处于等待中，通过条件进行等待的状态</td></tr><tr><td><code>PROPAGATE</code></td><td>int</td><td>-3</td><td>共享模式下释放节点时设置的状态，被标记为当前状态是表示无限传播下去</td></tr><tr><td><code>0</code></td><td>int</td><td></td><td>不属于上面的任何一种状态</td></tr><tr><td>waitStatus</td><td>int</td><td>0</td><td>等待状态，默认初始化为0，表示正常同步等待，</td></tr><tr><td>pre</td><td>Node</td><td>Null</td><td>队列中上一个节点</td></tr><tr><td>next</td><td>Node</td><td>Null</td><td>队列中下一个节点</td></tr><tr><td>thread</td><td>Thread</td><td>Null</td><td>当前Node操作的线程</td></tr><tr><td>nextWaiter</td><td>Node</td><td>Null</td><td>指向下一个处于阻塞的节点</td></tr></tbody></table><p>通过上面的内容我们可以看到waitStatus其实是有5个状态的，虽然这里面0并不是什么字段，但是他是waitStatus状态的一种，表示不是任何一种类型的字段，上面也讲解了关于AQS中子类实现的方法，AQS提供了独占模式和共享模式两种，但是<code>ReentrantLock</code>实现的是独占模式的方式，下面来通过源码的方式解析<code>ReentrantLock</code>。</p><h2 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h2><p>首先在源码分析之前我们先来看一下ReentrantLock的类的继承关系，如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/1.jpg" alt="1"></p><p>可以看到<code>ReentrantLock</code>继承自<code>Lock</code>接口，它提供了一些获取锁和释放锁的方法，以及条件判断的获取的方法，通过实现它来进行锁的控制，它是显示锁，需要显示指定起始位置和终止位置，<code>Lock</code>接口的方法介绍：</p><table><thead><tr><th>方法名称</th><th>方法描述</th></tr></thead><tbody><tr><td>lock</td><td>用来获取锁，如果锁已被其他线程获取，则进行等待。</td></tr><tr><td>tryLock</td><td>表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</td></tr><tr><td>tryLock(long time, TimeUnit unit)</td><td>和tryLock()类似，区别在于它在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</td></tr><tr><td>lockInterruptibly</td><td>获取锁，如果获取锁失败则进行等到，如果等待的线程被中断会相应中断信息。</td></tr><tr><td>unlock</td><td>释放锁的操作</td></tr><tr><td>newCondition</td><td>获取Condition对象，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件wait()方法，而调用后，当前线程释放锁。</td></tr></tbody></table><p>ReentrantLock也实现了上面接口的内容，前面讲解了很多理论行的内容，接下来我们以一个简单的例子来进行探讨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先声明内部类AddDemo，AddDemo的主要作用是将原子变量count进行递增的操作</li><li>AddDemo内部声明了ReentrantLock对象进行同步操作</li><li>AddDemo的add方法，进行递增操作，细心地同学发现，使用了lock方法获取锁，但是没有释放锁，这里面没有释放锁可以更让我们清晰的分析内部结构的变化。</li><li>主线程开启了两个线程进行同步进行递增的操作，最后让线程休眠一会输出累加的最后结果。</li></ol><p><code>ReentrantLock</code>内部提供了两种AQS的实现，一种公平模式，一种是非公平模式，如果没有特别指定在构造器中，默认是非公平的模式，我们可以看一下无参的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用有参构造函数时，指定使用哪种模式来进行操作，参数为布尔类型，如果指定为false的话代表非公平模式，如果指定为true的话代表的是公平模式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用的是非公平模式，后面再来进行分析公平模式，上面也讲到了分为两种模式，这两种模式为<code>FairSync</code>和<code>NonfairSync</code>两个内部静态类不可变类，不能被继承和实例化，这两个类是我们今天分析的重点，为什么说是重点呢，这里讲的内容是有关于AQS的，而<code>FairSync</code>和<code>NonfairSync</code>实现了抽象内部类<code>Sync</code>，<code>Sync</code>实现了<code>AbstractQueuedSynchronizer</code>这个类，这个类就是我们说的AQS也是主要同步操作的类，下面我们来看一下公平模式和非公平模式下类的继承关系，如下图所示：</p><p>非公平模式：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/2.png" alt="2"></p><p>公平模式：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/3.png" alt="3"></p><p>通过上面两个继承关系UML来看其实无差别，差别在于内部实现的原理不一样，回到上面例子中使用的是非公平模式，那先以非公平模式来进行分析，</p><p>假设第一个线程启动调用AddDemo的add方法时，首先执行的事<code>reentrantLock.lock()</code>方法，这个lock方法调用了<code>sync.lock()</code>,sync就是我们上面提到的两种模式的对象，来看一下源码内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了<code>sync.lock()</code>,其实是调用了<code>NonfairSync</code>对象的<code>lock</code>方法，也就是下面的方法内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平模式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行锁动作，先进行修改状态，如果锁被占用则进行请求申请锁，申请锁失败则将线程放到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 继承自AQS的tryAcquire方法，尝试获取锁操作，这个方法会被AQS的acquire调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>lock</code>方法首先先对<code>state</code>状态进行修改操作，如果锁没有被占用则获取锁，并设置当前线程独占锁资源，如果尝试获取锁失败了，则进行<code>acqurie</code>方法的调用，例子中第一个线程当尝试获取锁是内部<code>state</code>状态为<code>0</code>，进行修改操作的时候，发现锁并没有被占用，则获得锁，此时我们来看一下内部变化的情况，如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/4.png" alt="4"></p><p>此时只是将<code>state</code>的状态更新为<code>1</code>，表示锁已经被占用了，独占锁资源的线程是<code>Thread0</code>，也就是<code>exclusiveOwnerThread</code>的内容，头节点和尾节点都没有被初始化，当第二个线程尝试去获取锁的时候，发现锁已经被占用了，因为上一个线程并没有释放锁，所以第二线程直接获取锁时获取失败则进入到<code>acquire</code>方法中，这个方法是<code>AbstractQueuedSynchronizer</code>中的方法<code>acquire</code>，先来看一下具体的实现源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人理解<code>acquire</code>方法不间断的尝试获取锁，如果锁没有获取到则现将节点加入到队列中，并将当前线程设置为独占锁资源，也就是独占了锁的意思，别的线程不能拥有锁，然后如果当前节点的前节点是头节点话，再去尝试争抢锁，则设置当前节点为头节点，并将原头节点的下一个节点设置为null，帮助GC回收它，如果不是头节点或争抢锁不成功，则会现将前面节点的状态设置直到设置为<code>SIGNAL</code>为止，代表下面有节点被等待了等待上一个线程发来的信号，然后就挂起当前线程。</p><p>我们接下来慢慢一步一步的分析，我们先来看一下<code>NonfairSync</code>中的<code>tryAcquire</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用的是他的父类方法，也就是<code>ReentrantLock</code>下<code>Sync</code>中的<code>nonfairTryAcquire</code>方法，这个方法主要就是去申请锁的操作，来看一下具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;<span class="comment">//首先是一个被final修饰的方法</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state的状态值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果状态等于0代表线程没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//cas修改state值</span></span><br><span class="line">            setExclusiveOwnerThread(current);<span class="comment">//设置当前线程为独占模式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//如果state状态不等于0则先判断是否是当前线程占用锁，如果是则进行下面的流程。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;<span class="comment">//这个地方就说明重入锁的原理，如果拥有锁的是当前线程，则每次获取锁state值都会跟随递增</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow//溢出了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);<span class="comment">//直接设置state值就可以不需要CAS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//都不是就返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以看到其实他是有三种操作逻辑：</p><ul><li>如果<code>state</code>为0，则代表锁没有被占用，尝试去修改state状态，并且将当前线程设置为独占锁资源，表示获得锁成功</li><li>如果<code>state</code>大于0并且拥有锁的线程和当前申请锁的线程一致，则代表重入了锁，<code>state</code>值会进行递增，表示获得锁成功</li><li>如果<code>state</code>大于0并且拥有锁的线程和当前申请锁的线程不一致则直接返回false，代表申请锁失败</li></ul><p>当第二个线程去争抢锁的时候，state值已经设置为1了也就是已经被第一个线程占用了锁，所以这里它会返回false，而通过<code>acquire</code>方法内容可以看到if语句中是<code>!tryAcquire(arg)</code>，也就是<code>!false=ture</code>，它会进行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code>方法，这个方法里面又有一个<code>addWaiter</code>方法，从方法语义上能看到是添加等待队列的操作，方法的参数代表的是模式，<code>Node.EXCLUSIVE</code>表示的是在独占模式下等待，我们先来看一下<code>addWaiter</code>里面是如何进行操作，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//首先生成当前线程拥有的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 下面的内容是尝试快速进行插入末尾的操作，在没有其他线程同时操作的情况</span></span><br><span class="line">    Node pred = tail;<span class="comment">//获取尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;<span class="comment">//尾节点不为空，代表队列不为空</span></span><br><span class="line">        node.prev = pred;<span class="comment">//尾节点设置为当前节点的前节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//修改尾节点为当前节点</span></span><br><span class="line">            pred.next = node;<span class="comment">//原尾节点的下一个节点设置为当前节点</span></span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">//返回node节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);<span class="comment">//如果前面入队失败，这里进行循环入队操作，直到入队成功</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面代码中可以看到，它有一个快速入队的操作，如果快速入队失败则进行死循环进行入队操作，当然我们上面例子中发现队列其实是为空的，也就是pred==null，不能进行快速入队操作，则进入到<code>enq</code>进行入队操作，下面看一下<code>enq</code>方法实现，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环进行入队操作，直到入队成功</span></span><br><span class="line">        Node t = tail;<span class="comment">//获取尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize//判断尾节点为空，则必须先进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))<span class="comment">//生成一个Node，并将当前Node作为头节点</span></span><br><span class="line">                tail = head;<span class="comment">//head和tail同时指向上面Node节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//设置入队的当前节点的前节点设置为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//将当前节点设置为尾节点</span></span><br><span class="line">                t.next = node;<span class="comment">//修改原有尾节点的下一个节点为当前节点</span></span><br><span class="line">                <span class="keyword">return</span> t;<span class="comment">//返回最新的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面入队操作，可以清晰的了解入队操作其实就是Node节点的prev节点和next节点之前的引用，运行到这里我们应该能看到入队的状态了，如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/5.png" alt="5"></p><p>如上图可以清晰的看到，此时拥有锁的线程是Thread0，而当前线程是Threa1，头节点为初始化的节点，<code>Ref-707</code>引用地址所在的Node节点操作当前操作的节点信息，入队操作后并没有完成，而是继续往下进行，此时则进行<code>acquireQueued</code>这个方法，这个方法是不间断的去获取已经入队队列中的前节点的状态，如果前节点的状态为大于0，则代表当前节点被取消了，会一直往前面的节点进行查找，如果节点状态小于0并且不等于<code>SIGNAL</code>则将其设置为<code>SIGNAL</code>状态，设置成功后将当前线程挂起，挂起线程后也有可能会反复唤醒挂起操作，原因后面会讲到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//取消节点标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//中断标志位</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//这里的逻辑是如果前节点为头结点并且获取到锁则进行头结点变换</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//设置waitStatus状态</span></span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//挂起线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//取消操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的源码可以看到它在<code>acquireQueued</code>中对已经入队的节点进行尝试锁的获取，如果锁获得就修改头节点的指针，如果不是头节点或者争抢锁失败时，此时会进入到<code>shouldParkAfterFailedAcquire</code>方法，这个方法是获取不到锁时需要停止继续无限期等待锁，其实就是内部的操作逻辑也很简单，就是如果前节点状态为<code>0</code>时，需要将前节点修改为<code>SIGNAL</code>，如果前节点大于<code>0</code>则代表前节点已经被取消了，应该移除队列，并将前前节点作为当前节点的前节点，一直循环直到前节点状态修改为<code>SIGNAL</code>或者前节点被释放锁，当前节点获取到锁停止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 此节点已经设置了状态，要求对当前节点进行挂起操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前节点被取消，则将取消节点移除队列操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus=0或者PROPAGATE时，表示当前节点还没有被挂起停止，需要等待信号来通知节点停止操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法其实很容易理解就是等待挂起信号，如果前节点的状态为0或PROPAGATE则将前节点修改为<code>SIGNAL</code>，则代表后面前节点释放锁后会通知下一个节点，也就是说唤醒下一个可以唤醒的节点继续争抢所资源，如果前节点被取消了那就继续往前寻找不是被取消的节点，这里不会找到前节点为null的情况，因为它默认会有一个空的头结点，也就是上图内容，此时的队列状态是如何的我们看一下，这里它会进来两次，以为我们上图可以看到当前节点前节点是<code>Ref-724</code>此时<code>waitStatus=0</code>，他需要先将状态更改为<code>SIGNAL</code>也就是运行最有一个else语句，此时又会回到外面的for循环中，由于方法返回的是false则不会运行<code>parkAndCheckInterrupt</code>方法，而是又循环了一次，此时发现当前节点争抢锁又失败了，然后此时队列的状态如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/6.png" alt="6"></p><p>再次进入到方法之后发现前驱节点的waitStatus=-1，表示当前节点需要进行挂起等到，此时返回的结果是true，则会运行<code>parkAndCheckInterrupt</code>方法，这个方法很简单就是将当前线程进行挂起操作，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">//挂起线程</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">//判断是否被中断，获取中断标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>park</code>挂起线程并且响应中断信息，其实我们从这里就能发现一个问题，Thread.interrupted方法是用来获取是否被中断的标志，如果被中断则返回true，如果没有被中断则返回false，当当前节点被中断后，其实就会返回true，返回true这里并没有结束，而是跳到调用地方，也就是<code>acquireQueued</code>方法内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>以一个案例来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以发现，thread1调用中断方法interrupt()，当调用第一次方法的时候，它会进入到<code>parkAndCheckInterrupt</code>方法，然后线程响应中断，最后返回true，最后返回到<code>acquireQueued</code>方法内部，整个if语句为true，则开始设置interrupted=true，仅仅是设置了等于true，但是这离还会进入下一轮的循环，假如说上次的线程没有完成任务，则没有获取到锁，还是会进入到<code>shouldParkAfterFailedAcquire</code>由于已经修改了上一个节点的waitStatus=-1，直接返回true，然后再进入到<code>parkAndCheckInterrupt</code>又被挂起线程，但是如果上步骤操作他正抢到锁，则会返回ture，外面也会清除中断标志位，从这里可以清楚地看到<code>acquire</code>方法是一个不间断获得锁的操作，可能重复阻塞和解除阻塞操作。</p><p>上面阻塞队列的内容已经讲完了，接下来我们看一下unlock都为我们做了什么工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到他直接调用了独占模式的<code>release</code>方法，看一下具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//调用ReentrantLock中的Sync里面的tryRelease方法</span></span><br><span class="line">        Node h = head;<span class="comment">//获取头节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//头节点不为空且状态不为0时进行unpark方法</span></span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒下一个未被取消的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release方法，首先先进行尝试去释放锁，如果释放锁仍然被占用则直接返回false，如果尝试释放锁时，发现锁已经释放，当前线程不在占用锁资源时，则会进入的下面进行一些列操作后返回true，接下来我们先来看一下<code>ReentrantLock</code>的<code>Sync</code>下的<code>tryRelease</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//获取state状态，标志信息减少1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">//线程不一致抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;<span class="comment">//是否已经释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//state=0时表示锁已经释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;<span class="comment">//将标志free设置为true</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//取消独占锁信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);<span class="comment">//设置锁标志信息</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的源码，表示首先先获取<code>state</code>状态，如果<code>state</code>状态减少1之后和0不相等则代表有重入锁，则表示当前线程还在占用所资源，直到线程释放锁返回ture标识，还是以上例子为主（此时<code>AddDemo</code>中的<code>unlock</code>不在被注释），分析其现在的队列中的状态</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/7.png" alt="7"></p><p>释放锁后，进入到if语句中，判断当前头节点不为空且<code>waitStatus!=0</code>，通过上图也可以发现头节点为-1，则进入到<code>unparkSuccessor</code>方法内：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取节点的waitStatus状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="comment">// 如果小于0则设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 唤醒下一个节点，唤醒下一个节点之前需要判断节点是否存在或已经被取消了节点，如果没有节点则不需唤醒操作，如果下一个节点被取消了则一直一个没有被取消的节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它是现将头节点的状态更新为0，然后再唤醒下一个节点，如果下一个节点为空则直接返回不唤醒任何节点，如果下一个节点被取消了，那么它会从尾节点往前进行遍历，遍历与头节点最近的没有被取消的节点进行唤醒操作，在唤醒前看一下队列状态：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/8.png" alt="8"></p><p>然后唤醒节点后他会进入到<code>parkAndCheckInterrupt</code>方法里面，再次去执行下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//取消节点标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//中断标志位</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//这里的逻辑是如果前节点为头结点并且获取到锁则进行头结点变换</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//设置waitStatus状态</span></span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//挂起线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//取消操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时获取p==head成立，并且可以正抢到所资源，所以它会进入到循环体内，进行设置头结点为当前节点，前节点的下一个节点设置为null，返回中断标志，看一下此时队列情况，如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/9.png" alt="9"></p><p><code>AbstractQueuedSynchronizer</code>的独占模式其实提供了三种不同的形式进行获取锁操作，看一下下表所示：</p><table><thead><tr><th>方法名称</th><th>方法描述</th><th>对应调用的内部方法</th></tr></thead><tbody><tr><td>acquire</td><td>以独占模式进行不间断的获取锁</td><td>tryAcquire，acquireQueued</td></tr><tr><td>acquireInterruptibly</td><td>以独占模式相应中断的方式获取锁，发生中断抛出异常</td><td>tryAcquire，doAcquireInterruptibly</td></tr><tr><td>tryAcquireNanos</td><td>以独占模式相应中断的方式并且在指定时间内获取锁，会阻塞一段时间，如果还未获得锁直接返回，发生中断抛出异常</td><td>tryAcquire，doAcquireNanos</td></tr></tbody></table><p>通过上面图可以发现，他都会调用图表一中需要用户实现的方法，<code>ReentrantLock</code>实现了独占模式则内部实现的是<code>tryAcquire</code>和<code>tryRelease</code>方法，用来尝试获取锁和尝试释放锁的操作，其实上面内容我们用的是<code>ReentrantLock</code>中的<code>lock</code>方法作为同步器，细心的朋友会发现，这个<code>lock</code>，方法是ReentrantLock实现的，它内部调用了<code>acquire</code>方法，实现了不间断的获取锁机制，<code>ReentrantLock</code>中还有一个<code>lockInterruptibly</code>方法，它内部直接调用的是<code>AbstractQueuedSynchronizer</code>的<code>acquireInterruptibly</code>方法，两个之间的区别在于，两者都会相应中断信息，前者不会做任何处理还会进入等待状态，而后者则抛出异常终止操作，</p><p>这里为了详细看清楚它内部关系我这里用张图来进行阐述，如下所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/10.png" alt="10"></p><ol><li>左侧代表的事ReentrantLock，右侧代表的AQS</li><li>左侧内部黄色区域代表<code>NonfairSync</code></li><li>图中1和2代表AQS调用其他方法的过程</li></ol><p>接下来我们来看一下源码信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现他调用的<code>Sync</code>类中的<code>acquireInterruptibly</code>方法，但其实这个方法是AQS中的方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//判断线程是否被中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//中断则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))<span class="comment">//尝试获取锁</span></span><br><span class="line">        doAcquireInterruptibly(arg);<span class="comment">//进行添加队列，并且修改前置节点状态，且响应中断抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，它也调用了子类实现的<code>tryAcquire</code>方法，这个方法和我们上文提到的<code>tryAcquire</code>是一样，<code>ReentrantLock</code>下的<code>NonfairSync</code>下的<code>tryAcquire</code>方法，这里这个方法就不多说了详细请看上文内容，这里主要讲一下<code>doAcquireInterruptibly</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//将节点添加到队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//失败匹配机制</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//如果前节点为头节点并且获得了锁</span></span><br><span class="line">                setHead(node);<span class="comment">//设置当前节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC//头节点的下一个节点设置为null</span></span><br><span class="line">                failed = <span class="keyword">false</span>;<span class="comment">//匹配失败变为false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//将前节点设置为-1，如果前节点为取消节点则往前一直寻找直到修改为-1为止。</span></span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//挂起线程返回是否中断</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法和<code>acquireQueued</code>区别在于以下几点：</p><ol><li><code>acquireQueued</code>是在方法内部添加节点到队列尾部，而<code>doAcquireInterruptibly</code>是在方法内部进行添加节点到尾部，这个区别点并不是很重要</li><li>重点是<code>acquireQueued</code>响应中断，但是他不会抛出异常，而后者会抛出异常throw new InterruptedException()</li></ol><p>分析到这里我们来用前面的例子来进行模拟一下中中断的操作，详细代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread3.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程被中断了"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子其实和前面提到的例子没有什么太大的差别主要的差别是将<code>lock</code>替换为<code>lockInterruptibly</code>，其次就是在三个线程后面讲线程1进行中断操作，这里入队的操作不在多说，因为操作内容和上面大致相同，下面是四个个线程操作完成的状态信息：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/11.png" alt="11"></p><p>如果线程等待的过程中抛出异常，则当前线程进入到finally中的时候failed为true，因为修改该字段只有获取到锁的时候才会修改为false，进来之后它会运行<code>cancelAcquire</code>来进行取消当前节点，下面我们先来分析下源码内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空直接返回，节点不存在直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 设置节点所在的线程为空，清除线程操作</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的前节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">  <span class="comment">// 如果前节点是取消节点则跳过前节点，一直寻找一个不是取消节点为止</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取头节点下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接设置为取消节点状态，没有使用CAS原因是因为直接设置只有其他线程可以跳过取消的节点</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点为尾节点，并且设置尾节点为找到的合适的前节点时，修改前节点的下一个节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是尾节点，则说明是中间节点，则需要通知后续节点，嘿，伙计你被唤醒了。</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;<span class="comment">//前节点不是头结点</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||<span class="comment">// 前节点的状态为SIGNAL </span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) <span class="comment">//或者前节点状态小于0而且修改前节点状态为SIGNAL成功 </span></span><br><span class="line">           &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;<span class="comment">//前节点线程不为空</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//唤醒下一个不是取消的节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到当前节点的前节点，如果前节点为取消节点则一直往前寻找一个节点。</li><li>取消的是尾节点，则直接将前节点的下一个节点设置为null</li><li>如果取消的是头节点的下一个节点，且不是尾节点的情况时，它是唤醒下一个节点，唤醒之前并没有将其移除队列，而是在唤醒下一个节点的时候，<code>shouldParkAfterFailedAcquire</code>里面将取消的节点移除队列，唤醒之后，当前节点的下一个节点也设置成自己，帮助GC回收它。</li><li>如果取消节点是中间的节点，则直接将其前节点的下一个节点设置为取消节点的下下个节点即可。</li></ol><p>第一种情况如果我们取消的节点是前节点是头节点，此时线程1的节点应该是被中断操作，此时进入到<code>cancelAcquire</code>之后会进入else语句中，然后进去到<code>unparkSuccessor</code>方法，当进入到这个方法之前我们看一下状态变化：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/12.png" alt="12"></p><p>我们发现线程1的Node节点的waitStatus变为1也就是<code>Node.CANCELLED</code>节点，然后运行<code>unparkSuccessor</code>方法，该方法上面就已经讲述了其中的源码，这里就不在贴源码了，就是要唤醒下一个没有被取消的节点，这里是<code>Ref-695</code>这个线程，当<code>Ref-695</code>被唤醒之后它会继续运行下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//再一次循环发现还是没有争抢到锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//再一次循环之后有运行到这里了</span></span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//这里被唤醒了，又要进行循环操作了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现再一次循环操作后，还是没有正抢到锁，这时候还是会运行<code>shouldParkAfterFailedAcquire</code>方法，这个方法内部发现前节点的状态是<code>Node.CANCELLED</code>这时候它会在内部先将节点给干掉，也就是这个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">     * indicate retry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还是会被挂起状态，因为没有释放锁操作，最后移除的节点如下所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/13.png" alt="13"></p><p>如果取消的事尾节点，也就是线程3被中断操作，这个是比较简单的直接将尾节点删除即可，其中会走如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/15.png" alt="15"></p><p>如果取消的节点是中间的节点，通过上例子中则是取消线程2，其实它内部只是将线程取消线程的前节点的下一个节点指向了取消节点的下节点，如下图所示：</p><p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/16.png" alt="16"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这章节分析的主要是<code>ReentrantLock</code>的内部原理，本来公平模式和非公平模式想放在一起来写，无奈发现篇幅有点长了，所以就分开进行写，这样读取来不会那么费劲，内部还有条件内容等待下章节分析，如果有分析不到位的请大家指正。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SynchronousQueue原理详解-非公平模式</title>
      <link href="/2019/05/18/synchronousqueue-principle-unfair-pattern/"/>
      <url>/2019/05/18/synchronousqueue-principle-unfair-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="SynchronousQueue原理详解-非公平模式"><a href="#SynchronousQueue原理详解-非公平模式" class="headerlink" title="SynchronousQueue原理详解-非公平模式"></a>SynchronousQueue原理详解-非公平模式</h1><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><blockquote><p>说明：本文分析采用的是jdk1.8</p><p>约定：下面内容中Ref-xxx代表的是引用地址，引用对应的节点</p></blockquote><p>前面已经讲解了公平模式的内容，今天来讲解下关于非公平模式下的SynchronousQueue是如何进行工作的，在源码分析的时候，先来简单看一下非公平模式的简单原理，它采用的栈这种FILO先进后出的方式进行非公平处理，它内部有三种状态，分别是REQUEST，DATA，FULFILLING，其中REQUEST代表的数据请求的操作也就是take操作，而DATA表示的是数据也就是Put操作将数据存放到栈中，用于消费者进行获取操作，而FULFILLING代表的是可以进行互补操作的状态，其实和前面讲的公平模式也很类似。</p><p>当有相同模式情况下进行入栈操作，相同操作指的是REQUEST和DATA两种类型中任意一种进行操作时，模式相同则进行入栈操作，如下图所示：</p><p>同REQUEST进行获取数据时的入栈情况：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/1.png" alt="1"></p><p>同样的put的操作，进行数据操作时为DATA类型的操作，此时队列情况为：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/2.png" alt="2"></p><p>不同模式下又是如何进行操作的？当有不同模式进来的时候，他不是将当前的模式压入栈顶，而是将FullFill模式和当前模式进行按位或之后压入栈顶，也就是压入一个进行FullFill请求的模式进入栈顶，请求配对操作，如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/3.png" alt="3"></p><p>通过上图可见，本来栈中有一个DATA模式的数据等待消费者进行消费，这时候来了一个REQUEST模式的请求操作来进行消费数据，这时候并没有将REQUEST模式直接压入栈顶，而是将其转换为FULLFILLING模式，并且保留了原有的类型，这是进行FULLFILLING的请求，请求和栈顶下方元素进行匹配，当匹配成功后将栈顶和匹配元素同时进行出栈操作，详细请见下文分析：</p><h2 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h2><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 消费者模式 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** 提供者模式 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** 互补模式 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** 栈顶指针 */</span></span><br><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>isFulfilling</td><td>判断指定类型是否是互补模式</td></tr><tr><td>casHead</td><td>替换当前头结点</td></tr><tr><td>snode</td><td>生成SNode节点对象</td></tr><tr><td>transfer</td><td>主要处理逻辑</td></tr><tr><td>awaitFulfill</td><td>等待fulfill操作</td></tr><tr><td>shouldSpin</td><td>判断节点s是头结点或是fulfill节点则返回true</td></tr></tbody></table><h3 id="SNode内容"><a href="#SNode内容" class="headerlink" title="SNode内容"></a>SNode内容</h3><h4 id="字段信息-1"><a href="#字段信息-1" class="headerlink" title="字段信息"></a>字段信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode next;        <span class="comment">// 栈下一个元素</span></span><br><span class="line"><span class="keyword">volatile</span> SNode match;       <span class="comment">// 匹配的节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;     <span class="comment">// 控制park/unpark的线程</span></span><br><span class="line">Object item;                <span class="comment">// 数据或请求</span></span><br><span class="line"><span class="keyword">int</span> mode;<span class="comment">// 模式，上面介绍的三种模式</span></span><br></pre></td></tr></table></figure><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>casNext</td><td>判断指定类型是否是互补模式</td></tr><tr><td>tryMatch</td><td>尝试匹配节点，如果存在匹配节点则判断是否是当前节点，直接返回判断结果，如果没有则替换match内容并且唤醒线程</td></tr><tr><td>tryCancel</td><td>取消当前节点，将当前节点的match节点设置为当前节点(this)</td></tr><tr><td>isCancelled</td><td>判断match节点是不是等于当前节点</td></tr></tbody></table><p>经过上面内容的分析，接下来就进入正题，让我们整体先看一下下transfer都为我们做了些什么内容，下面是transfer源码内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment">     *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment">     *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment">     *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment">     *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment">     *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment">     *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment">     *    other threads performing action 3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment">     *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment">     *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment">     *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment">     *    that it doesn't return the item.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        SNode h = head;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// 栈顶指针为空或者是模式相同</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// 制定了timed并且时间小于等于0则取消操作。</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    casHead(h, h.next);     <span class="comment">// 判断头结点是否被取消了取消了就弹出队列，将头结点指向下一个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;<span class="comment">// 初始化新节点并且修改栈顶指针</span></span><br><span class="line">                SNode m = awaitFulfill(s, timed, nanos);<span class="comment">// 进行等待操作</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// 返回内容是本身则进行清理操作</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// 尝试去匹配</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// 判断是否已经被取消了</span></span><br><span class="line">                casHead(h, h.next);         <span class="comment">// 弹出取消的节点并且从新进入主循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;<span class="comment">//新建一个Full节点压入栈顶</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; <span class="comment">// 循环直到匹配</span></span><br><span class="line">                    SNode m = s.next;       <span class="comment">// s的下一个节点为匹配节点</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// 代表没有等待内容了</span></span><br><span class="line">                        casHead(s, <span class="keyword">null</span>);   <span class="comment">// 弹出full节点</span></span><br><span class="line">                        s = <span class="keyword">null</span>;           <span class="comment">// 设置为null用于下次生成新的节点</span></span><br><span class="line">                        <span class="keyword">break</span>;              <span class="comment">// 退回到主循环中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn);     <span class="comment">// 弹出s节点和m节点两个节点</span></span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span>                  <span class="comment">// 如果失去了匹配</span></span><br><span class="line">                        s.casNext(m, mn);   <span class="comment">// 帮助取消连接</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 这里是帮助进行fillull</span></span><br><span class="line">            SNode m = h.next;               <span class="comment">// m是头结点的匹配节点</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// 如果m不存在则直接将头节点赋值为nll</span></span><br><span class="line">                casHead(h, <span class="keyword">null</span>);           <span class="comment">// 弹出fulfill节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// h节点尝试匹配m节点</span></span><br><span class="line">                    casHead(h, mn);         <span class="comment">// 弹出h和m节点</span></span><br><span class="line">                <span class="keyword">else</span>                        <span class="comment">// 丢失匹配则直接将头结点的下一个节点赋值为头结点的下下节点</span></span><br><span class="line">                    h.casNext(m, mn);       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模式相同的时候则进行等待操作，入队等待操作</li><li>当模式不相同时，首先判断头结点是否是fulfill节点如果不是则进行匹配操作，如果是fulfill节点先帮助头结点的fulfill节点进行匹配操作</li></ol><p>接下来再来看一下<code>awaitFulfill</code>方法内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">  <span class="comment">// 等待线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 等待时间设置</span></span><br><span class="line">    <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())<span class="comment">// 判断当前线程是否被中断 </span></span><br><span class="line">            s.tryCancel();<span class="comment">// 尝试取消操作 </span></span><br><span class="line">        SNode m = s.match;<span class="comment">// 获取当前节点的匹配节点，如果节点不为null代表匹配或取消操作，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，其实我们之前分析同步模式的时候差不太多，变化的地方其中包括返回内容判断这里判断的是match节点是否为null，还有就是spins时间设置这里发现了<code>shoudSpin</code>用来判断是否进行轮训，来看一下<code>shouldSpin</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断节点是否是fulfill节点，或者是头结点为空再或者是头结点和当前节点相等时则不需要进行轮训操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    SNode h = head;</span><br><span class="line">    <span class="keyword">return</span> (h == s || h == <span class="keyword">null</span> || isFulfilling(h.mode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是判断节点是否是fulfill节点，或者是头结点为空再或者是头结点和当前节点相等时则不需要进行轮训操作，如果满足上述条件就不小进行轮训等到操作了直接进行等待就行了。</p><p>接下来我们来用例子一点点解析原理：</p><p>首先先进行一个put操作，这样可以简单分析下内部信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue原理内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先它会进入到transfer方法中，进行第一步的判断他的类型信息，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"><span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看到e=1所以是DATA类型，接下来进行判断是如何进行操作，当前堆栈是空的，如何判断堆栈为空呢？上面也讲到了<code>head</code>节点为空时则代表堆栈为空，接下来就要判断如果head节点为空或head指向的节点和当前操作内容模式相同，则进行等待操作，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SNode h = head;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// empty or same-mode</span></span><br><span class="line">    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// can't wait</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">            casHead(h, h.next);     <span class="comment">// pop cancelled node</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">        SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">        <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">            clean(s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">            casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line">        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然头结点是空的，所以进入到第一个fi语句中执行等待操作，如果指定了timed则判断时间是否小于0，如果小于0则直接null，反之判断当前节点是否不是头结点以及头结点是否取消，潘祖条件弹出头结点，并将下一个节点设置为头结点，上述条件在当前例子中都不满足，所以要进入到下面这段代码中，首先进行对s进行初始化值，并且进行入栈操作，<code>casHead(h, s = snode(s, e, h, mode))</code>，下面看一下栈中的情况如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/4.png" alt="4"></p><p>当执行完了入栈操作之后接下来要执行<code>awaitFulfill</code>这里的操作就是轮训以及将当前节点的线程赋值，并且挂起当前线程。此时的栈的情况如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/5.png" alt="5"></p><p>当有同样的模式进行操作时候也是重复上述的操作内容，我们这里模拟两次put操作，让让我们看一下栈中的情况如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/6.png" alt="6"></p><p>通过上图可以看到，其实就是将头结点移动到了新的节点上，然后新节点的next节点维护这下一个节点的引用，好了，上述内容分析是同模式的操作，接下来我们试着进行take操作时，这时候会发什么内容呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue例子二进行两次put操作和一次take操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread thread6 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      thread6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子正好符合上面例子两次put操作的截图，进行两次put操作过后再进行take操作，接下来我们来看一下take操作是如何进行操作的，换句话说当有不同模式的操作时又是如何进行处理呢？上面分析的内容是同种操作模式下的，当有不同操作则会走下面内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// try to fulfill</span></span><br><span class="line">    <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">        casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">            SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">            &#125;</span><br><span class="line">            SNode mn = m.next;</span><br><span class="line">            <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">    SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">        casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SNode mn = m.next;</span><br><span class="line">        <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">            casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">            h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最下面的else我们等会来进行分析，我们看到如果不是同模式的话，则会先判断是否是fulfill模式，如果不是fulfill模式，则进入到第一个if语句中，显然通过<code>图示6</code>可以得出，头结点<code>head</code>模式并不是fillfull模式，则进入到该if语句中，上来首先判断当前头结点是否被取消了，如果被取消则将头结点移动到栈顶下一个节点，反之则将s节点赋值为fulfill模式按位或当前节点模式，个人认为目的是既保留了原有模式也变成了fulfill模式，我们开篇就讲到了，REQUEST=0，二进制则是00，而DATA=1，其二进制为01，而FULFILLING=2，其二进制表示10，也就是说如果当前节点是REQUEST的话那么节点的内容值时00|10=10，如果节点是DATA模式则s节点的模式时01|10=11，这样的话11既保留了原有模式也是FULFILLING模式，然后将头节点移动到当前s节点，也就是将FULFILLING模式节点入栈操作，目前分析到这里时<code>casHead(h, s=snode(s, e, h, FULFILLING|mode)</code>，栈的情况如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/7.png" alt="7"></p><p>接下来运行for循环里面内容，先运行如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">    casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">    s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">    <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断当前节点也就是头结点s的下一个节点上图中head=s节点，所以s.next节点代表的是<code>Ref-750</code>，判断当前节点是否为空，如果为空的话代表没有可匹配的节点，先对head进行替换为null代表堆栈为空，然后将当前s节点设置为null，退出fulfill匹配模式进入到主循环中，会重新进行对当前节点进行操作，是消费还是匹配，显然本例子中m节点是不为空的，所以这里不会运行，跳过之后运行下面内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SNode mn = m.next;</span><br><span class="line"><span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">    casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">&#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">    s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br></pre></td></tr></table></figure><p>mn节点在上图中对应的是<code>Ref-681</code>，这里是重点，<code>m.tryMatch(s)</code>，m节点尝试匹配s节点，进入到方法里，到这一步是我们再来看一下头结点的元素的内容：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/8.png" alt="8"></p><p>并且唤醒m节点的，告诉m节点，你现在有匹配的对象了你可以被唤醒了，这里唤醒之后就会进入到<code>awaitFulfill</code>下面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (m == s) &#123;               <span class="comment">// wait was cancelled</span></span><br><span class="line">    clean(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">    casHead(h, s.next);     <span class="comment">// help s's fulfiller</span></span><br><span class="line"><span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br></pre></td></tr></table></figure><p>运行这里的线程显然是上图中的m节点，因为m节点被唤醒了，m==s代表的是取消了节点，显然没有进行该操作，然后就是帮助头结点进行fulfill操作，这里重点说一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)</span><br><span class="line">    casHead(h, s.next);</span><br></pre></td></tr></table></figure><p>获取当前头结点，也就是上图中的头结点如果不为空而且h.next节点为m节点正好是m节点进行操作时的s节点，也就是说这个语句是成立的，直接将头节点指向了上图的mn节点，这里的操作和take中的下面操作是一样的，也就是帮助fulfill操作弹出栈顶和栈顶匹配的节点内容，下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SNode mn = m.next;</span><br><span class="line"><span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">    casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">&#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">    s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br></pre></td></tr></table></figure><p>重点是casHead的代码，弹出s和m两个节点，此时栈中内容如下图所示：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/9.png" alt="9"></p><p>主要的流程分析完毕了，但是细心的朋友会发现，最后面还有一个帮助fulfill的操作，（transfer中）代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;                            <span class="comment">// help a fulfiller</span></span><br><span class="line">    SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">        casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SNode mn = m.next;</span><br><span class="line">        <span class="keyword">if</span> (m.tryMatch(h))          <span class="comment">// help match</span></span><br><span class="line">            casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// lost match</span></span><br><span class="line">            h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解是这样的，我们上面也分析到了如果模式是相同模式情况和如果是不同模式且模式不为匹配模式的情况，但是还会有另外一种情况就是如果是不同模式并且头结点是匹配模式的就会进入到帮助去fullfill的情况，我来画图说明一下该情况：</p><p><img src="/2019/05/18/synchronousqueue-principle-unfair-pattern/10.png" alt="10"></p><p>如上图所示，上一个匹配操作没有进行完然后又来了一个请求操作，他就会帮助head进行匹配操作，也就是运行上面的代码逻辑，逻辑和匹配内容是一样的。</p><p>接下来让我们看一下取消的clean方法内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    s.item = <span class="keyword">null</span>;   <span class="comment">// 将item值设置为null</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// 将线程设置为null</span></span><br><span class="line"></span><br><span class="line">    SNode past = s.next;   <span class="comment">// s节点下一个节点如果不为空，并且节点是取消节点则指向下下个节点，这里是结束的标识，代表没有了。</span></span><br><span class="line">    <span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">        past = past.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消的是头节点则运行下面的清理操作，操作逻辑很简单就是判断头结点是不是取消节点，如果是则将节点一定到下一个节点</span></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">        casHead(p, p.next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消不是头结点的嵌套节点。</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">        SNode n = p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">            p.casNext(n, n.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到首先是先找到一个可以结束的标识past，也就说到这里就结束了，判断是否不是头节点被取消了，如果是头节点被取消了则进行第一个while语句，操作也很简单就是将头节点替换头结点的下一个节点，如果不是头节点被取消了则进行下面的while语句操作，其实就是将取消的上一个节点的下一个节点指定为被取消节点的下一个节点，到此分析完毕了。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>如果有分析不正确的请各位指正，我这边改正~</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SynchronousQueue原理详解-公平模式</title>
      <link href="/2019/05/04/synchronousqueue-principle-fair-pattern/"/>
      <url>/2019/05/04/synchronousqueue-principle-fair-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="SynchronousQueue原理详解-公平模式"><a href="#SynchronousQueue原理详解-公平模式" class="headerlink" title="SynchronousQueue原理详解-公平模式"></a>SynchronousQueue原理详解-公平模式</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>SynchronousQueue是一个双栈双队列算法，无空间的队列或栈，任何一个对SynchronousQueue写需要等到一个对SynchronousQueue的读操作，反之亦然。一个读操作需要等待一个写操作，相当于是交换通道，提供者和消费者是需要组队完成工作，缺少一个将会阻塞线程，知道等到配对为止。</p><p>SynchronousQueue是一个队列和栈算法实现，在SynchronousQueue中双队列FIFO提供公平模式，而双栈LIFO提供的则是非公平模式。</p><p>对于SynchronousQueue来说，他的put方法和take方法都被抽象成统一方法来进行操作，通过抽象出内部类Transferer，来实现不同的操作。</p><blockquote><p>注意事项：本文分析主要是针对jdk1.8的版本进行分析，下面的代码中的线程执行顺序可能并不能完全保证顺序性，执行时间比较短，所以暂且认定有序执行。</p><p>约定：图片中以Reference-开头的代表对象的引用地址，通过箭头方式进行引用对象。</p></blockquote><p>Transferer.transfer方法主要介绍如下所示：        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行put和take方法.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 非空时,表示这个元素要传递给消费者（提供者-put）;</span></span><br><span class="line"><span class="comment">     *          为空时, 则表示当前操作要请求消费一个数据（消费者-take）。</span></span><br><span class="line"><span class="comment">     *          offered by producer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed 决定是否存在timeout时间。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos 超时时长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回非空, 代表数据已经被消费或者正常提供; 如果为空,</span></span><br><span class="line"><span class="comment">     *         则表示由于超时或中断导致失败。可通过Thread.interrupted来检查是那种。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下SynchronousQueue的字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** CPU数量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋次数，如果transfer指定了timeout时间，则使用maxTimeSpins,如果CPU数量小于2则自旋次数为0，否则为32</span></span><br><span class="line"><span class="comment"> * 此值为经验值，不随CPU数量增加而变化，这里只是个常量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋次数，如果没有指定时间设置，则使用maxUntimedSpins。如果NCPUS数量大于等于2则设定为为32*16，否则为0；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure><ul><li>NCPUS：代表CPU的数量</li><li>maxTimedSpins：自旋次数，如果transfer指定了timeout时间，则使用maxTimeSpins,如果CPU数量小于2则自旋次数为0，否则为32，此值为经验值，不随CPU数量增加而变化，这里只是个常量。</li><li>maxUntimedSpins：自旋次数，如果没有指定时间设置，则使用maxUntimedSpins。如果NCPUS数量大于等于2则设定为为32*16，否则为0；</li><li>spinForTimeoutThreshold：为了防止自定义的时间限过长，而设置的，如果设置的时间限长于这个值则取这个spinForTimeoutThreshold 为时间限。这是为了优化而考虑的。这个的单位为纳秒。</li></ul><h2 id="公平模式-TransferQueue"><a href="#公平模式-TransferQueue" class="headerlink" title="公平模式-TransferQueue"></a>公平模式-TransferQueue</h2><p>TransferQueue内部是如何进行工作的，这里先大致讲解下，队列采用了互补模式进行等待，QNode中有一个字段是isData，如果模式相同或空队列时进行等待操作，互补的情况下就进行消费操作。</p><p>入队操作相同模式</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/24.png" alt=""></p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/25.png" alt=""></p><p>不同模式时进行出队列操作：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/26.png" alt=""></p><p>这时候来了一个isData=false的互补模式，队列就会变成如下状态：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/27.png" alt=""></p><p>TransferQueue继承自Transferer抽象类，并且实现了transfer方法，它主要包含以下内容:</p><h3 id="QNode"><a href="#QNode" class="headerlink" title="QNode"></a>QNode</h3><p>代表队列中的节点元素，它内部包含以下字段信息：</p><ol><li>字段信息描述</li></ol><table><thead><tr><th>字段</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>next</td><td>下一个节点</td><td>QNode</td></tr><tr><td>item</td><td>元素信息</td><td>Object</td></tr><tr><td>waiter</td><td>当前等待的线程</td><td>Thread</td></tr><tr><td>isData</td><td>是否是数据</td><td>boolean</td></tr></tbody></table><ol start="2"><li>方法信息描述</li></ol><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>casNext</td><td>替换当前节点的next节点</td></tr><tr><td>casItem</td><td>替换当前节点的item数据</td></tr><tr><td>tryCancel</td><td>取消当前操作，将当前item赋值为this(当前QNode节点)</td></tr><tr><td>isCancelled</td><td>如果item是this(当前QNode节点)的话就返回true，反之返回false</td></tr><tr><td>isOffList</td><td>如果已知此节点离队列，判断next节点是不是为this，则返回true，因为由于* advanceHead操作而忘记了其下一个指针。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">     * two actions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">     *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">     *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">     *    call is of complementary mode, try to fulfill by CAS'ing</span></span><br><span class="line"><span class="comment">     *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">     *    returning matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">     * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">     * threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">     * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">     * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">     * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">     * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">     * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">     * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// 分为两种状态1.有数据=true 2.无数据=false</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 循环内容</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 尾部节点。</span></span><br><span class="line">        QNode t = tail;</span><br><span class="line">        <span class="comment">// 头部节点。</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">// 判断头部和尾部如果有一个为null则自旋转。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// 还未进行初始化的值。</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// 自旋</span></span><br><span class="line">        <span class="comment">// 头结点和尾节点相同或者尾节点的模式和当前节点模式相同。</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 空或同模式。</span></span><br><span class="line">            <span class="comment">// tn为尾节点的下一个节点信息。</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 这里我认为是阅读不一致，原因是当前线程还没有阻塞的时候其他线程已经修改了尾节点tail会导致当前线程的tail节点不一致。</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 这里如果指定timed判断时间小于等于0直接返回。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 判断新增节点是否为null,为null直接构建新节点。</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 如果next节点不为null说明已经有其他线程进行tail操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将t节点替换为s节点</span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">            <span class="comment">// 等待有消费者消费线程。</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 如果返回的x，指的是s.item,如果s.item指向自己的话清除操作。</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有取消联系</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点替换头结点</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// 取消item值，这里是take方法时会进行item赋值为this</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                <span class="comment">// 将等待线程设置为null</span></span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            <span class="comment">// 获取头结点下一个节点</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="comment">// 如果当前线程尾节点和全局尾节点不一致,重新开始</span></span><br><span class="line">            <span class="comment">// 头结点的next节点为空，代表无下一个节点，则重新开始，</span></span><br><span class="line">            <span class="comment">// 当前线程头结点和全局头结点不相等，则重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下awaitFulfill方法内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果指定了timed则为System.nanoTime() + nanos，反之为0。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 获取当前线程。</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果头节点下一个节点是当前s节点(以防止其他线程已经修改了head节点)</span></span><br><span class="line">    <span class="comment">// 则运算(timed ? maxTimedSpins : maxUntimedSpins)，否则直接返回。</span></span><br><span class="line">    <span class="comment">// 指定了timed则使用maxTimedSpins，反之使用maxUntimedSpins</span></span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经被中断。</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">//尝试取消，将当前节点的item修改为当前节点(this)。</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="comment">// 获取当前节点内容。</span></span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="comment">// 判断当前值和节点值不相同是返回，因为弹出时会将item值赋值为null。</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先先判断有没有被中断，如果被中断则取消本次操作，将当前节点的item内容赋值为当前节点。</li><li>判断当前节点和节点值不相同是返回</li><li>将当前线程赋值给当前节点</li><li>自旋，如果指定了timed则使用<code>LockSupport.parkNanos(this, nanos);</code>，如果没有指定则使用<code>LockSupport.park(this);</code>。</li><li>中断相应是在下次才能被执行。</li></ol><p>通过上面源码分析我们这里做出简单的示例代码演示一下put操作和take操作是如何进行运作的，首先看一下示例代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue进行put和take操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来之后进行的是两次take操作，然后再put操作，默认队列上来会进行初始化，初始化的内容如下代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化后队列的状态如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/16.png" alt="16"></p><p>当线程1执行put操作时，来分析下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail;</span><br><span class="line">QNode h = head;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>首先执行局部变量t代表队尾指针，h代表队头指针，判断队头和队尾不为空则进行下面的操作，接下来是if…else语句这里是分水岭，当相同模式操作的时候执行if语句，当进行不同模式操作时执行的是else语句，程序是如何控制这样的操作的呢？接下来我们慢慢分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 队列为空或者模式相同时进行if语句</span></span><br><span class="line">    QNode tn = t.next;</span><br><span class="line">    <span class="keyword">if</span> (t != tail)                  <span class="comment">// 判断t是否是队尾，不是则重新循环。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// tn是队尾的下个节点，如果tn有内容则将队尾更换为tn，并且重新循环操作。</span></span><br><span class="line">        advanceTail(t, tn);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 如果指定了timed并且延时时间用尽则直接返回空，这里操作主要是offer操作时，因为队列无存储空间的当offer时不允许插入。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)                  <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">        s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">    <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    advanceTail(t, s);              <span class="comment">// 队尾移动</span></span><br><span class="line">    Object x = awaitFulfill(s, e, timed, nanos);<span class="comment">//自旋并且设置线程。</span></span><br><span class="line">    <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">        clean(t, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">        advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">            s.item = s;</span><br><span class="line">        s.waiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是if语句中的内容，进入到if语句中的判断是如果头结点和尾节点相等代表队列为空，并没有元素所有要进行插入队列的操作，或者是队尾的节点的isData标志和当前操作的节点的类型一样时，会进行入队操作，isData标识当前元素是否是数据，如果为true代表是数据，如果为false则代表不是数据，换句话说只有模式相同的时候才会往队列中存放，如果不是模式相同的时候则代表互补模式，就不走if语句了，而是走了else语句，上面代码中做有注释讲解，下面看一下这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)                  <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">    s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line"><span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>当执行上面代码后，队列的情况如下图所示：(这里视为<code>插入第一个元素</code>图，方便下面的引用)</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/17.png" alt="17"></p><p>接下来执行这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advanceTail(t, s);              <span class="comment">// 队尾移动</span></span><br></pre></td></tr></table></figure><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/18.png" alt="18"></p><p>修改了tail节点后，这时候就需要进行自旋操作，并且设置QNode的waiter等待线程，并且将线程等待，等到唤醒线程进行唤醒操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);<span class="comment">//自旋并且设置线程。</span></span><br></pre></td></tr></table></figure><p>方法内部分析局部内容，上面已经全部内容的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">    --spins;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">    s.waiter = w;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br></pre></td></tr></table></figure><p>如果自旋时间spins还有则进行循环递减操作，接下来判断如果当前节点的waiter是空则价格当前线程赋值给waiter，上图中显然是为空的所以会把当前线程进行赋值给我waiter，接下来就是等待操作了。</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/19.png" alt="19"></p><p>上面线程则处于等待状态，接下来是线程二进行操作，这里不进行重复进行，插入第二个元素队列的状况，此时线程二也处于等待状态。</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/20.png" alt="20"></p><p>上面的主要是put了两次操作后队列的情况，接下来分析一下take操作时又是如何进行操作的，当take操作时，isData为false，而队尾的isData为true两个不相等，所以不会进入到if语句，而是进入到了else语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 互补模式</span></span><br><span class="line">    QNode m = h.next;               <span class="comment">// 获取头结点的下一个节点，进行互补操作。</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">        <span class="keyword">continue</span>;                   <span class="comment">// 这里就是为了防止阅读不一致的问题</span></span><br><span class="line"></span><br><span class="line">    Object x = m.item;</span><br><span class="line">    <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// 如果x=null说明已经被读取了。</span></span><br><span class="line">        x == m ||                   <span class="comment">// x节点和m节点相等说明被中断操作，被取消操作了。</span></span><br><span class="line">        !m.casItem(x, e)) &#123;         <span class="comment">// 这里是将item值设置为null</span></span><br><span class="line">        advanceHead(h, m);          <span class="comment">// 移动头结点到头结点的下一个节点</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">    LockSupport.unpark(m.waiter);</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取头结点的下一个节点用于互补操作，也就是take操作，接下来进行阅读不一致的判断，防止其他线程进行了阅读操作，接下来获取需要弹出内容x=1，首先进行判断节点内容是不是已经被消费了，节点内容为null时则代表被消费了，接下来判断节点的item值是不是和本身相等如果相等话说明节点被取消了或者被中断了，然后移动头结点到下一个节点上，然后将<code>refenrence-715</code>的item值修改为null，<code>至于为什么修改为null这里留下一个悬念，这里还是比较重要的，大家看到这里的时候需要注意下</code>，显然这些都不会成立，所以if语句中内容不会被执行，接下来的队列的状态是是这个样子的：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/21.png" alt="21"></p><p>OK，接下来就开始移动队头head了，将head移动到m节点上，执行代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advanceHead(h, m);</span><br></pre></td></tr></table></figure><p>此时队列的状态是这个样子的：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/22.png" alt="22"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.unpark(m.waiter);</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br></pre></td></tr></table></figure><p>接下来将执行唤醒被等待的线程，也就是thread-0，然后返回获取item值1，take方法结束，但是这里并没有结束，因为唤醒了put的线程，此时会切换到put方法中，这时候线程唤醒后会执行<code>awaitFulfill</code>方法，此时循环时，有与item值修改为null则直接返回内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p>这里的代码我们可以对照<code>插入第一个元素</code>图，s节点也就是当前m节点，获取值得时候已经修改为null，但是当时插入的值时1，所以两个不想等了，则直接返回null值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">    advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">        s.item = s;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br></pre></td></tr></table></figure><p>又返回到了transfer方法的if语句中，此时x和s并不相等所以不用进行clean操作，首先判断s节点是否已经离队了，显然并没有进行离队操作，<code>advanceHead(t, s);</code>操作不会被执行因为上面已近将头节点修改了，但是第一次插入的时候头结点还是<code>reference-716</code>，此时已经是<code>reference-715</code>,而t节点的引用地址是<code>reference-716</code>，所以不会操作，接下来就是将waiter设置为null，也就是忘记掉等待的线程。</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/23.png" alt="22"></p><p>分析了正常的take和put操作，接下来分析下中断操作，由于中断相应后，会被执行<code>if(w.isInterrupted())</code>这段代码，它会执行<code>s.tryCancel(e)</code>方法，这个方法的作用的是将QNode节点的item节点赋值为当前QNode，这时候x和e值就不相等了（<code>if (x != e)</code>），x的值是s.item，则为当前QNode，而e的值是用户指定的值，这时候返回x(s.item)。返回到函数调用地方<code>transfer</code>中，这时候要执行下面语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到clean方法执行清理当前节点，下面是方法clean代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets rid of cancelled node s with original predecessor pred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At any given time, exactly one node on list cannot be</span></span><br><span class="line"><span class="comment">     * deleted -- the last inserted node. To accommodate this,</span></span><br><span class="line"><span class="comment">     * if we cannot delete s, we save its predecessor as</span></span><br><span class="line"><span class="comment">     * "cleanMe", deleting the previously saved version</span></span><br><span class="line"><span class="comment">     * first. At least one of node s or the node previously</span></span><br><span class="line"><span class="comment">     * saved can always be deleted, so this always terminates.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (pred.next == s) &#123; <span class="comment">// Return early if already unlinked</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line">        <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">            advanceHead(h, hn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line">        <span class="keyword">if</span> (t == h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="comment">// 判断现在的t是不是末尾节点，可能其他线程插入了内容导致不是最后的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (t != tail)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果不是最后节点的话将其现在t.next节点作为tail尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advanceTail(t, tn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点不是尾节点进入到这里面。</span></span><br><span class="line">        <span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">            <span class="comment">// 获取当前节点（被取消的节点）的下一个节点。</span></span><br><span class="line">            QNode sn = s.next;</span><br><span class="line">            <span class="comment">// 修改上一个节点的next(下一个)元素为下下个节点。</span></span><br><span class="line">            <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                <span class="comment">//返回。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode dp = cleanMe;</span><br><span class="line">        <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// 尝试清除上一个标记为清除的节点。</span></span><br><span class="line">            QNode d = dp.next;<span class="comment">//1.获取要被清除的节点</span></span><br><span class="line">            QNode dn;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// 被清除节点不为空</span></span><br><span class="line">                d == dp ||                 <span class="comment">// 被清除节点已经离队</span></span><br><span class="line">                !d.isCancelled() ||        <span class="comment">// 被清除节点是标记为Cancel状态的。</span></span><br><span class="line">                (d != t &amp;&amp;                 <span class="comment">// 被清除节点不是尾节点</span></span><br><span class="line">                 (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">// 被清除节点下一个节点不为null</span></span><br><span class="line">                 dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">                 dp.casNext(d, dn)))       <span class="comment">// 将被清除的节点的前一个节点的下一个节点修改为被清除节点的下一个节点。</span></span><br><span class="line">                casCleanMe(dp, <span class="keyword">null</span>);      <span class="comment">// 清空cleanMe节点。</span></span><br><span class="line">            <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred)) <span class="comment">// 这里将上一个节点标记为被清除操作，但是其实要操作的是下一个节点。</span></span><br><span class="line">            <span class="keyword">return</span>;          <span class="comment">// Postpone cleaning s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果节点中取消的头结点的下一个节点，只需要移动当前head节点到下一个节点即可。</li><li>如果取消的是中间的节点，则将当前节点next节点修改为下下个节点。</li><li>如果修改为末尾的节点，则将当前节点放入到QNode的clearMe中，等待有内容进来之后下一次进行清除操作。</li></ol><p><strong>实例一</strong>：清除头结点下一个节点，下面是实例代码进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除头结点的下一个节点实例代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子说明我们启动了两个线程，分别向SynchronousQueue队列中添加了元素1和元素2，添加成功之后的，让主线程休眠一会，然后将第一个线程进行中断操作，添加两个元素后节点所处在的状态为下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/1.png" alt="1"></p><p>当我们调用<code>thread1.interrupt</code>时，此时线程1等待的消费操作将被终止，会相应上面<code>awaitFulfill</code>方法，该方法会运行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">    <span class="comment">//尝试取消，将当前节点的item修改为当前节点(this)。</span></span><br><span class="line">    s.tryCancel(e);</span><br><span class="line"><span class="comment">// 获取当前节点内容。</span></span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="comment">// 判断当前值和节点值不相同是返回，因为弹出时会将item值赋值为null。</span></span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p>首先上来现将s节点(上图中的Reference-715引用对象)的item节点设置为当前节点引用(Reference-715引用对象)，所以s节点和e=1不相等则直接返回，此时节点的状态变化如下所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/2.png" alt="2"></p><p>退出<code>awaitFulfill</code>并且返回的是s节点内容（实际上返回的就是s节点），接下来返回到调用<code>awaitFulfill</code>的方法<code>transfer</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// 是否是被取消了</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断的事x节点和s节点是否相等，上面我们也说了明显是相等的所以这里会进入到clean方法中，<code>clean(QNode pred, QNode s)</code>clean方法一个是前节点，一个是当前被取消的节点，也就是当前s节点的前节点是head节点，接下来我们一步一步的分析代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.waiter = <span class="keyword">null</span>; <span class="comment">// 删除等待的线程。</span></span><br></pre></td></tr></table></figure><p>进入到方法体之后首先先进行的是将当前节点的等待线程删除，如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/3.png" alt="3"></p><p>接下来进入while循环，循环内容时<code>pred.next == s</code>如果不是则表示已经移除了节点，反之还在队列中，则进行下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next;   <span class="comment">// 如果取消的是第一个节点则进入下面语句</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先h节点为head节点，hn为头结点的下一个节点，在进行判断头结点的下一个节点不为空并且头结点下一个节点是被中断的节点(取消的节点)，则进入到if语句中，if语句其实也很简单就是将头结点修改为头结点的下一个节点(s节点，别取消节点，并且将前节点的next节点修改为自己，也就是移除了之前的节点，我们看下advanceHead方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h; <span class="comment">// forget old next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来先进行CAS移动头结点，再讲原来头结点h的next节点修改为自己(h)，为什么这样做呢？因为上面进行<code>advanceHead</code>之后并没有退出循环，是进行continue操作，也就是它并没有跳出while循环，他还会循环一次prev.next此时已经不能等于s所以退出循环，如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/4.png" alt="5"></p><p><strong>实例二</strong>：清除中间的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue实例二，清除中间的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面例子，首先先进行put操作三次，也就是入队3条数据，分别是整型值1，整型值2，整型值3，然后将当前线程休眠一下，对中间线程进行中断操作，通过让主线程休眠一会保证线程执行顺序性(当然上面线程不一定能保证执行顺序，因为put操作一下子就执行完了所以这点时间是可以的)，此时队列所处的状态来看一下下图：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/5.png" alt="5"></p><p>当休眠一会之后，进入到threa2进行中断操作，目前上图中表示<code>Reference-723</code>被中断操作，此时也会进入到<code>awaitFulfill</code>方法中，将<code>Reference-723</code>的item节点修改为当前节点，如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/6.png" alt="6"></p><p>进入到clear方法中此时的prev节点为<code>Reference-715</code>，s节点是被清除节点，还是首先进入clear方法中先将waiter设置为null，取消当前线程内容，如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/7.png" alt="7"></p><p>接下来进入到循环中，进行下面处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line"><span class="keyword">if</span> (t == h)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">QNode tn = t.next;</span><br><span class="line"><span class="keyword">if</span> (t != tail)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advanceTail(t, tn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个if语句已经分析过了所以说这里不会进入到里面去，接下来是进行尾节点t是否是等于head节点如果相等则代表没有元素，在判断当前方法的t尾节点是不是真正的尾节点tail如果不是则进行修改尾节点，先来看一下现在的状态：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/8.png" alt="8"></p><p><code>tn != null</code>判断如果tn不是尾节点，则将tn作为尾节点处理，如果处理之后还不是尾节点还会进行处理直到tail是尾节点未知，我们现在这个是尾节点所以跳过这段代码。<code>s != t</code>通过上图可以看到s节点是被清除节点，并不是尾节点所以进入到循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取的s节点的下一个节点，上图中表示<code>Reference-725</code>节点，判断sn是都等于当前节点显然这一条不成立，pred节点为<code>Reference-715</code>节点，将715节点的next节点变成<code>Reference-725</code>节点，这里就将原来的节点清理出去了，现在的状态如下所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/9.png" alt="9"></p><p><strong>实例三</strong>：删除的节点是尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue实例三，删除的节点为尾节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread3.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子主要说明一个问题就是删除的节点如果是末尾节点的话，<code>clear</code>方法又是如何处理的，首先启动了三个线程其中主线程休眠了一会，为了能让插入的顺序保持线程1，线程2，线程3这样子，启动第二个线程后，又将第二个线程中断，这是第二个线程插入的节点为尾节点，然后再启动第三个节点插入值，再中断了第三个节点末尾节点，说一下为啥这样操作，因为当清除尾节点时，并不是直接移除当前节点，而是将被清除的节点的前节点设置到QNode的CleanMe中，等待下次clear方法时进行清除上次保存在CleanMe的节点，然后再处理当前被中断节点，将新的被清理的节点prev设置为cleanMe当中，等待下次进行处理，接下来一步一步分析，首先我们先来看一下第二个线程启动后节点的状态。</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/10.png" alt="10"></p><p>此时运行<code>thread2.interrupt();</code>将第二个线程中断，这时候会进入到clear方法中，前面的代码都不会被返回，会执行下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QNode dp = cleanMe;</span><br><span class="line"><span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">    QNode d = dp.next;</span><br><span class="line">    QNode dn;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">        d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">        !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">        (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">         (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">         dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">         dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">        casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (dp == pred)</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>首先获得TransferQueue当中cleanMe节点，此时获取的为null，当判断dp!=null时就会被跳过，直接执行</p><p><code>casCleanMe(null, pred)</code>此时pred传入的值时t节点指向的内容，也就是当前节点的上一个节点，它会被标记为清除操作节点(其实并不清楚它而是清除它下一个节点，也就是说item=this的节点)，此时看一下节点状态为下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/11.png" alt="11"></p><p>接下来第三个线程启动了这时候又往队列中添加了元素3，此时队列的状况如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/12.png" alt="12"></p><p>此时thread3也被中断操作了，这时候还是运行上面的代码，但是这次不同的点在于cleanMe已经不是空值，是有内容的，首先获取的是cleanMe的下一个节点（d），然我来把变量标记在图上然后看起来好分析一些，如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/13.png" alt="13"></p><p>dp表示d节点的前一个pred节点，dn表示d节点的next节点，主要逻辑在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">    d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">    !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">    (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">     (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">     dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">     dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">    casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (dp == pred)</span><br><span class="line">    <span class="keyword">return</span>;      <span class="comment">// s</span></span><br></pre></td></tr></table></figure><p>首先判断d节点是不是为null，如果d节点为null代表已经清除掉了，如果cleanMe节点的下一个节点和自己相等，说明需要清除的节点已经离队了，判断下个节点是不是需要被清除的节点，目前看d节点是被清除的节点，然后就将被清除的节点的下一个节点赋值给dn并且判断d节点是不是末尾节点，如果不是末尾节点则进行<code>dp.casNext</code>方法，这个地方是关键点，它将被清除节点d的前节点的next节点修改为被清除节点d的后面节点dn，然后调用caseCleanMe将TransferQueue中的cleanMe节点清空，此时节点的内容如下所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/14.png" alt="14"></p><p>可以看出将上一次标记为清除的节点清除了队列中，清除完了就完事儿？那这次的怎么弄呢?因为现在运行的是thread3的中断程序，所以上面并没有退出，而是再次进入循环，循环之后发现dp为null则会运行<code>casCleanMe(null, pred)</code>，此时当前节点s的前一个节点已经被清除队列，但是并不影响后续的清除操作，因为前节点的next节点还在维护中，也是前节点的next指向还是<code>reference-725</code>,如下图所示：</p><p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/15.png" alt="15"></p><p>就此分析完毕如果有不正确的地方请指正。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统栈的工作原理</title>
      <link href="/2019/04/11/stack-working-principle/"/>
      <url>/2019/04/11/stack-working-principle/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>本篇文章着重写的是系统中栈的工作原理，以及函数调用过程中栈帧的产生与释放的过程，有可能名字过大，如果不合适我可以换一个名字，希望大家能够指正，小丁虚心求教！如果有哪里写的不清楚的或者错误的地方请及时更正，小丁再次谢过了。文章里面有错别字，也可能会有好友说寄存器的32、16位的区别其实我感觉这里主要讲的还是些原理性的东西，后续会将文章图片错别字进行调整.（图片里面的posh改为push）</p><h2 id="内存的不同用途"><a href="#内存的不同用途" class="headerlink" title="内存的不同用途"></a>内存的不同用途</h2><p>根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分为以下4个部分：</p><ol><li><p>代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。</p></li><li><p>数据区：用于存储全局变量等。</p></li><li><p>堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。</p></li><li><p>栈区：用于动态地存储函数之间的关系，以保证被调用函数在返回时恢复到母函数中继续执行。</p></li></ol><p>在Windows平台下，高级语言写出的程序经过编译链接，最终会变成PE文件。当PE文件被装载运行后，就成了所谓的进程。</p><p>PE文件代码段中包含的二进制级别的机器代码会被装入内存的代码区(.text)，处理器将到内存的这个区域一条一条地取出指令和操作数，并送入运算逻辑单元进行运算；如果代码中请求开辟动态内存，则会在内存的堆区分配一块大小合适的区域返回给代码区的代码使用；当函数调用发生时，函数的调用关系等信息会动态地保存在内存的栈区，以供处理器在执行完被调用函数的代码时，返回母函数。</p><p>如果把计算机看成一个有条不紊的工厂，我们可以得到如下类比：</p><ol><li><p>&lt; CPU是完成工作的工人。</p></li><li><p>&lt; 数据区、堆区、栈区等则是用来存放原料、半成品、成品等各种东西的场所。</p></li><li><p>&lt; 存放在代码区的指令则告诉CPU要做什么，怎么做，到哪里去领原材料，用什么工具来做，做完以后把成品放到哪个货仓去。</p></li><li><p>&lt; 值得一提的是，栈除了扮演存放原料、半成品的仓库之外，它还是车间调度主任的办公室。</p></li></ol><h2 id="栈与系统栈"><a href="#栈与系统栈" class="headerlink" title="栈与系统栈"></a>栈与系统栈</h2><p>从计算机科学的角度来看，栈指的是一种数据结构，是一种先进后出的数据表。栈的最常见操作有两种：压栈(PUSH)、弹栈(POP)；</p><ol><li><p>用于标识栈的属性也有两个：栈顶(TOP)、栈底(BASE)。</p></li><li><p>栈在内存中的存放是高地址是栈底（Base），低地址是栈顶（Top）。</p></li></ol><p><strong>下面来演示下栈的工作原理</strong>：</p><p>首先我们先以这段汇编指令来进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">mov bx 2244H</span><br><span class="line"></span><br><span class="line">push bx</span><br><span class="line"></span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure><p>首先我们先将10000H-1000FH这段内存空间来当做栈来使用，首先执行的操作是push ax，会将0123H压入到栈中，SP=SP-2，SS：SP指向当前栈顶当前的单元，以当前的单元为新的栈顶，将ax的数据送到SS：SP指向的内存单元中，SS：SP此时指向新的栈顶。此时ax的数值是0123H；详细请见下图</p><p><img src="/2019/04/11/stack-working-principle/121548313995232.png" alt=""></p><p>接来下进行第二部操作：push bx，操作同上:</p><p><img src="/2019/04/11/stack-working-principle/121549125554658.png" alt=""></p><p>接下来我们要演示的是pop操作，请注意pop操作的细节，比如到了栈底的时候指针是在哪里？这些都是要进行关注的。</p><p>CPU执行pop ax时，SP=SP+2,SS:SP指向1000EH,pop操作栈顶元素，1000CH处的2266H依然存在，但是它在栈中不存在了，当再次push等入栈指令后，SS：SP移至1000CH，并在里面写入新的数据，将其覆盖。详细看下图操作：</p><p><img src="/2019/04/11/stack-working-principle/121550116333243.png" alt=""></p><p>当再次进行pop给bx时，这是SP=SP+2,这时候指针就超出了栈底，就变成了SP=10H，所以我们得出一个结论就是当栈为空时，SS=1000H，SP=10H。详细看下面操作：</p><p><img src="/2019/04/11/stack-working-principle/121550331809527.png" alt=""></p><p>内存的栈区实际上指的就是系统栈。系统栈由系统自动维护，它用于实现高级语言中函数的调用。对于类似C语言这样的高级语言，系统栈的PUSH、POP等堆栈平衡细节是透明的。一般说来，只有在使用汇编语言开发程序的时候，才需要和它直接打交道。</p><h2 id="函数调用约定与相关指令"><a href="#函数调用约定与相关指令" class="headerlink" title="函数调用约定与相关指令"></a>函数调用约定与相关指令</h2><p>函数调用约定描述了函数传递参数方式和栈帧同工作的技术细节。不同的操作系统、不同的语言、不同的编译器在实现函数调用时的原理虽然基本相同，但具体的调用约定还是有差别的。这包括参数传递方式，参数入栈顺序是从右向左还是从左向右，函数返回时恢复堆栈平衡的操作在子函数中进行还是在母函数中进行。<br><strong>调用方式之间的差异</strong></p><p><img src="/2019/04/11/stack-working-principle/121551284612271.png" alt=""></p><p>具体的，对于Visual C++来说，可支持以下3种函数调用约定：</p><p><img src="/2019/04/11/stack-working-principle/121552120404524.png" alt=""></p><p>如果要明确使用某一种调用约定，只需要在函数前加上调用约定的声明即可，否则默认情况下，VC会使用_stdcall的调用方式。 除了参数入栈方向和恢复栈平衡操作位置的不同之外，参数传递有时也会有所不同。例如，每一个C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用ECX寄存器来传递的，但如果用GCC编译器来编译，这个指针会作为最后一个参数压入栈中。</p><p>注意：同一段代码用不同的编译选项、不同的编译器编译链接后，得到的可执行文件会有很多不同。</p><p><strong>函数调用大概包括以下几个步骤</strong>：</p><ol><li>参数入栈：将参数从右向左依次压入系统栈中。</li><li>返回地址入栈：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。</li><li>代码区跳转：处理器从当前代码区跳转到被调用函数的入口处。</li><li>栈帧调整：具体包括：<ol><li><1>保存当前栈帧状态值，已备后面恢复本栈帧时使用(EBP入栈)。</1></li><li><2>将当前栈帧切换到新栈帧(将ESP值装入EBP，更新栈帧底部)。</2></li><li><3>给新栈帧分配空间(把ESP减去所需空间的大小，抬高栈顶)。</3></li><li><4>对于_stdcall调用约定，函数调用时用到的指令序列大致如下：<ul><li>push 参数3      ;假设该函数有3个参数，将从右向做依次入栈</li><li>push 参数2</li><li>push 参数1</li><li>call 函数地址   ;call指令将同时完成两项工作：a)向栈中压入当前指令地址的下一个指令地址，即保存返回地址。 b)跳转到所调用函数的入口处。</li><li>push  ebp        ;保存旧栈帧的底部</li><li>mov  ebp,esp     ;设置新栈帧的底部 (栈帧切换)</li><li>sub   esp,xxx     ;设置新栈帧的顶部 (抬高栈顶，为新栈帧开辟空间)</li></ul></4></li></ol></li></ol><p><strong>函数返回的步骤如下</strong>：</p><ol><li><p><1>保存返回值，通常将函数的返回值保存在寄存器EAX中。</1></p></li><li><p><2>弹出当前帧，恢复上一个栈帧。具体包括：</2></p><ol><li><p>(1)在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。</p></li><li><p>(2)将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。</p></li><li><p>(3)将函数返回地址弹给EIP寄存器。</p></li></ol></li><li><p><3>跳转：按照函数返回地址跳回母函数中继续执行。</3></p><p>　　还是以C语言和Win32平台为例，函数返回时的相关的指令序列如下：</p><p>　　add esp,xxx     ;降低栈顶，回收当前的栈帧</p><p>　　pop ebp         ;将上一个栈帧底部位置恢复到ebp</p><p>　　retn            ;a)弹出当前栈顶元素，即弹出栈帧中的返回地址，至此，栈帧恢复到上一个栈帧工作完成。b)让处理器跳转到弹出的返回地址，恢复调用前代码区</p></li></ol><h2 id="寄存器与函数栈帧"><a href="#寄存器与函数栈帧" class="headerlink" title="寄存器与函数栈帧"></a>寄存器与函数栈帧</h2><p>每一个函数独占自己的栈帧空间。当前正在运行的函数的栈帧总是在栈顶。Win32系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。</p><ol><li><p>(1)ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p></li><li><p>(2)EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 </p></li></ol><p>　　【寄存器对栈的标识作用见(图1)】</p><p><img src="/2019/04/11/stack-working-principle/121552471181241.png" alt=""></p><p>函数栈帧：ESP和EBP之间的内存空间为当前栈帧,EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。</p><p>在函数栈帧中，一般包含以下几类重要信息。</p><ol><li><p>(1)局部变量：为函数局部变量开辟的内存空间。</p></li><li><p>(2)栈帧状态值：保存前栈帧的顶部和底部(实际上只保存前栈帧的底部，前栈帧的顶部可以通过栈帧平衡计算得到)，用于在本栈被弹出后恢复出上一个栈帧。</p></li><li><p>(3)函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。</p></li></ol><p>注：函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。函数运行过程中，其栈帧大小也是在不停变化的。除了与栈相关的寄存器外，我们还需要记住另一个至关重要的寄存器。</p><p>EIP：指令寄存器(extended instruction pointer)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。 可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。这里不多说EIP的作用，我个人认为王爽老是的汇编里面讲EIP讲的已经是挺好的了~这里不想多写关于EIP的事情。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文是针对上面两篇文章的一个基础性的补充~希望大家能够喜欢和指正其中的不足之处，小丁虚心学习于请教~不知道名字叫啥~</p><p>内容参考：<strong>0day安全:软件漏洞分析技术(第2版)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Assembly </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git仓库迁移</title>
      <link href="/2019/04/09/git-server-transfer/"/>
      <url>/2019/04/09/git-server-transfer/</url>
      
        <content type="html"><![CDATA[<h1 id="Git仓库迁移"><a href="#Git仓库迁移" class="headerlink" title="Git仓库迁移"></a>Git仓库迁移</h1><ol><li>首先查看当前仓库的远程信息</li></ol><blockquote><p>git remote -v</p></blockquote><p>会出现如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">originhttps://gitee.com/xxxx/xxxxx.git (fetch)</span><br><span class="line">originhttps://gitee.com/xxxx/xxxxx.git (push)</span><br></pre></td></tr></table></figure><ol start="2"><li>移除远程分支</li></ol><blockquote><p>git remote rm <strong>origin</strong></p></blockquote><ol start="3"><li>添加远程仓库</li></ol><blockquote><p>git remote add origin <a href="https://gitee.com/xxxx/xxxxx.git" target="_blank" rel="noopener">https://gitee.com/xxxx/xxxxx.git</a></p></blockquote><ol start="4"><li>将代码提交到分支</li></ol><blockquote><p>git push origin master:master</p></blockquote><ol start="5"><li>提交其他的分支到对应的远程分支</li></ol><blockquote><p>git push origin V0.1:V0.1</p></blockquote><p>其中前面分支代表本地分支，后面的代表远程分支。</p><ol start="6"><li>简化分支使用git push直接推送</li></ol><blockquote><p>git push –set-upstream origin V0.1</p></blockquote><ol start="7"><li>删除远程分支</li></ol><blockquote><p>git push origin –delete V.4</p></blockquote><ol start="8"><li>迁移所有tag到服务器上</li></ol><blockquote><p>git push origin –tags</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedBlockingQueue原理解析</title>
      <link href="/2019/04/07/LinkedBlockingQueue-Principle/"/>
      <url>/2019/04/07/LinkedBlockingQueue-Principle/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedBlockingQueue原理详解"><a href="#LinkedBlockingQueue原理详解" class="headerlink" title="LinkedBlockingQueue原理详解"></a>LinkedBlockingQueue原理详解</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>前面已经介绍过关于ArrayBlockingQueue相关原理性内容，我们前面讲过ArrayBlockingQueue是基于数组的方式实现的，那么LinkedBlockingQueue是基于链表的形式实现。先来看一下LinkedBlockingQueue的UML，如下所示：</p><p><img src="/2019/04/07/LinkedBlockingQueue-Principle/1.png" alt="image-20190407143028626"></p><p>通过上面的UML可以看到，他也是BlockingQueue的实现，也就是他的核心在于Blocking（阻塞）这个上面，在讲解ArrayBlockingQueue的时候，可以清晰的得出ArrayBlockingQueue是使用了独占锁的方式，要求两个操作进行时获得当先队列的独占锁，那么take()和put()操作就不可能真正的并发。它们会彼此等待对方释放资源，在这种情况下所竞争会比较激励，从而会影响到高并发的效率，而LinkedBlockingQueue为了解决这一问题，采用<code>锁分离</code>的方式进行实现，take()函数和put()函数分别实现了从队列中取得数据和往队列天价收的功能，换句话说就会说take()方法有专门的锁进行控制，而put()方法也有专门的锁进行控制，由于take()方法是操作队尾，put()方法操作队首，又因为LinkedBlockingQueue是基于链表的方式实现，因此两个操作不受影响。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>首先看一下LinkedBlockingQueue中的字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的Node节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点，如果节点为Null代表最后一个节点</span></span><br><span class="line"><span class="comment">     * - the real successor Node</span></span><br><span class="line"><span class="comment">     * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">     * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 容量限制,如果没有指定则为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前队列的元素个数，原子操作 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头结点</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾节点</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**take, poll的重入锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 不为空的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** put, offer的重入锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队满条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><ol><li>Node节点维护链表的信息。</li><li>最大容量限制，用户可自己指定，如果没有指定则代表Integer的最大值。</li><li>包含了head头结点，tail尾节点。</li><li>takeLock代表的是take，poll等出队列操作的锁。</li><li>putLock代表是put，offer等入队列的操作的锁。</li></ol><p>接下来看一下put方法是如何进行入队操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此队列的尾部, 等待队列空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// 保持计数为负，表示失败，除非设定。</span></span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">  <span class="comment">// putLock锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">  <span class="comment">// 链表长度，原子操作。</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="comment">// 获得锁，并且响应中断，put操作只有一个线程操作。</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表长度等着capacity，代表队列已满，则等待队列为空。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 将元素插入队列末尾。</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">      <span class="comment">// c为count加1前的值，这里是原子操作，它会进行CAS，因为现在是两个线程进行操作，有可能put的时候也进行take操作，所以要保证原子性。</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">      <span class="comment">// 当c+1不是最大值时，通知notFull，队列未满可继续添加元素，通知其他线程。</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// c代表插入前的的值，所以队列为空的时候c=0，此时已经插入了数据所以c本来应该不为0，所以需要通知队列元素插入成功。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以清晰得到put方法是如何进行操作的，首先获取putLock锁，获取队列的原子类型的长度，如果当前队列的长度与队列最大长度相等说明队列未满，则等待队列为空的时候插入数据，当队列未满时，可直接插入数据到队尾，c存放的事count元素加1前的值，也就是谁队列为空的时候c的长度是为0，当执行完了put方法后，实际的count为1，但是这里因为存放的是加1前的值，所有c=0，代表队列中有数据通知notEmpty可以进行take了。</p><p>enqueue方法源码很简单，就是将node节点插入到队尾，将last节点指向当前队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说一下take方法的源码是如何实现的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队头获取元素，等待队列有数据可读。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">  <span class="comment">// 本地保存变量。</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 队列长度。</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="comment">// 获取take重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">  <span class="comment">// 获得锁，并且响应中断操作，并且只有一个线程进入take方法。</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果队列为空则等待队列不为空时进行获取操作。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 出队列操作。</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">      <span class="comment">// c保存减1前的值。</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">      <span class="comment">// 如果队列还有元素则可通知其他线程进行take操作。</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// c如果是capacity的时候代表之前队列存在过满的情况，进行take方法后则表示队列有空间可用可进行put操作，通知notFull进行put操作。</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码可以看到，take方法获取的是takeLock重入锁，并且当前线程进入到take方法后，其他线程是不允许同时进入到take方法中，首先判断队列的长度是不是为0，如果队列为0则代表队列中无数据可消费，则进行等待，等待队列中有元素时进行take后的操作，如果队列长度不为0，则进行dequeue方法，出队列操作，将head节点指向下一个节点，将当前head值返回，当c大于1时，代表还有元素可以take，通知其他线程进行take操作，c如果是capacity的时候，代表之前队列存在过满的情况，进行这次take方法后队列有空间可用，所以可以通知notFull进行put操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// 帮助GC进行垃圾回收。</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LinkedBlockingQueue是通过锁分离的方式进行控制，减少了take和put之间的锁竞争。</li><li>LinkedBlockingQueue是通过链表的方式实现，所以进行锁分离时不会冲突，因为入队和出队分别作用于队尾和队首。</li><li>内部采用了原子操作类（CAS）进行控制链表长度。</li><li>入队后，如果之前队列为空时，会通知take方法，队列已有数据可进行take，反之，出队后，队列之前已满，则通知put方法，队列已有空闲位置可进行put操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayBlockingQueue原理详解</title>
      <link href="/2019/04/06/arrayblockingqueue-principle/"/>
      <url>/2019/04/06/arrayblockingqueue-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayBlockingQueue原理详解"><a href="#ArrayBlockingQueue原理详解" class="headerlink" title="ArrayBlockingQueue原理详解"></a>ArrayBlockingQueue原理详解</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ArrayBlockingQueue是基于数组实现的共享通道，为什么说是共享通道，假说线程A希望给线程B发一个消息，用什么方式来告知线程B是比较合适的呢？可以使用BlockingQueue来实现。</p><p><img src="/2019/04/06/arrayblockingqueue-principle/1554447867621.jpg" alt=""></p><p>通过上图中的继承关系我们可以清晰的发现ArrayBlockingQueue是BlockingQueue接口的实现，通过名称可以得出它是基于数组实现的，所以更适合做有界的队列。</p><p>​    刚才也提到过它是作为数据共享来进行的线程间数据的传递，那么问题来了，当队列中为空的时候消费队列的线程如何知道队列中有新的元素添加进去，队列满的时候又如何进行处理？我们带着上面的疑问来进行下面的分析。</p><p>主要的队列的入队、出队操作如下表所示：</p><h3 id="插入队列方法"><a href="#插入队列方法" class="headerlink" title="插入队列方法"></a>插入队列方法</h3><table><thead><tr><th>方法名称</th><th>参数描述</th><th>返回值</th><th>异常信息</th></tr></thead><tbody><tr><td>add</td><td>插入对象</td><td>ture代表插入成功，如果队列已满，抛出异常</td><td>IllegalStateException(“Queue full”)异常——AbstractQueue</td></tr><tr><td>offer</td><td>插入对象</td><td>true代表插入成功，队列已满直接返回false</td><td>无</td></tr><tr><td>offer</td><td>插入对象，等待时间</td><td>true代表插入成功，队列已满等待一段时间后仍没有空间则返回false</td><td>无</td></tr><tr><td>put</td><td>插入对象</td><td>true代表插入成功，如果队列已满则阻塞线程等待队列为空的时候插入</td></tr></tbody></table><h3 id="获取队列内容"><a href="#获取队列内容" class="headerlink" title="获取队列内容"></a>获取队列内容</h3><table><thead><tr><th>方法名称</th><th>参数描述</th><th>返回值</th><th>异常信息</th></tr></thead><tbody><tr><td>remove</td><td>无</td><td>返回队首数据并移除，队列已空则抛出异常信息</td><td>NoSuchElementException()异常——AbstractQueue</td></tr><tr><td>poll</td><td>无</td><td>列不为空时返回队首值并移除；队列为空时返回null。非阻塞立即返回。</td><td></td></tr><tr><td>poll</td><td>等待时间</td><td>设定等待的时间，如果在指定时间内队列还未孔则返回null，不为空则返回队首值</td><td></td></tr><tr><td>take</td><td>无</td><td>队列不为空返回队首值并移除；当队列为空时会阻塞等待，一直等到队列不为空时再返回队首值。</td></tr></tbody></table><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>上面的方法中重点的内容在于put和take方法，我们以一个实例来看一下这个队列的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayBlockingQueue内容测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:dwlsxj@126.com"&gt;battleheart&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">"预备入队"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    arr.put(i);</span><br><span class="line">                    System.out.println(i + <span class="string">"入队成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"进入消费队列"</span>);</span><br><span class="line">                    System.out.println(arr.take());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>开启了两个线程，一个是提供数据的线程，一个是消费数据的线程</li><li>入队操作之前进行了睡眠，目的是先让消费线程进行消费队列，然后队列数据提供线程再往线程中提供数据。</li><li>出队的操作中添加了sleep方法，目的是为了能让入队的内容多一些。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">进入消费队列</span><br><span class="line"><span class="number">0</span>预备入队</span><br><span class="line"><span class="number">0</span>入队成功</span><br><span class="line"><span class="number">1</span>预备入队</span><br><span class="line"><span class="number">1</span>入队成功</span><br><span class="line"><span class="number">2</span>预备入队</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span>入队成功</span><br><span class="line"><span class="number">3</span>预备入队</span><br><span class="line"><span class="number">3</span>入队成功</span><br><span class="line"><span class="number">4</span>预备入队</span><br><span class="line"><span class="number">4</span>入队成功</span><br><span class="line"><span class="number">5</span>预备入队</span><br><span class="line"><span class="number">5</span>入队成功</span><br><span class="line"><span class="number">6</span>预备入队</span><br><span class="line"><span class="number">6</span>入队成功</span><br><span class="line"><span class="number">7</span>预备入队</span><br><span class="line"><span class="number">7</span>入队成功</span><br><span class="line"><span class="number">8</span>预备入队</span><br><span class="line"><span class="number">8</span>入队成功</span><br><span class="line"><span class="number">9</span>预备入队</span><br><span class="line"><span class="number">9</span>入队成功</span><br><span class="line"><span class="number">10</span>预备入队</span><br><span class="line"><span class="number">10</span>入队成功</span><br><span class="line"><span class="number">11</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">11</span>入队成功</span><br><span class="line"><span class="number">12</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">12</span>入队成功</span><br><span class="line"><span class="number">13</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">13</span>入队成功</span><br><span class="line"><span class="number">14</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">14</span>入队成功</span><br><span class="line"><span class="number">15</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span>入队成功</span><br><span class="line"><span class="number">16</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">16</span>入队成功</span><br><span class="line"><span class="number">17</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">17</span>入队成功</span><br><span class="line"><span class="number">18</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">18</span>入队成功</span><br><span class="line"><span class="number">19</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">19</span>入队成功</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">10</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">11</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">12</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">13</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">14</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">15</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">16</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">17</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">18</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">19</span></span><br><span class="line">进入消费队列</span><br></pre></td></tr></table></figure><p>分析上述输出内容：</p><p><code>进入消费队列</code>文字输出出来说明数据提供者线程在休眠状态，而消费者线程在执行任务，在等待100ms后，<code>0</code>入队成功，<code>1</code>入队成功，当<code>2</code>准备入队时，这时候消费者线程获得了锁，消费了队列中的<code>0</code>,以此类推，最有一个<code>进入消费队列</code>说明队列为空等待队列不为空时，take方法进行消费。</p><p>通过输出结果可以得出以下内容：</p><ol><li>消费线程先进入，但是并没有执行完，也就是说消费线程一直等待的状态。</li><li>入队和出队只能同步进行一项，也就是入队操作会阻止出队操作，出队操作也会阻止入队操作。</li></ol><h2 id="内部原理解析"><a href="#内部原理解析" class="headerlink" title="内部原理解析"></a>内部原理解析</h2><p>ArrayBlockingQueue内部定义了以下的字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列元素数组 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下一个被take，poll，peek，remove的元素位置 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 插入位置包含put，offer，add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列元素的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 重入锁 */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列不为空的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列满时的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>当执行take()操作的时候，如果队列为空，则在notEmpty出等待，同时也会进行notFull的通知，通知notFull队列已经有位置可以进行入队操作了。新元素入队时，调用put方法时，如果队列满了，则当前线程暂停在notFull上，同时会进行一次notEmpty的通知，通知notEmpty队列已经有内容可，可以进行下面的内容了。</p><p>put方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素插入到队尾, 并且当队列中满的进行等待操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">  <span class="comment">//获得重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">//这里可以相应中断操作。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断队列是否已经满了。</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">          <span class="comment">//如果满了就在这里等待，等待通知队列为空时，进行相应。</span></span><br><span class="line">            notFull.await();</span><br><span class="line">      <span class="comment">//入队操作。</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源代码可以得到以下内容：</p><ol><li>获得重入锁进行入队同步操作，这也说明入队和出队只能同时进行一种操作的原因。</li><li>判断队列元素是否已经达到了队列的长度，也就是队列是否已经装满，如果装满则进行等待队列中有空余位置为止。</li><li>入队操作。</li></ol><p>接下来详细看一下入队操作是如何进行的,enqueue源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前putIndex位置插入元素, 并且通知notEmpty队列已经有内容.</span></span><br><span class="line"><span class="comment"> * 只有在获得锁的情况下执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">  <span class="comment">// 队列数组。</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="comment">// 在putIndex的位置插入x。</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 进行循环操作，如果putIndex到了队尾则将putIndex索引指向队头。</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列数量加1</span></span><br><span class="line">    count++;</span><br><span class="line">  <span class="comment">// 通知notEmpty队列已经有内容可以进行消费。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下take方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * take方法从队列中获取元素，并且如果队列为空时进行notEmpty等待。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获得重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 响应中断请求。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果队列为空，则进行notEmpty等待。</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">      <span class="comment">// 出队操作。</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源码我们也可以看到如下内容：</p><ol><li>出队前必须先获得锁，才能进行操作。</li><li>队列为空时，进行notEmpty等待。</li></ol><p>dequeue方法源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出takeIndex元素信息,并且通知notFull队列已经有空余位置。</span></span><br><span class="line"><span class="comment"> * 执行必须先获得锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">  <span class="comment">// 队列元素。</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="comment">// 获取takeIndex索引信息。</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将takeIndex标记为null，方便GC进行回收。</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 循环进行操作。</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列元素数量减1</span></span><br><span class="line">    count--;</span><br><span class="line">  <span class="comment">// 迭代器进行take</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 通知notFull队列已经不再满，可进行put操作。</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对源码put和take 的分析总结一下几点：</p><ol><li>ArrayBlockingQueue是采用数组进行实现队列，通过putIndex和takeIndex来控制队列的队头和队尾。</li><li>内部使用ReentrantLock进行同步操作，并配合Condition处理等待操作。</li><li>总结成下面的图片内容：</li></ol><p><img src="/2019/04/06/arrayblockingqueue-principle/2.png" alt=""></p><p>下面来用图示法讲解下ArrayBlockingQueue的工作原理</p><p>首先将元素1进行入队操作，如下图所示：</p><p><img src="/2019/04/06/arrayblockingqueue-principle/1.png" alt=""></p><p>putIndex和takeIndex在同一个位置，因为他只有一个元素，当再依次入队8个元素后内容如下所示</p><p><img src="/2019/04/06/arrayblockingqueue-principle/3.png" alt=""></p><p>此时putIndex就到了最后一个数组的元素的索引上，当再向数组元素中添加元素时，就会进行notFull的等待操作</p><p><img src="/2019/04/06/arrayblockingqueue-principle/4.png" alt=""></p><p>当调用take方法后，队列中出现了空余位置，并且通知了notFull，嘿，伙计你可以将你的东西添加到队列中了。</p><p><img src="/2019/04/06/arrayblockingqueue-principle/5.png" alt=""></p><p>可以清晰的看到putIndex变到了数组索引0的位置，就是下面的代码导致的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>并且此时的takeIndex便到了数组索引1的位置，持续进行take方法，队列内容全部出队列：</p><p><img src="/2019/04/06/arrayblockingqueue-principle/6.png" alt=""></p><p>当take方法走到数组的末尾时，它会将takeIndex值设置为0，进行从新开始take。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>并且当队列为空时，会进行notEmpty等待，等待队列中存在元素，当调用put方法后，它会通知notEmpty，兄弟你可以取队列消息了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阻塞算法和非阻塞算法</title>
      <link href="/2019/03/28/block-and-lock-free/"/>
      <url>/2019/03/28/block-and-lock-free/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞算法和非阻塞算法"><a href="#阻塞算法和非阻塞算法" class="headerlink" title="阻塞算法和非阻塞算法"></a>阻塞算法和非阻塞算法</h1><h2 id="阻塞算法"><a href="#阻塞算法" class="headerlink" title="阻塞算法"></a>阻塞算法</h2><p><strong>阻塞算法步骤</strong>：</p><ol><li>执行线程请求的操作。</li><li>阻塞争抢资源的线程，直到线程资源被释放，才有机会执行线程请求操作。</li></ol><p><img src="/2019/03/28/block-and-lock-free/1.png" alt="阻塞算法"></p><p>​    上图表明了阻塞算法的流程，线程A和线程B同时争抢临界区资源，线程A优先争抢到资源，这时候线程B争抢资源时，发现临界区资源已经被其他线程占用，线程B只能等待线程A释放资源后才能获取资源，阻塞线程B执行，阻塞的线程不会执行任何内容，等待线程A执行结束，当线程A执行结束释放资源后，线程B争抢到资源执行下面的流程。</p><h2 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h2><p><strong>非阻塞算法步骤</strong></p><ol><li>执行线程请求参数。</li><li>其他线程可以进入临界区，并且通知请求不能被执行，一直请求执行操作，直到执行线程操作。</li></ol><p><img src="/2019/03/28/block-and-lock-free/2.png" alt="非阻塞算法"></p><p>​    线程A和线程B申请临界区资源，线程A优先申请到资源，线程A正常执行，线程B申请临界区资源时，发现线程B正在执行操作，线程B直接被驳回申请，线程B进入下一轮的申请操作，直到申请成功。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你必须知道的多线程几个概念</title>
      <link href="/2019/03/28/you-have-to-know-the-concept-of-multithreading/"/>
      <url>/2019/03/28/you-have-to-know-the-concept-of-multithreading/</url>
      
        <content type="html"><![CDATA[<h1 id="你必须知道多线程几个概念"><a href="#你必须知道多线程几个概念" class="headerlink" title="你必须知道多线程几个概念"></a>你必须知道多线程几个概念</h1><h2 id="同步（Synchronous）、异步（Asynchronous）"><a href="#同步（Synchronous）、异步（Asynchronous）" class="headerlink" title="同步（Synchronous）、异步（Asynchronous）"></a>同步（Synchronous）、异步（Asynchronous）</h2><ol><li>同步方法调用一旦开始，就必须等待方法执行完之后，才能继续后续的行为。</li><li>异步方法更像是消息传递，一旦开始，方法调用就会返回结果，调用者就可以继续后续的行为。</li></ol><p><img src="/2019/03/28/you-have-to-know-the-concept-of-multithreading/image-20190308223510003.png" alt="image-20190308223510003"></p><h2 id="并发（Concurrency）和并行"><a href="#并发（Concurrency）和并行" class="headerlink" title="并发（Concurrency）和并行"></a>并发（Concurrency）和并行</h2><ol><li>并发：指的是多个任务交替执行，而多个任务之间有可能还是串行的。</li><li>并行：并行多个任务之间是真实同时执行。</li></ol><p><img src="/2019/03/28/you-have-to-know-the-concept-of-multithreading/image-20190308225730993.png" alt="image-20190308225730993"></p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程必须等待。</p><h2 id="阻塞（Blocking）和非阻塞（Non-Blocking）"><a href="#阻塞（Blocking）和非阻塞（Non-Blocking）" class="headerlink" title="阻塞（Blocking）和非阻塞（Non-Blocking）"></a>阻塞（Blocking）和非阻塞（Non-Blocking）</h2><p>阻塞和非阻塞用来形容多线程之间的相互影响。</p><p>阻塞：指的是资源占用的情况下，其他线程想要获取资源，此时必须阻塞其他线程访问。</p><p>非阻塞：强调没有一个线程可以妨碍其他线程执行。</p><h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><p>死锁：谁都不愿意释放自己，这个状态一直维持下去，谁都别想争抢到资源。</p><p>饥饿：指某一个或者多个线程因为种种原因无法或得所需要的资源，导致一直无法执行。（比如线程优先级低，每次要执行时，都被线程优先级高的先执行，一直执行不了）</p><p>活锁：指的是线程都秉承“谦让”的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot快速整合dubbo</title>
      <link href="/2019/02/25/spring-boot-and-dubbo-starter/"/>
      <url>/2019/02/25/spring-boot-and-dubbo-starter/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot与Dubbo进行整合"><a href="#Spring-Boot与Dubbo进行整合" class="headerlink" title="Spring Boot与Dubbo进行整合"></a>Spring Boot与Dubbo进行整合</h1><h2 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="服务提供端-provider"><a href="#服务提供端-provider" class="headerlink" title="服务提供端-provider"></a>服务提供端-provider</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboProviderApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .listeners((ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt;) event -&gt; &#123;</span><br><span class="line">                    Environment environment = event.getEnvironment();</span><br><span class="line">                    <span class="keyword">int</span> port = environment.getProperty(<span class="string">"embedded.zookeeper.port"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                    <span class="keyword">new</span> EmbeddedZooKeeper(port, <span class="keyword">false</span>).start();</span><br><span class="line">                &#125;)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ApplicationEnvironmentPreparedEvent</code>监听环境变量预处理事件</li><li>通过事件方式连接Zk</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Demo Service实现层。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, loadbalance = <span class="string">"roundrobin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务提供端通过dubbo的<code>@Service</code>注解进行服务的提供</li></ol><h3 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># SpringBoot应用名称</span><br><span class="line">spring.application.name=dubbo-registry-zookeeper-provider-sample</span><br><span class="line"># 扫描的Service包地址</span><br><span class="line">dubbo.scan.base-packages=com.battleheart.dubboprovider</span><br><span class="line"># Zookeeper的端口号</span><br><span class="line">embedded.zookeeper.port=2181</span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Dubbo注册地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">## dubbo服务版本号</span><br><span class="line">demo.service.version=1.0.0</span><br><span class="line"># 服务端口</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><h2 id="服务消费端-customer"><a href="#服务消费端-customer" class="headerlink" title="服务消费端-customer"></a>服务消费端-customer</h2><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=annotation-consumer</span><br><span class="line">embedded.zookeeper.port=2181</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">dubbo.consumer.timeout=3000</span><br></pre></td></tr></table></figure><h1 id="EmbeddedZooKeeper"><a href="#EmbeddedZooKeeper" class="headerlink" title="EmbeddedZooKeeper"></a>EmbeddedZooKeeper</h1><p><code>EmbeddedZooKeeper</code>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedZooKeeper</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logger.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EmbeddedZooKeeper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZooKeeper client port. This will be determined dynamically upon startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> clientPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether to auto-start. Default is true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> autoStartup = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle phase. Default is 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread for running the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread zkServerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ZooKeeperServerMain zkServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked if an Exception is thrown from the ZooKeeper server thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ErrorHandler errorHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct an EmbeddedZooKeeper with a random port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedZooKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clientPort = SocketUtils.findAvailableTcpPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct an EmbeddedZooKeeper with the provided port.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientPort port for ZooKeeper server to bind to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedZooKeeper</span><span class="params">(<span class="keyword">int</span> clientPort, <span class="keyword">boolean</span> daemon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientPort = clientPort;</span><br><span class="line">        <span class="keyword">this</span>.daemon = daemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the port that clients should use to connect to this embedded server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> dynamically determined client port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getClientPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clientPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify whether to start automatically. Default is true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoStartup whether to start automatically</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoStartup</span><span class="params">(<span class="keyword">boolean</span> autoStartup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.autoStartup = autoStartup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autoStartup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify the lifecycle phase for the embedded server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phase the lifecycle phase</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phase = phase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (zkServerThread != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start the ZooKeeper server in a background thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Register an error handler via &#123;<span class="doctag">@link</span> #setErrorHandler&#125; in order to handle</span></span><br><span class="line"><span class="comment">     * any exceptions thrown during startup or execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkServerThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zkServerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerRunnable(), <span class="string">"ZooKeeper Server Starter"</span>);</span><br><span class="line">            zkServerThread.setDaemon(daemon);</span><br><span class="line">            zkServerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shutdown the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkServerThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The shutdown method is protected...thus this hack to invoke it.</span></span><br><span class="line">            <span class="comment">// This will log an exception on shutdown; see</span></span><br><span class="line">            <span class="comment">// https://issues.apache.org/jira/browse/ZOOKEEPER-1873 for details.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method shutdown = ZooKeeperServerMain.class.getDeclaredMethod(<span class="string">"shutdown"</span>);</span><br><span class="line">                shutdown.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                shutdown.invoke(zkServer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// It is expected that the thread will exit after</span></span><br><span class="line">            <span class="comment">// the server is shutdown; this will block until</span></span><br><span class="line">            <span class="comment">// the shutdown is complete.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zkServerThread.join(<span class="number">5000</span>);</span><br><span class="line">                zkServerThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                logger.warn(<span class="string">"Interrupted while waiting for embedded ZooKeeper to exit"</span>);</span><br><span class="line">                <span class="comment">// abandoning zk thread</span></span><br><span class="line">                zkServerThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop the server if running and invoke the callback when complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide an &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked if an Exception is thrown from the ZooKeeper server thread. If none</span></span><br><span class="line"><span class="comment">     * is provided, only error-level logging will occur.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorHandler the &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorHandler = errorHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnable implementation that starts the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                File file = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)</span><br><span class="line">                        + File.separator + UUID.randomUUID());</span><br><span class="line">                file.deleteOnExit();</span><br><span class="line">                properties.setProperty(<span class="string">"dataDir"</span>, file.getAbsolutePath());</span><br><span class="line">                properties.setProperty(<span class="string">"clientPort"</span>, String.valueOf(clientPort));</span><br><span class="line"></span><br><span class="line">                QuorumPeerConfig quorumPeerConfig = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">                quorumPeerConfig.parseProperties(properties);</span><br><span class="line"></span><br><span class="line">                zkServer = <span class="keyword">new</span> ZooKeeperServerMain();</span><br><span class="line">                ServerConfig configuration = <span class="keyword">new</span> ServerConfig();</span><br><span class="line">                configuration.readFrom(quorumPeerConfig);</span><br><span class="line"></span><br><span class="line">                zkServer.runFromConfig(configuration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    errorHandler.handleError(e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Exception running embedded ZooKeeper"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解synchronized</title>
      <link href="/2019/02/22/how-use-synchronized/"/>
      <url>/2019/02/22/how-use-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解synchronized"><a href="#深入理解synchronized" class="headerlink" title="深入理解synchronized"></a>深入理解synchronized</h1><h2 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h2><p>synchronized是java的关键字，用于修饰方法、代码块，能够保证同一时刻最多只有一个线程执行这段代码，通过上述描述可以清晰告诉我们synchronized的作用，也就是同步操作，同步是围绕称为<em>内部锁</em>或<em>监视器锁</em>的内部实体构建的。内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>在方法内部使用synchronized来进行代码块的同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        lastName = name;</span><br><span class="line">        nameCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    nameList.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>直接在方法上使用synchronized进行修饰即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程调用synchronized方法时，它会自动获取该方法对象的内部锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放，可能想知道在调用静态同步方法时会发生什么，因为静态方法与类关联，而不是与对象关联。在这种情况下，线程获取<code>Class</code>与类关联的对象的内部锁。因此，对类的静态字段的访问由与该类的任何实例的锁不同的锁控制。</p><h2 id="内部锁或监视器锁"><a href="#内部锁或监视器锁" class="headerlink" title="内部锁或监视器锁"></a>内部锁或监视器锁</h2><p>同步是围绕称为<em>内部锁</em>或<em>监视器锁</em>的内部实体构建的。内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系。每个对象都有一个与之关联的内在锁，按照惯例，需要对对象字段进行独占和一致访问的线程必须在访问对象之前<em>获取</em>对象的内部锁，然后在完成它们时<em>释放</em>内部锁。据说一个线程在获得锁定和释放锁定之间<em>拥有</em>内在锁定。只要一个<code>线程</code>拥有一个内部锁，没有<code>其他线程</code>可以获得相同的锁。另一个线程在尝试获取锁时将阻塞。当线程释放内部锁时，在该操作与同一锁的任何后续获取之间建立先发生关系。</p><ol><li><p>当使用synchronized修饰非静态方法是，内置锁就是对象本身（this）</p></li><li><p>当使用synchronized修饰静态方法是，内置锁就是该方法的所在的<strong>类对象</strong>的内置锁</p></li></ol><p>通过一张图来描述一下synchronized的运行过程：</p><p><img src="/2019/02/22/how-use-synchronized/lock.png" alt="Synchronized运行"></p><ol><li><p>当线程1获取到拥有一个内部锁，没有其他线程可以获得相同的锁。</p></li><li><p>线程2只能等到线程1释放内部锁，线程2处于Blocked阻塞状态，被阻塞的线程将等待。</p></li><li><p>当线程1方法执行完释放内部锁之后，线程2获取内部锁，执行相应的方法。</p></li></ol><h2 id="内部锁可重入"><a href="#内部锁可重入" class="headerlink" title="内部锁可重入"></a>内部锁可重入</h2><p><strong>重入性</strong>指的是同一线程中，线程不需要再次获取同一把锁，内部锁是基于<code>每个线程</code>而不是基于每个方法的调用获取的。一旦线程获得了锁，它就可以在内部调用其他方法而无需重新获取锁。只有在使用entry方法调用完成线程时才会释放Lock。</p><p>下面结合例子进行分析锁的重入性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantDemo demo = <span class="keyword">new</span> ReentrantDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1调用前 "</span>+ LocalDateTime.now());</span><br><span class="line">            demo.syncMethod1(<span class="string">"执行线程1的方法"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1调用后 "</span>+LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程2调用前 "</span>+LocalDateTime.now());</span><br><span class="line">            demo.syncMethod2(<span class="string">"执行线程2的方法"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程2调用后 "</span>+LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod1</span> <span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入同步方法1syncMethod1 "</span>+msg+<span class="string">" "</span>+LocalDateTime.now());</span><br><span class="line">        syncMethod2(<span class="string">"重入同步方法syncMethod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod2</span> <span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入到同步方法2syncMethod2 "</span>+msg+<span class="string">" "</span>+LocalDateTime.now());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程2调用前 2019-02-22T15:33:43.963</span><br><span class="line">进入同步方法1syncMethod1 执行线程1的方法 2019-02-22T15:33:43.964</span><br><span class="line">进入到同步方法2syncMethod2 重入同步方法syncMethod2 2019-02-22T15:33:43.964</span><br><span class="line">线程1调用后 2019-02-22T15:33:46.969</span><br><span class="line">进入到同步方法2syncMethod2 执行线程2的方法 2019-02-22T15:33:46.969</span><br><span class="line">线程2调用后 2019-02-22T15:33:49.973</span><br></pre></td></tr></table></figure><p>代码解析：</p><ol><li><code>syncMethod1</code>和<code>syncMethod2</code>都用synchronized进行修饰。</li><li><code>syncMethod1</code>调用了<code>syncMethod2</code>方法，这时候会产生重入的问题</li><li>线程1当调用<code>syncMethod1</code>时，获取当前对象的内部锁</li><li>线程1调用<code>syncMethod2</code>时，发现当前线程拥有当前对象的内部锁，直接重入<code>syncMethod2</code>中</li><li>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</li></ol><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>我们当使用synchronized修饰代码块或者方法时内部实现了什么操作？我们通过下面例子来进行揭露真面目</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.syncMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap -v Test.class查看字节码文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  public com.example.demo.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/demo/Test;</span><br><span class="line">  public synchronized void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String testing</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lcom/example/demo/Test;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #5                  // class com/example/demo/Test</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #6                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokevirtual #7                  // Method syncMethod:()V</span><br><span class="line">        12: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 8</span><br><span class="line">        line 12: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            8       5     1  test   Lcom/example/demo/Test;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>syncMethod</code>的synchronized修饰在方法上</li><li><code>syncMethod</code>的flag中存在ACC_SYNCHRONIZED进行修饰，标识是否为synchronized</li></ol><p>实例二：</p><p>通过synchronized方法修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            syncMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap -v Test.class查看字节码文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.example.demo.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/demo/Test;</span><br><span class="line"></span><br><span class="line">  public static void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String testing</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: ldc           #5                  // class com/example/demo/Test</span><br><span class="line">         2: dup</span><br><span class="line">         3: astore_1</span><br><span class="line">         4: monitorenter</span><br><span class="line">         5: invokestatic  #6                  // Method syncMethod:()V</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: monitorexit</span><br><span class="line">        10: goto          18</span><br><span class="line">        13: astore_2</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit</span><br><span class="line">        16: aload_2</span><br><span class="line">        17: athrow</span><br><span class="line">        18: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             5    10    13   any</span><br><span class="line">            13    16    13   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 12: 5</span><br><span class="line">        line 13: 8</span><br><span class="line">        line 14: 18</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      19     0  args   [Ljava/lang/String;</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 13</span><br><span class="line">          locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Exception</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>执行同步代码块首先执行<strong>monitorenter</strong>指令，退出时候执行<strong>monitorexit</strong>指令</li><li>同步时必须要获取对象的监视器monitor，获取monitor后才能执行下面逻辑，否则只能等待。</li><li>经过<strong>monitorenter</strong>指令和<strong>monitorexit</strong>指令修饰的部分代码是互斥的，仅有一个线程持有内部锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot自动装配详解</title>
      <link href="/2019/01/24/spring-boot-autoconfiguration-fashion/"/>
      <url>/2019/01/24/spring-boot-autoconfiguration-fashion/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot自动装配"><a href="#Spring-Boot自动装配" class="headerlink" title="Spring Boot自动装配"></a>Spring Boot自动装配</h1><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><ol><li><p><code>@Import</code>注解<br>如果我们在项目中不同的模块提供多个spring bean配置，则@Import注释将非常有用。在这种情况下，最好将所有这些配置导入到单个配置类中，以便通过引用多个配置类来创建bean时不会产生任何混淆。Spring中的<code>@Import</code>注释允许从另一个配置类加载bean定义，将多个配置类导入单个应用程序配置非常容易，这里不过多篇幅讲解<code>@Import</code>。</p></li><li><p><code>@Enable</code>注解驱动，对配置进行自动配置。</p><ul><li>通过<code>ConfigurationClassParser</code>类对标记为<code>@Configuration</code>注解的类进行解析。</li><li>然后通过解析<code>@Import</code>注解进行自动导入配置，<code>@Import</code>支持以下三种方式解析。<ul><li>直接解析配置类<code>@Configuraion</code></li><li><code>ImportSelector</code>接口（<code>Spring 4.0</code>后增加了<code>DeferredImportSelector</code>继承自<code>ImportSelector</code>，两者的区别是<code>ImportSelector</code>在<code>DeferredImportSelector</code>先执行解析）</li><li><code>ImportBeanDefinitionRegistrar</code>动态注册Bean的方式</li></ul></li></ul></li><li><p><code>@Conditional</code>条件注解，以及常见的Spring Boot常见条件注解</p></li><li><p>源码分析</p></li></ol><h2 id="引用例子抛出问题"><a href="#引用例子抛出问题" class="headerlink" title="引用例子抛出问题"></a>引用例子抛出问题</h2><p><code>@SpringBootApplication</code>中包括<code>@EnableAutoConfiguration</code>注解，@Enable驱动，此时我们可能会想以下几个问题：</p><ol><li>@Enbale的主要作用是什么？</li><li>配置类是如何导入的？</li><li>配置类又是如何被解析的？</li><li>配置类导入方式是以什么方式进行导入的？</li></ol><p>接下来我们带着问题看以下内容</p><h2 id="Enable-模块驱动"><a href="#Enable-模块驱动" class="headerlink" title="@Enable 模块驱动"></a>@Enable 模块驱动</h2><p>通过观察这些<code>@Enable*</code>的源码，我们发现所有注解都有一个<code>@Import</code>注解，<code>@Import</code>是用来导入配置类的，这就意味着这些自动开启的实现其实是导入一些自动配置的Bean。</p><ol><li>直接导入配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(SchedulingConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>直接导入配置类<code>SchedulingConfiguration</code>，这个类注解了<code>@Configuration</code>注解，且注册了一个<code>scheduledAnnotationProcessor</code>的Bean，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p><code>ImportSelector</code>接口，实现该接口。</p><p>根据条件选择配置类，通过选择的方式进行选择配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AsyncConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>AsyncConfigurationSelector</code>通过条件来选择需要导入的配置类，<code>AsyncConfigurationSelector</code>实现了<code>ImportSelector</code>，这个接口需要重写<code>selectImports</code>方法，在此方法内进行事先条件判断。此例中，若<code>adviceMode</code>为PROXY，则返回<code>ProxyAsyncConfiguration</code>这个配置类；若为ASPECTJ则返回<code>AspectJAsyncConfiguration</code>配置类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableAsync</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">            <span class="string">"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;ProxyAsyncConfiguration.class.getName()&#125;;</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><code>ImportBeanDefinitionRegistrar</code>接口,动态注册Bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>AspectJAutoProxyRegistrar</code>实现了<code>ImportBeanDefinitionRegistrar</code>接口，<code>ImportBeanDefinitionRegistrar</code>接口的作用是在运行时自动添加Bean到已有的配置类，通过重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>AnnotationMetadata</code>参数用来获取当前配置类上的注解，<code>BeanDefinitionRegister</code>参数用来注册Bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：通过上述内容的描述可以清晰的看到@Enable注解回答了以下两个问题</p><ol><li>@Enable主要作用是导入配置</li><li>@Enable导入配置的方式<ul><li>直接导入配置类，通过<code>@Configuraion</code>注解加持的配置类</li><li>继承ImportSelector接口</li><li>继承ImportBeanDefinitionRegistrar接口</li></ul></li><li>配置类是通过上述三种方式进行导入<ul><li>直接导入配置类的方式很容易理解</li><li>ImportSelector接口方式程序又是如何进行解析的呢？请看下文内容。</li><li>ImportBeanDefinitionRegistrar接口又是如何进行解析？</li></ul></li></ol><h2 id="Spring-Boot条件注解讲解"><a href="#Spring-Boot条件注解讲解" class="headerlink" title="Spring Boot条件注解讲解"></a>Spring Boot条件注解讲解</h2><ol><li><p>常用相关条件注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span>              <span class="comment">// 配置了某个特定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>       <span class="comment">// 没有配置特定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>             <span class="comment">// classpath有指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>      <span class="comment">// classpath没有指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span>        <span class="comment">// 给定的Spring Expression Language（SpEL）表达式计算结果为true</span></span><br><span class="line"><span class="meta">@ConditionalOnJava</span>              <span class="comment">// Java的版本匹配特定值或某一个范围值</span></span><br><span class="line"><span class="meta">@ConditionalOnJndi</span>              <span class="comment">// 参数中给定的JNDI位置必须存在一个，如果没有给参数，则要有JNDI InitialContext</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>          <span class="comment">// 指定的配置属性要有一个明确的值</span></span><br><span class="line"><span class="meta">@ConditionalOnResource</span>          <span class="comment">// Classpath里有指定资源</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>    <span class="comment">// 这是个Web应用程序</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span> <span class="comment">// 这不是个Web应用程序</span></span><br></pre></td></tr></table></figure></li><li><p>条件注解<code>@Conditional</code>   </p><p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。通过一个源码我可以清晰的看到上面Spring Boot的源码都是采用条件注解。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(OnBeanCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>;</span><br><span class="line">    Class&lt;?&gt;[] parameterizedContainer() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@Conditional</code>中有一个<code>OnBeanCondition</code>的条件类，条件类最终继承关系如下图所示：<br><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/1.png" alt="OnBeanCondition继承关系" title="OnBeanCondition继承关系"><br>可以清晰的看到他最后继承自Condition接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中包含一个matches方法，有两个参数一个是ConditionContext包含了获取环境变量信息，Bean信息，类加载器的贵相关信息，AnnotatedTypeMetadata获取注解的信息。通过该方法返回true和false来表明是否加载当前Bean信息。</p><p>Spring Boot添加了很多注解，主要分类以下六大类内容：</p><ol><li><code>Class条件</code></li><li><code>Bean条件</code></li><li><code>Property条件</code></li><li><code>Resource条件</code></li><li><code>Web应用程序条件</code></li><li><code>SpEL表达式条件</code> </li></ol><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><ol><li><p>resource下添加META-INF文件，文件下添加spring.factories文件，如下图所示：  </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/2.png" alt="spring.factories" title="spring.factories">   </p><p>以Mybatis自动配置为主进行讲解，里面内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure></li></ol><p>我们可以看到里面是通过<code>EnableAutoConfiguration</code>这个注解来进行自动装配，也就是说添加了当前注解的类它会扫面spring.factorie文件下所有关于<code>EnableAutoConfiguration</code>指定类的全名称，然后进行自动化配置。</p><ol><li><code>EnableAutoConfiguration</code>注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">    <span class="comment">//排除Class类对象。</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//排除类名称。</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>EnableAutoConfiguration</code>中添加了<code>@Import</code>注解，注解中包含<code>AutoConfigurationImportSelector</code>类，这个类继承自<code>DeferredImportSelector</code>接口,而它又继承自<code>ImportSelector</code>接口，这就说明他是通过<code>ImportSelector</code>的方式来完成自动化配置。   </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/4.png" alt="AutoConfigurationImportSelector继承关系" title="AutoConfigurationImportSelector继承关系"></p><ol start="3"><li><p><code>ConfigurationClassParser</code>类解析@Configuration标记的类   </p><ul><li><p>主要作用：首先为什么要先说<code>ConfigurationClassParser</code>类，因为<code>Spring的</code>工具类<code>ConfigurationClassParser</code>用于分析<code>@Configuration</code>注解的配置类，产生一组<code>ConfigurationClass</code>对象。</p></li><li><p>分析过程：</p><ul><li><code>ConfigurationClassParser</code>类的调用是由<code>ConfigurationClassPostProcessor</code>，而<code>ConfigurationClassPostProcessor</code>是继承自<code>BeanDefinitionRegistryPostProcessor</code>接口，它又继承自<code>BeanFactoryPostProcessor</code>接口，它会在容器启动过程中，应用上下文执行各个<code>BeanFactoryPostProcessor</code>时被执行。</li><li><code>BeanFactoryPostProcessor</code>调用过程：Spring Boot 应用中在<code>ApplicationContext</code>对象创建时，会调用 <code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code> 注册这个<code>BeanFactoryPostProcessor</code>。执行时会调用<code>postProcessBeanDefinitionRegistry</code>方法，该方法中调用了该类中的<code>processConfigBeanDefinitions</code>方法来调用<code>ConfigurationClassPostProcessor</code>类的<code>parse</code>方法来进行解析<code>@Configuration</code>注解加载的类信息,以及调用<code>BeanFactoryPostProcessor</code>的<code>postProcessBeanFactory()</code>方法。   </li><li>分析过程会接受一组配置类(调用者已知其是配置类，通常就一个)，从它开始分析所有关联的配置类</li><li>分析过程主要是递归分析配置类的注解<code>@Import</code>，配置类内部嵌套类，找出其中所有的配置类，然后返回这组配置类</li></ul></li></ul><p><code>ConfigurationClassPostProcessor</code>继承关系：  </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/3.jpg" alt="ConfigurationClassPostProcessor继承关系" title="ConfigurationClassPostProcessor继承关系">   </p><p><code>ConfigurationClassPostProcessor</code>类的<code>postProcessBeanDefinitionRegistry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">//处理Config配置Bean。</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>processConfigBeanDefinitions</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记为@Configuration候选类</span></span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//从容器中获取已经标记为Bean的候选配置类名称。</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            <span class="comment">//如果当前类标记为@Configuration注解添加到候选类集合中。</span></span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有@Configuration注解的类直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据@Order的value来进行排序。</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取生成策略包括@ComponentScan和@Import的范围。</span></span><br><span class="line">    SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">                <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析每一个标记@Configuration注解的类。</span></span><br><span class="line">    <span class="comment">//首先构造ConfigurationClassParser类。</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为不清楚候选是否确实是配置类，所以使用BeanDefinitionHolder类型记录</span></span><br><span class="line">    <span class="comment">// 这里初始化为方法开始时容器中注解了@Configuration的Bean定义的集合</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    <span class="comment">// 这里记录已经解析的类。</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析配置文件，如果是标记为@Component注解的直接解析成bean，如果标记为@Import注解的将解析三种类型的类文件进行循环解析，解析成ConfigurationClass类添加到ConfigurationClassParser属性configurationClasses中。</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        parser.validate();</span><br><span class="line">        <span class="comment">// 获取ConfigurationClassParser中的ConfigurationClass对象集合。</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 去除已经解析的Bean对象。</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模型并根据其上下文创建bean定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 ConfigurationClassBeanDefinitionReader reader 从 configClasses 中加载Bean定义并加载到容器中。</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        <span class="comment">//处理完的添加到已处理类中。</span></span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空候选配置类集合，为下一轮do循环做初始化准备</span></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            <span class="comment">// 经过一轮do循环,现在容器中Bean定义数量超过了该次循环开始时的容器内Bean定义数量，</span></span><br><span class="line">            <span class="comment">// 说明在该次循环中发现并注册了更多的Bean定义到容器中去，这些新注册的Bean定义</span></span><br><span class="line">            <span class="comment">// 也有可能是候选配置类，它们也要被处理用来发现和注册Bean定义</span></span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty()); <span class="comment">//循环到没有配置类为止。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ConfigurationClassParser</code>的<code>parse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据不同的类型来进行解析。</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">//bd是AnnotateBeanDefinition</span></span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                <span class="comment">//bd是AbstractBeanDefinition,并且指定 beanClass 属性</span></span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他情况</span></span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后处理DeferredImportSelector接口内容。</span></span><br><span class="line">    <span class="comment">// DeferredImportSelector继承自ImportSelector接口。</span></span><br><span class="line">    <span class="comment">// ImportSelector 被设计成其实和@Import注解的类同样的导入效果，但是实现 ImportSelector的类可以条件性地决定导入哪些配置。</span></span><br><span class="line">    <span class="comment">// DeferredImportSelector的设计目的是在所有其他的配置类被处理后才处理。这也正是该语句被放到本函数最后一行的原因。</span></span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看一下第一种情况，其实不管是三个中的任何情况，最后都会调用<code>processConfigurationClass</code>方法来进行处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processConfigurationClass</code>方法，主要是对解析的ConfigurationClass进行处理，如果已经处理过则合并importBy属性，反之，循环解析配置类并且向上沿着类的接口逐层执行doProcessConfigurationClass方法，直到java提供的类结束循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先获取当前ConfigurationClass，检测是否已经被解析了。</span></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">//如果已经解析了，合并二者的importedBy属性</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前配置类configClass开始向上沿着类继承结构逐层执行doProcessConfigurationClass,</span></span><br><span class="line">    <span class="comment">// 直到遇到的父类是由Java提供的类结束循环</span></span><br><span class="line">    <span class="comment">// 将类封装成SourceClass类</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置configurationClasses属性添加当前configuClass对象，用于上一步中的获取当前属性来注册到上下文中。</span></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>doProcessConfigurationClass</code>方法内部实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是@Component注解优先处理内部类/内部成员。</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@PropertySource注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() + <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理@ComponentScan注解</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理@Import注解，这里才是真正的主题。</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource注解</span></span><br><span class="line">    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">                configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Bean@Bean的方法。</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有父类处理父类。</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有父类则代表处理完成。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看一下<code>processImports</code>方法，看一下是如何处理<code>@Import</code>注解的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,Collection&lt;SourceClass&gt; importCandidates, <span class="keyword">boolean</span> checkForCircularImports)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要处理的SourceClass是否为空，如果为空直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测循环引用问题。</span></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.problemReporter.error(<span class="keyword">new</span> CircularImportProblem(configClass, <span class="keyword">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="comment">//1.检测是否继承自ImportSelector接口。</span></span><br><span class="line">                <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="comment">//创建ImportSelectord对象。</span></span><br><span class="line">                    ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(selector, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">                    <span class="comment">//这里判断selector是否是DeferredImportSelector实现。</span></span><br><span class="line">                    <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                        <span class="comment">//将调用ConfigurationClassParser内部类DeferredImportSelectorHandler的handle方法，将该类添加到DeferredImportSelectorHandler的属性</span></span><br><span class="line">                        <span class="comment">//deferredImportSelectors等到后面的最后ConfigurationClassParser类的parse方法的最后执行的方法this.deferredImportSelectorHandler.process()。</span></span><br><span class="line">                        <span class="keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//这里是直接继承ImportSelector接口,并且执行selector的selectImports方法,获取需要解析的类，</span></span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                        <span class="comment">// 这里会循环解决配置中内容。</span></span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是动态注册Bean。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                    <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    ImportBeanDefinitionRegistrar registrar =</span><br><span class="line">                            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            registrar, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//直接处理@Configuration注解的类。</span></span><br><span class="line">                    <span class="keyword">this</span>.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    <span class="comment">// 从新开始又来处理ConfigurationClass，详细可以看上面的介绍该方法的地方。</span></span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Failed to process import candidates for configuration class ["</span> +</span><br><span class="line">                    configClass.getMetadata().getClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个Spring Boot的运行调用过程如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--SpringApplication.run()</span><br><span class="line">----refreshContext(context);</span><br><span class="line">------SpringApplication.refresh(context);</span><br><span class="line">--------ServletWebServerApplicationContext.refresh();</span><br><span class="line">----------AbstractApplicationContext.refresh()</span><br><span class="line">------------invokeBeanFactoryPostProcessors(beanFactory); <span class="comment">//这里就会继承自BeanFactoryPostProcessor接口的方法。</span></span><br><span class="line">--------------PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());<span class="comment">//第二个参数传递的就是BeanFactoryPostProcessor的list集合。</span></span><br><span class="line">----------------invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<span class="comment">//处理BeanDefinitionRegistryPostProcessors,继承自BeanFactoryPostProcessor接口</span></span><br><span class="line">------------------postProcessor.postProcessBeanDefinitionRegistry(registry);<span class="comment">//这里会调用ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法来进行处理Bean内容。</span></span><br><span class="line">--------------------ConfigurationClassPostProcessor.processConfigBeanDefinitions(registry);<span class="comment">//解析待处理的Bean。</span></span><br><span class="line">----------------------ConfigurationClassParser.parse(candidates);<span class="comment">//这里就是正式的将待处理的holder解析成ConfigurationClass。</span></span><br></pre></td></tr></table></figure></p><p>到上面最后一步其实就是已经到了我们上面源码分析的内容位置。</p><p>整体流程图大致如下图所示：</p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/5.png" alt="处理流程"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><code>JavaEE开发的颠覆者: Spring Boot实战</code>书籍,其中@Enable*驱动的三种方式摘抄本书</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring-boot与thymeleaf模板整合shiro标签内容</title>
      <link href="/2019/01/24/spring-boot-thymeleaf-and-shiro/"/>
      <url>/2019/01/24/spring-boot-thymeleaf-and-shiro/</url>
      
        <content type="html"><![CDATA[<h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="添加Bean对象"><a href="#添加Bean对象" class="headerlink" title="添加Bean对象"></a>添加Bean对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * shiro 标签的Bean。</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ShiroDialect shiroDialect() &#123;</span><br><span class="line">    return new ShiroDialect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面添加对标签的引用，添加方式如下："><a href="#页面添加对标签的引用，添加方式如下：" class="headerlink" title="页面添加对标签的引用，添加方式如下："></a>页面添加对标签的引用，添加方式如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;zh_CN&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="上述配置成功后即可使用shiro相关的标签"><a href="#上述配置成功后即可使用shiro相关的标签" class="headerlink" title="上述配置成功后即可使用shiro相关的标签"></a>上述配置成功后即可使用shiro相关的标签</h2><ol><li><p>直接对代码块进行控制 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;P0101&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">      &lt;a data-href=&quot;/ticket/spot/view/list&quot; data-title=&quot;景点&quot; href=&quot;javascript:void(0)&quot;&gt;景点&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过html属性方式进行控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a data-href=&quot;/ticket/spot/view/list&quot; data-title=&quot;景点&quot; href=&quot;javascript:void(0)&quot; shiro:hasPermission name=&quot;P0101&quot;&gt;景点&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Hexo搭建博客</title>
      <link href="/2018/10/26/use-hexo-to-build-a-blog/"/>
      <url>/2018/10/26/use-hexo-to-build-a-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>需要安装的内容如下：</p><ol><li>git 仓库（<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>）下载并安装</li><li>node.js（<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node官网</a>）下载并安装</li><li>hexo安装</li></ol><p>输入以下命令安装hexo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p><p>安装成功后，新建一个喜欢的文件夹，进入文件夹中执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install（用于安装依赖包）</span><br></pre></td></tr></table></figure></p><p>执行完成后，输入以下命令，然后通过访问:<a href="http://localhost:4000，来访问，一个本地博客就搭建完了。" target="_blank" rel="noopener">http://localhost:4000，来访问，一个本地博客就搭建完了。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><h2 id="常用命令如下"><a href="#常用命令如下" class="headerlink" title="常用命令如下"></a>常用命令如下</h2><blockquote><p>hexo g #完整命令为hexo generate,生成静态文件<br>hexo s #完整命令为hexo server,启动服务器,本地可以测试<br>hexo d #完整命令为hexo deploy,将本地编译好的静态文件发布到github上<br>hexo n #完整命令为hexo new,新建一篇文章<br>hexo clean #清除当前项目的静态文件  </p></blockquote><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><p>博主可根据自己的需求去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>中找寻自己喜欢的主题，并且将主题的仓库内容复制到themes目录下。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx.git  themes/xxx</span><br></pre></td></tr></table></figure></p><p>我们到themes目录下查看后可清楚看到我们download下的xxx文件夹内的主题信息，修改根目录的_config.yml（注意不是主题下的config.yml，而是hexo根目录下的配置文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></p><h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><ol><li>github仓库中新建一个git仓库，仓库的名字叫做<code>github账户名.github.io</code>(必须这样起名字)，例如我的账户名为dwlsxj，则仓库的名称是<code>dwlsxj.github.io</code></li><li>接下来配置SSH，自己的邮箱地址， 在git bash 中执行命令，连续回车三次不需要输入任何内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxx@126.com&quot;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/26/use-hexo-to-build-a-blog/1.jpg" alt="图片1" title="图片1"></p><p>从图中我们可以清晰的看到生成到了C盘Users/BattleHeart/.ssh/下，打开id_rsa.pub文件，copy文件中的内容。</p><ol start="3"><li>将复制的key设置到github中，用户-&gt;setting-SSH and GPG keys   </li></ol><p><img src="/2018/10/26/use-hexo-to-build-a-blog/2.png" alt="图片2" title="图片2"></p><ol start="4"><li>打开hexo目录下的_config.yml,找到deploy，添加git地址，保存后使用deploy d进行上传私服。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  #repository: https://github.com:xxxx/xxxx.github.io.git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:xxx/xxxx.github.io.git,master</span><br></pre></td></tr></table></figure><h1 id="个人域名绑定"><a href="#个人域名绑定" class="headerlink" title="个人域名绑定"></a>个人域名绑定</h1><ol><li>在source文件下新建一个CNAME文件（）没有后缀</li><li>将个人域名<code>www.battleheart.cn</code>添加到CNAME文件中</li><li>修改域名解析，添加两天CNAME的解析，解析到<code>dwlsxj.github.io</code>,也就是自己的仓库下。  </li></ol><p><img src="/2018/10/26/use-hexo-to-build-a-blog/3.png" alt="图片3" title="图片3"></p><ol start="4"><li>将CNAME文件deploy到github仓库中即可访问。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot Admin监控系统搭建</title>
      <link href="/2018/10/01/spring-boot-admin-monitor/"/>
      <url>/2018/10/01/spring-boot-admin-monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-Admin监控系统搭建"><a href="#Spring-Boot-Admin监控系统搭建" class="headerlink" title="Spring Boot Admin监控系统搭建"></a>Spring Boot Admin监控系统搭建</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring Boot Admin是对Spring Boot的管理和监控的一个开源框架，支持Eureka服务注册列表状态监控，JMX监控，日志监控，JVM信息，垃圾信息，内存情况的监控，还可以设置日志的level级别。Spring Boot Admin UI 采用AngularJs将数据展示在前端。Spring Boot Admin分为服务端和客户端。</p><h2 id="Spring-Boot-Admin-Server端搭建"><a href="#Spring-Boot-Admin-Server端搭建" class="headerlink" title="Spring Boot Admin Server端搭建"></a>Spring Boot Admin Server端搭建</h2><ol><li><p>添加依赖项，依赖项内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot主类上添加对Spring Boot Admin Server启动的注解@EnableAdminServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableDiscoveryClient # 开启服务注册。</span><br><span class="line">@EnableTurbineStream # 开启Turbine服务监控。</span><br><span class="line">@EnableAdminServer # 开启Spring Boot Admin Server功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudMonitorApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudMonitorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">            http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 设置登出页面地址。</span> http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line">            <span class="comment">// 设置目前不支持csrf。</span> http.csrf().disable();</span><br><span class="line">            <span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line">            <span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">            http.httpBasic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们看到上面其实还添加对Eureka的注解以及对Turbine Stream的注解功能，需要添加Turbine Stream注解相关与Spring boot Admin Server ui相关依赖项，为了安全起见导入了安全相关依赖项。依赖项内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—spring boot admin server ui支持登录页面依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-login&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成Hystrix监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成turbine--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--对Turbine Stream支持，使用RabbitMQ的方式对Hystrix数据进行收集分析。--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-codec-http&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Eureka支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!—安全支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>其实Spring Boot Admin Server依赖中包含对Zuul和Hystrix以及Eureka核心包的依赖整合，所以我们看到上面只是整合了UI相关的依赖项。而针对Eureka和Turbine Stream以及安全方面的依赖需要额外导入进去，依赖项也导入进去后需要对端点进行权限安全控制，我们可以看到上面内部类中对安全进行控制，通过继承WebSecurityConfigurerAdapter对安全进行配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line"><span class="comment">// 设置登出页面地址。</span></span><br><span class="line">http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line"><span class="comment">// 设置目前不支持csrf。</span></span><br><span class="line">http.csrf().disable();</span><br><span class="line"><span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>)</span><br><span class="line">    .permitAll();</span><br><span class="line"><span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line"><span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">http.httpBasic();</span><br></pre></td></tr></table></figure></p><p>也就是说对那些内容页面进行授权访问，那些页面是可以直接访问，对安全的开启等等一系列操作。</p><ol start="3"><li>修改配置文件信息，配置文件信息如下所示：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">    level:</span><br><span class="line">        org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter: error</span><br><span class="line">server: </span><br><span class="line">    port: <span class="number">8040</span></span><br><span class="line">turbine:</span><br><span class="line">    stream:</span><br><span class="line">        port: 8041    # 收集地址。</span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">boot:</span><br><span class="line">    admin:</span><br><span class="line">        routes:</span><br><span class="line">            endpoints: env,metrics,trace,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream</span><br><span class="line">        turbine:</span><br><span class="line">            clusters: <span class="keyword">default</span></span><br><span class="line">            location: http:<span class="comment">//localhost:$&#123;turbine.stream.port&#125;</span></span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;MONITOR_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：</p><ul><li>turbine.stream.port: 对Turbine支持，turbine服务端口号。</li><li>boot.admin.routes.endpoints: Spring Boot Admin暴露的EndPoint端点</li><li>spring.boot.admin.routes.turbine.clusters: 集群的名称</li><li>spring.boot.admin.routes.turbine.location: 集成Turbine服务数据收集的地址。  </li></ul><p>这里的地址就是为了收集是需要访问地址，我们之前在Turbine章节中说过这里不在多阐述。<br>Eureka中的metadataMap是专门用来存放一些自定义的数据，当注册中心或者其他服务需要此服务的某些配置时可以在metadataMap里取。实际上，每个instance都有各自的metadataMap，map中存放着需要用到的属性。例如，上面配置中的eureka.instance.metadata-map.user.name，当这个服务成功注册到Eureka上，SpringBootAdmin就会取拿到这个instance，进而拿到metadataMap里的属性，然后放入请求头，向此服务发送请求，访问此服务的actuator开放的端点。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>需要添加对安全保护的依赖项，以及对Turbine Stream注解。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>以上对Turbine Stream的支持请参考Spring Cloud Turbine相关文章内容。  </p><ol start="2"><li>修改配置文件信息，添加对Turbine Stream 消息队列的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span> </span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        hostname: localhost</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">        healthcheck:</span><br><span class="line">            enabled: <span class="keyword">true</span></span><br><span class="line"># Hystrix超时时间。</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                        timeoutInMilliseconds: <span class="number">5000</span></span><br><span class="line">spring:</span><br><span class="line">    abbitmq:</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        host: localhost</span><br><span class="line"></span><br><span class="line"># Spring Boot Admin配置相关 # SpringBoot 1.5以后的版本都默认开启端点保护</span><br><span class="line">management:</span><br><span class="line">    security:</span><br><span class="line">        enabled: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></li></ol><p>最主要的是management.security.enabled：关闭管理安全。<br>下面是Spring Boot Admin相关监控信息。</p><p><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片1" title="图片1"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片2" title="图片2"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片3" title="图片3"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片4" title="图片4">  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Logback输出日志到ELK</title>
      <link href="/2018/10/01/logback-with-elk/"/>
      <url>/2018/10/01/logback-with-elk/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Logback输出日志到ELK"><a href="#使用Logback输出日志到ELK" class="headerlink" title="使用Logback输出日志到ELK"></a>使用Logback输出日志到ELK</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>前两篇文章中我们介绍了windows上如何搭建ELK日志收集系统，那么问题来了，日志系统搭建完成后如何使用java代码直接输出日志到ELK系统中？</p><h2 id="logback支持ELK"><a href="#logback支持ELK" class="headerlink" title="logback支持ELK"></a>logback支持ELK</h2><p>我们带着背景中的问题进行下面的开始思路整理，其实在ELK文章中我们已经说了两种方案，其实ELK中logstash支持的日志收集的方式有很多种，下面说一下logstash收集其中方法：  </p><ol><li>使用logstash对文件进行检测  </li><li>使用TCP协议，logstash开放对TCP协议端口的监听。  </li><li>使用UDP协议，logstash开放对UDP协议端口的监听。  </li></ol><p>我们本章节中使用的是TCP协议的方式进行日志输出，下面看一下logback的配置文件。  </p><ol><li><p>引入依赖项logstash-logback-encoder</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- logback和logstash结合 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改logback的配置文件信息。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=<span class="string">"LOGSTASH"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span><br><span class="line">    &lt;destination&gt;192.168.1.107:9250&lt;/destination&gt;</span><br><span class="line">    &lt;!-- encoder必须配置,有多种可选 --&gt;</span><br><span class="line">    &lt;encoder charset=<span class="string">"UTF-8"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">&lt;root level=<span class="string">"ERROR"</span>&gt;</span><br><span class="line">    &lt;appender-ref ref=<span class="string">"LOGSTASH"</span>/&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>appender</code>的name属性使用的是net.logstash.logback.appender.LogstashTcpSocketAppender<br><code>destination</code>属性：tcp的IP地址和端口号<br><code>encoder</code>：编码格式  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows环境下搭建ELK环境</title>
      <link href="/2018/10/01/elk-environment-construction-in-windows/"/>
      <url>/2018/10/01/elk-environment-construction-in-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows环境下搭建ELK环境"><a href="#Windows环境下搭建ELK环境" class="headerlink" title="Windows环境下搭建ELK环境"></a>Windows环境下搭建ELK环境</h1><h2 id="搭建Elastic-Stack环境"><a href="#搭建Elastic-Stack环境" class="headerlink" title="搭建Elastic Stack环境"></a>搭建Elastic Stack环境</h2><ol><li>通过官网下载相关包，网址：<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic1.png" alt="Elastic Stack" title="Elastic Stack">  </p><ol start="2"><li><p>运行<code>bin/elasticsearch</code> (or <code>bin\elasticsearch.bat on Windows</code>)  </p></li><li><p>在浏览器上访问<a href="http://localhost:9200，出现如下截图内容代表ES部署成功。" target="_blank" rel="noopener">http://localhost:9200，出现如下截图内容代表ES部署成功。</a>  </p></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic2.png" alt="运行情况" title="运行情况">  </p><h2 id="搭建Logstash环境"><a href="#搭建Logstash环境" class="headerlink" title="搭建Logstash环境"></a>搭建Logstash环境</h2><ol><li>下载logstash文件，网址：<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic3.png" alt="logstash" title="logstash"><br>下载Zip将Zip解压到本地。  </li><li>新建Logstash.conf文件，将logstash.conf文件复制到bin文件夹下。  </li></ol><ul><li><p>通过检测文件的方式输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     file &#123;</span><br><span class="line">        path =&gt; [&quot;D:/Log/*.log&quot;]   检测文件，通过检测文件变化输出到ES中。</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]  ES地址</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过TCP方式进行监听日志信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     tcp &#123;</span><br><span class="line"></span><br><span class="line">port =&gt; 9250   TCP端口号</span><br><span class="line">codec =&gt; json_lines</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>运行<code>bin/logstash -f logstash.conf –t</code>  -t代表检测文件语法格式是否有误。<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic4.png" alt="运行结果" title="运行结果"><br>通过访问9600可以得到如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"host"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"6.4.1"</span>,  </span><br><span class="line">    <span class="string">"http_address"</span>: <span class="string">"127.0.0.1:9600"</span>,  </span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"bbb75ede-2654-4312-a80b-77d2c431ee73"</span>,  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"build_date"</span>: <span class="string">"2018-09-13T23:17:51Z"</span>,  </span><br><span class="line">    <span class="string">"build_sha"</span>: <span class="string">"cee0d74663380e80c2a38cf5a9ccffb9a0cfa215"</span>,  </span><br><span class="line">    <span class="string">"build_snapshot"</span>: <span class="keyword">false</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="搭建Kibana环境"><a href="#搭建Kibana环境" class="headerlink" title="搭建Kibana环境"></a>搭建Kibana环境</h2><ol><li>下载Kibana，选择Windows版本。地址：<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic5.png" alt="下载地址" title="下载地址">  </li><li>打开config/kibana.yml文件，设置elasticsearch.url  为<a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a>  </li><li>运行bin/kibana或者bin/kiana.bat（在windows下运行）。  </li><li>访问地址localhost://5601<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic6.png" alt="访问的地址" title="访问的地址">  </li><li>配置日志打开Discover菜单，创建索引<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic7.png" alt="创建索引" title="创建索引">  </li><li>创建筛选器–根据时间筛选<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic8.png" alt="创建筛选器–根据时间筛选" title="创建筛选器–根据时间筛选">  </li><li>再次返回到 Discover<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic9.png" alt="Discover" title="下载地Discover址">  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式服务跟踪之Spring Cloud Sleuth快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-sleuth/"/>
      <url>/2018/10/01/quick-start-spring-cloud-sleuth/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着业务的发展，系统规模也会变得越来越大，微服务之前的关系也会变得越来越复杂，客户端发起请求后通过一些列的微服务返回的结果，则会形成一个复杂的链路，在每个链路中如果有一个以来服务出现延迟或错误都会引发请求最后的失败，这时候对于整个链路的跟踪极为重要，通过实现队请求调用的跟踪可以帮助我们快速发现错误根源以及监控分析每条请求链路上的性能瓶颈等。<br>接下来我们要使用Spring Cloud Sleuth与Zipkin进行整合。</p><h1 id="Spring-Cloud-Sleuth使用。"><a href="#Spring-Cloud-Sleuth使用。" class="headerlink" title="Spring Cloud Sleuth使用。"></a>Spring Cloud Sleuth使用。</h1><ol><li>需要准备两个服务，service1与service2，service1调用service2的方法。</li><li>添加依赖项spring-cloud-starter-sleuth。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-sleuth它会自动为当前应用构建起各通信通道跟踪机制。比如：</p><ul><li>通过诸如RabbitMQ、Kafaka（或者其他任何Spring Cloud Stream绑定器实现的消息中间件）传递的请求。</li><li>通过Zuul代理传递的请求。</li><li>通过RestTemplate发起的请求。</li></ul><p>通过上面的配置即可对链路数据的监控，当我们访问service1和service2接口时会在控制台中输出相应的信息，例如：  </p><blockquote><p>INFO [servce1,f410a57afd5c145,a9f2118fa201984,false]25028—call servce1<br>INFO [servce1,f410a57afd5c145,e9a377dc2268bc29,false]25028—call servce2</p></blockquote><p><code>中括号</code>中的元素是实现分布式服务跟踪的重要组成部分，主要是：<br>第一个值：service1代表的是应用的名称，也就是spring.application.name参数属性值。<br>第二个值：Spring Cloud Sleuth生成的一个ID，称之为Trace ID，它用来标识是一条链路。一个请求链路中包含一个Trace ID，多个Span ID。<br>第三个值：也是Spring Cloud Sleuth生成的一个ID，代表的是Span ID,他表示一个基本的工作单位，比如发送一个Http请求。<br>也就是说同一个TranceID代表是一条链路，而不同的SpanID代表不同的Http请求和业务访问操作。  </p><h1 id="整合Zipkin"><a href="#整合Zipkin" class="headerlink" title="整合Zipkin"></a>整合Zipkin</h1><ol><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;    </span><br><span class="line">    &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>其中包括：spring-cloud-sleuth-zipkin-stream、spring-cloud-stream-binder-rabbit表示使用RabbitMQ的方式对链路进行传递请求。<br>zipkin-autoconfigure-ui依赖是通过页面的展示链路的情况。<br>客户端中需要添加对RabbitMQ注解的支持，主要是spring-cloud-stream-binder-rabbit或者spring-cloud-starter-stream-rabbit，我可以清晰的发现前后两者内容其实是一样后者内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;parent&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-stream-binder-rabbit-parent&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/parent&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">   &lt;description&gt;Spring Cloud Starter Stream Rabbit&lt;/description&gt;</span><br><span class="line">   &lt;url&gt;http:<span class="comment">//projects.spring.io/spring-cloud&lt;/url&gt;</span></span><br><span class="line">   &lt;organization&gt;</span><br><span class="line">      &lt;name&gt;Pivotal Software, Inc.&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http:<span class="comment">//www.spring.io&lt;/url&gt;</span></span><br><span class="line">   &lt;/organization&gt;</span><br><span class="line">   &lt;properties&gt;</span><br><span class="line">      &lt;main.basedir&gt;$&#123;basedir&#125;/../..&lt;/main.basedir&gt;</span><br><span class="line">   &lt;/properties&gt;    &lt;dependencies&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在Spring Boot主类上添加@EnableZipkinStreamServer注解开启Zipkin功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZipkinStreamServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudSluethZipkinApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringCloudSluethZipkinApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudsluethzipkin</span><br><span class="line">rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">9411</span></span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: admin</span><br><span class="line">    password: $&#123;ZIPKIN_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过RabbitMQ对消息进行传递，将链路信息传递给RabbitMQ，Zipkin对消息队列消息进行收集分析得出实际的访问链路。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控Spring Cloud Turbine消息队列篇</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>上一篇文章中我们介绍了Turbine简单的通过服务名称的方式构建监控聚合服务，这一章中我们将要讲一下使用消息队列的方式对集群信息进行收集，监控，我们可以将所有需要收集的监控信息都输出到消息代理中，然后turbine订阅消息代理中的消息，通过异步的方式读取消息，最后将读取出来的监控指标输出到Hystrix Dashboard中。</p><h1 id="Turbine与消息代理结合"><a href="#Turbine与消息代理结合" class="headerlink" title="Turbine与消息代理结合"></a>Turbine与消息代理结合</h1><ol><li>首先需要一个重要的东西就是消息代理，这里我们使用的是RabbitMQ来进行消息的传递与收集。（环境搭建省略）</li><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者是<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-stream-rabbit &lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为我们可以看到spring-cloud-starter-turbine-amqp实际上是包装了spring-cloud-starter-turbine-stream和spring-cloud-starter-turbine-stream依赖。  </p><ol start="3"><li><p>在Spring Boot主类上添加@EnableTurbineStream注解来启用Turbine Stream的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTurbineStream</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">TurbineApplication</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(TurbineApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件信息中添加RabbitMq的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">   application: </span><br><span class="line">       name: springCloudMonitor</span><br><span class="line">server: </span><br><span class="line">  port: <span class="number">8040</span> </span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">  instance:</span><br><span class="line">    hostname: registry</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">        user.name: $&#123;security.user.name&#125;</span><br><span class="line">        user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br></pre></td></tr></table></figure></li></ol><p>对于Turbine的配置已经完成，还需要对服务消费者做一些修改，修改如下：  </p><ol><li>添加对RabbitMQ支持依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为第一个依赖项是对下面两个依赖项的整合，所以下面的和上面的效果是以昂的。</p><ol start="2"><li>添加对RabbitMQ配置信息的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    host: localhost</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以通过消息队列的方式进行系统监控。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控之Spring Cloud Turbine快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Spring Cloud Turbine是对集群中微服务信息的统一监控收集监控信息，我们在每个微服务中添加了对Hystrix熔断器功能的支持，可以通过/hystrix.stream对每个微服务的运行状况进行监控，如果在集群中去对每一个微服务去进行单个访问是行不通的，这时候turbine就发挥了它的优势，他可以将多个微服务的hystrix.stream聚合到一起使用turbine.stream进行聚合监控。  </p><h1 id="Spring-Cloud-Turbine快速入门"><a href="#Spring-Cloud-Turbine快速入门" class="headerlink" title="Spring Cloud Turbine快速入门"></a>Spring Cloud Turbine快速入门</h1><ol><li><p>添加依赖项，spring-cloud-starter-turbine，使用HystrixDashboard对Hystrix熔断进行图形化监控。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot的主类上添加@EnableTurbine注解开启Turbine功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudHystrixTurbineApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudHystrixTurbineApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，修改如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8031</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springhystrixturbine</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:password@localhost:8761/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: <span class="keyword">default</span></span><br><span class="line">  #turbine.app-config指定了要收集监控信息的服务名</span><br><span class="line">  appConfig: spring-cloud-user,spring-cloud-service</span><br><span class="line">    #turbine.cluster-name-expression 指定集群名称</span><br><span class="line">  clusterNameExpression: <span class="string">"'default'"</span></span><br><span class="line">  combine-host-port: true #使同一主机上的多个服务实例可以通过主机名和端口号的组合来进行区分</span><br></pre></td></tr></table></figure></li></ol><p>配置信息参数描述：  </p><ul><li>turbine.appConfig：制定要收集监控信息的服务名，意思就是代表这些服务的hystrix.stream由turbine来进行收集监控。</li><li>turbine.cluster-name-expression：指定集群的名称。</li><li>combine-host-port：默认是true，代表同一台主机上多个服务实例可通过主机名和端口号组合来进行区分，因为同一个服务器可能部署多台微服务实例。</li></ul><ol start="4"><li>集群监控，可以通过访问<a href="http://localhost:8031/hystrix" target="_blank" rel="noopener">http://localhost:8031/hystrix</a> 对单个服务进行监控<br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic1.png" alt="turbine页面" title="turbine主页面"><br>可以清晰的看到下面的需要进行turbine监控的url的写法<a href="http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：" target="_blank" rel="noopener">http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：</a><br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic2.png" alt="turbine页面" title="turbine主页面"><br>这说明我们集群监控配置成功。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API网关服务-Spring Cloud Zuul快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-zuul/"/>
      <url>/2018/09/27/quick-start-spring-cloud-zuul/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#简介">简介</a></li><li><a href="#Spring-Cloud-Zuul使用">Spring Cloud Zuul使用</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。</p><h2 id="Spring-Cloud-Zuul使用"><a href="#Spring-Cloud-Zuul使用" class="headerlink" title="Spring Cloud Zuul使用"></a>Spring Cloud Zuul使用</h2><ol><li>添加依赖项<code>spring-cloud-starter-zuul</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-zuul包下不仅仅包含zuul-core包，还包含了spring-cloud-starter-hystrix、spring-cloud-starter-ribbon、spring-boot-starter-autuator，提供了负载均衡以及熔断器的支持。  </p><ol start="2"><li>Spring Boot主类添加@EnableZuulProxy注解开启Zuul的API网关功能。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 网关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们可以看到@EnableZuulProxy注解其实是一个组合注解，它包含了开启Hystrix熔断技术的功能以及对Eureka注册中心的功能的开启。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker    # 开启Hystrix熔断器功能。</span><br><span class="line">@EnableDiscoveryClient   # 开启Eureka客户端功能。</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(&#123;ZuulProxyMarkerConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>修改配置文件信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudzuul</span><br><span class="line">server:</span><br><span class="line">  port: 8050</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://admin:password@localhost:8761/eureka</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">zuul:</span><br><span class="line">  ignoredServices: springcloudservice    # 取消对服务路由机制列表</span><br><span class="line">  routes:</span><br><span class="line">    springclouduser: /user/**     # 指定服务路径。</span><br><span class="line"># Hystrix超时等到时间。</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 20000</span><br><span class="line"># ribbon超时等待时间。</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: 10000</span><br><span class="line">  ConnectTimeout: 10000</span><br></pre></td></tr></table></figure></li></ol><p>理由规则配置讲解：</p><ul><li><code>zuul.ignoredServices</code>：取消路由机制的服务名称列表。</li><li><code>zuul.routes.name</code>: 我们可以看到name被标记为红色字体，代表的是注册到erueka服务中的服务名称，例如上面是springclouduser服务的路由规则是通过/user进行访问该服务的所有接口信息。</li><li><code>zuul.routes.xxx.path=/xxx/**</code><br><code>zuul.routes.xxx.url=http://localhost:8080/</code><br>该配置的表示所有符合/xxx/**规则的访问都将转发到<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 地址上，例如：访问服务中的<a href="http://localhost:8081/xxx/getUserList" target="_blank" rel="noopener">http://localhost:8081/xxx/getUserList</a> 接口时，API网关服务会将该请求路由到<a href="http://localhost:8080/getUserList" target="_blank" rel="noopener">http://localhost:8080/getUserList</a> 提供的服务接口上。其中红色部分为路由的名称，可以任意定义，但是一组path和url映射关系的路由名称要相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置管理中心Spring Cloud Config快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-config/"/>
      <url>/2018/09/27/quick-start-spring-cloud-config/</url>
      
        <content type="html"><![CDATA[<h1 id="配置管理中心-Spring-Cloud-Config"><a href="#配置管理中心-Spring-Cloud-Config" class="headerlink" title="配置管理中心-Spring Cloud Config"></a>配置管理中心-Spring Cloud Config</h1><h2 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h2><p>Spring Cloud Config是用为分布式系统中的基础设施和服务应用提供集中化的外部配置支持，它分为服务端和客户端两个部分。服务端是一个独立的服务，用来连接配置仓库并为客户端提供获取配置信息、加密、解密信息等访问接口，客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关配置内容，并在启动时候从配置中心获取和加载配置信息。Spring Cloud Config默认是git仓库进行存储配置信息，同时也支持其他方式进行存储，例如数据库，文件系统等。  </p><h2 id="Spring-Cloud-Config使用"><a href="#Spring-Cloud-Config使用" class="headerlink" title="Spring Cloud Config使用"></a>Spring Cloud Config使用</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>添加依赖项<code>spring-cloud-stater-config-server</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置相关信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableConfigServer    # 开启Spring Cloud Config功能。</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，添加配置服务的基本信息以及git仓库相关信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/dwlsxj/spring-cloud-test.git  # 配置仓库地址。</span></span><br><span class="line">          search-paths: git-repo # 仓库文件夹地址。</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: $&#123;security.user.name&#125;</span><br><span class="line">      user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">    defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password@localhost:8761/eureka/# Eureka地址。</span></span><br><span class="line"># 安全验证。</span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: user</span><br><span class="line">    password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中配置信息分别如下所示：<br><code>spring.cloud.config.server.git.uri</code>：git仓库的地址。<br><code>spring.cloud.config.server.search-paths</code>：对应仓库下相对所搜的位置，可以配置多个，其实就是存储配置信息的具体位置，例如如果仓库中存放了其他的内容并不是单纯存储配置信息，可通过该参数对配置信息进行搜索，定位。<br><code>spring.cloud.config.server.git.username</code>：访问git仓库的用户名。<br><code>spring.cloud.config.server.git.password</code>：访问git仓库的密码。</p><ol start="4"><li>配置规则详解,我们可以通过浏览器、postman、curl等工具直接访问配置相关信息，访问配置信息的URL与配置文件的映射关系如下所示：</li></ol><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties  </li></ul><p>访问地址：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic2.png" alt="配置信息" title="配置信息"><br>当我们通过URL访问配置信息时，我们发现控制台出现如下内容：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic3.png" alt="本地存储信息" title="本地存储信息"></p><p>配置服务实际是从Git仓库获取配置信息后，会存储一份在config-server的文件系统中，实质上config-server是通过git clone命令将配置内容复制一份在本地存储，然后读取本地内容返回给客户端，通过本地仓库暂存，可以有效的放置当git仓库出现故障而引起的无法加载的问题。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p>添加依赖项<code>spring-cloud-starter-config</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>对配置文件进行添加配置中心服务地址，以及安全访问的用户名密码等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springclouduser</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">        uri: http:<span class="comment">//localhost:8080</span></span><br><span class="line">        fail-fast: <span class="keyword">true</span></span><br><span class="line">        username: user</span><br><span class="line">        password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br><span class="line">        profile: dev</span><br><span class="line">        label: master</span><br><span class="line">        retry:  # 重试机制。</span><br><span class="line">            initial-interval: <span class="number">2000</span></span><br><span class="line">            max-interval: <span class="number">10000</span></span><br><span class="line">            multiplier: <span class="number">2</span></span><br><span class="line">            max-attempts: <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：<br><code>spring.application.name</code>：服务名称，对应配置文件规则中的{application}部分。<br><code>spring.cloud.config.uri</code>:配置中心服务地址。<br><code>spring.cloud.config.username</code>:访问服务注册中心用户名。<br><code>spring.cloud.config.password</code>:访问注册中心密码。<br><code>spring.cloud.config.profile</code>:应用的环境信息，对应配置规则中的{profile}部分。<br><code>spring.cloud.config.label</code>:主要是分支，对应配置文件规则中的{label}部分。<br>需要注意的是这些配置信息必须配置到<code>bootstrap.yml</code>或<code>bootstrap.properties</code>文件中，因为配置信息<code>application.yml</code>和<code>bootstrap.yml</code>是有加载顺序的，首先程序启动时先加载的是<code>bootstrap.yml</code>文件，其次是<code>application.yml</code>配置信息，因为jar包之外的配置信息优先于jar包之内的配置信息，所以需要首先加载外部的配置信息。  </p><ol start="3"><li>对配置信息的读取和使用，首先需要添加配置类，对配置信息通过EL表达式的方式进行注入。<br>读取方式有两种方式：  </li></ol><ul><li><p>通过@Value(“${profile}”)方式绑定参数到属性中。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;profile&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Environment对象来获取配置属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="meta">@GetMapping</span>(“/getProfile”)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(“profile”,“<span class="keyword">null</span>”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务容错保护Spring Cloud Hystrix之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-hystrix/"/>
      <url>/2018/09/27/quick-start-spring-cloud-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Spring-Cloud-Hystrix介绍">Spring Cloud Hystrix介绍</a></li><li><a href="#Spring-Cloud-Hystrix整合">Spring Cloud Hystrix整合</a><ul><li><a href="#常用配置">常用配置</a>  </li></ul></li></ul><h2 id="Spring-Cloud-Hystrix介绍"><a href="#Spring-Cloud-Hystrix介绍" class="headerlink" title="Spring Cloud Hystrix介绍"></a>Spring Cloud Hystrix介绍</h2><p>Spring Cloud Hystrix实现了断路器、线程隔离等一系列服务保护功能。它是基于Netflix的开源框架Hystrix实现，该框架的目标在于通过控制那些访问远程系统，服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级，服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等功能。<br>场景描述：如果我们在微服务中进行通信时，发现其中微服务宕机了，这时候另外一个服务调用了宕机的服务，如果在没有断路器机制的前提下访问，这时候会一直等待，一直等待到服务达到超时的点，会使得线程因调用故障服务被长时间占用不能释放，通过断路器的故障监控，如果发现故障时，会向调用者返回一个错误相应，这样就不用长时间等待。</p><h2 id="Spring-Cloud-Hystrix整合"><a href="#Spring-Cloud-Hystrix整合" class="headerlink" title="Spring Cloud Hystrix整合"></a>Spring Cloud Hystrix整合</h2><ol><li>添加依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId &gt;</span><br><span class="line">&lt;/denpendecy&gt;</span><br></pre></td></tr></table></figure></li></ol><p>同时需要添加<code>spring-boot-starter-actuator</code>，这是Spring Boot对监控的依赖项，只有添加了这些东西后监控相关的endpoint才会被注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解<code>@EnableCircuitBreaker</code>，对Hystrix进行开启功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableEurekaClient#开启Eureka客户端注册</span><br><span class="line">@EnableCircuitBreaker #开启Hystrix功能</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudUserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造服务消费方式，通过添加@HystrixCommod注解对服务接口的熔断技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TestController.class);    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getHelloWorld的熔断机制。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 熔断信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>代码分析：</p><ol><li>通过依赖注入RestTemplate，该Bean主要是对Rest Api进行访问，可以裂解调用服务接口的封装。</li><li>定义了getHelloWorld去访问另外一个服务springcloudservice的getHelloWorld方法</li><li>对该接口上添加了@HystrixCommod注解，通过制定fallbackMethod对出现问题接口进行错误转向</li><li>定义错误转向方法：fallback()</li><li>当springcloudservice服务宕机后，可以快速返回“error“字样。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommod</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HystrixCommand &#123;</span><br><span class="line"><span class="comment">// HystrixCommand 命令所属的组的名称：默认注解方法类的名称</span></span><br><span class="line"><span class="function">String <span class="title">groupKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// HystrixCommand 命令的key值，默认值为注解方法的名称</span></span><br><span class="line"><span class="function">String <span class="title">commandKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 线程池名称，默认定义为groupKey</span></span><br><span class="line"><span class="function">String <span class="title">threadPoolKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 定义回退方法的名称, 此方法必须和hystrix的执行方法在相同类中</span></span><br><span class="line"><span class="function">String <span class="title">fallbackMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 配置hystrix命令的参数</span></span><br><span class="line">HystrixProperty[] commandProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 配置hystrix依赖的线程池的参数</span></span><br><span class="line">HystrixProperty[] threadPoolProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。我们也可以通过此方法定义哪些需要忽略的异常</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] ignoreExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义执行hystrix observable的命令的模式，类型详细见ObservableExecutionMode</span></span><br><span class="line"> <span class="function">ObservableExecutionMode <span class="title">observableExecutionMode</span><span class="params">()</span> <span class="keyword">default</span> ObservableExecutionMode.EAGER</span>;</span><br><span class="line"> <span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。此方法定义需要抛出的异常</span></span><br><span class="line">HystrixException[] raiseHystrixExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义回调方法：但是defaultFallback不能传入参数，返回参数和hystrix的命令兼容</span></span><br><span class="line"><span class="function">String <span class="title">defaultFallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Hystrix超时时间</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                       timeoutInMilliseconds: <span class="number">5000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端负载均衡Spring Cloud Ribbon之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-ribbon/"/>
      <url>/2018/09/27/quick-start-spring-cloud-ribbon/</url>
      
        <content type="html"><![CDATA[<h1 id="客户端负载均衡-Spring-Cloud-Ribbon"><a href="#客户端负载均衡-Spring-Cloud-Ribbon" class="headerlink" title="客户端负载均衡-Spring Cloud Ribbon"></a>客户端负载均衡-Spring Cloud Ribbon</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#客户端负载均衡-Spring-Cloud-Ribbon">客户端负载均衡-Spring Cloud Ribbon</a><ul><li><a href="#Spring-Cloud-Ribbon介绍">Spring Cloud Ribbon介绍</a></li><li><a href="#Spring-Cloud-Ribbon使用">Spring Cloud Ribbon使用</a></li></ul></li></ul><h2 id="Spring-Cloud-Ribbon介绍"><a href="#Spring-Cloud-Ribbon介绍" class="headerlink" title="Spring Cloud Ribbon介绍"></a>Spring Cloud Ribbon介绍</h2><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它是基于Netflix的Ribbon的实现。通过Spring Cloud的封装可以轻松的将面向服务的Rest模板请求自动转化成客户端负载均衡的服务调用。它是一个工具类框架，不能像服务注册中心、配置中心、API网关单独部署，但是可以存在每一个Spring Cloud构建的微服务和基础设施中。<br>负载均衡模块都会维护一个可用的服务列表，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。客户端负载均衡和服务端负载均衡唯一的区别是客户端负载均衡中，所有客户端负载均衡都会自己维护服务清单，而这些服务清单是由服务注册中心获取得到。  </p><h2 id="Spring-Cloud-Ribbon使用"><a href="#Spring-Cloud-Ribbon使用" class="headerlink" title="Spring Cloud Ribbon使用"></a>Spring Cloud Ribbon使用</h2><p>1．    添加依赖项<code>spring-cloud-starter-ribbon</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解对负载均衡支持<code>@LoadBalanced</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务之间调用通过服务名称的方式进行调用而不是通过ip地址的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的springcloudservice是注册到Eureka的服务，服务名称为springcloudservice，可以通过加了@LoadBalanced修饰过的RestTemplate来实现面向服务的接口调用。之前调用方式如下代码所示：restTemplate.getForObject(“<a href="http://localhost:8888/getHelloWorld&quot;" target="_blank" rel="noopener">http://localhost:8888/getHelloWorld&quot;</a>, String.class);</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务治理-Spring Cloud Eureka</title>
      <link href="/2018/09/26/spring-cloud-tutorial-eureka/"/>
      <url>/2018/09/26/spring-cloud-tutorial-eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka介绍"><a href="#Eureka介绍" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h1><p>Eureka是Spring Cloud Netflix的微服务套件的一部分，它是基于Netflix Eureka的二次开发，主要负责完成微服务架构中的服务治理功能。而且可以与Spring boot很容易的整合进行开发，使得开发变得简单，Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端，也被称为服务消费者与服务的生产者，服务启动时向服务注册中心（服务端）进行注册自己，并通过定时心跳检测的方式告诉服务端存活状态，更新服务续约，同时也可以将服务端的服务列表缓存到本地并周期性刷新服务列表的状态。</p><h1 id="Eureka的使用"><a href="#Eureka的使用" class="headerlink" title="Eureka的使用"></a>Eureka的使用</h1><p>服务端</p><ol><li>在pom文件中添加依赖项。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加配置信息，在application.yml或application.properties中添加如下内容  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springcloudeurekaserver   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: 8761  # 端口号</span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        registerWithEureka: false # 是否注册自己，不注册</span><br><span class="line">        fetchRegistry: false   # 禁止检测服务</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//$&#123;security.user.name&#125;:$&#123;security.user.password&#125;@localhost:$&#123;server.port&#125;/eureka/   #Eureka服务地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 处于安全考虑需要对用户进行登录。</span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;REGISTRY_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaServer注解，开启对Eureka服务的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行Eureka服务，通过访问<a href="http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：" target="_blank" rel="noopener">http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：</a><br><img src="/2018/09/26/spring-cloud-tutorial-eureka/pic1.png" alt="Eureka服务" title="Eureka服务"></p><h2 id="页面描述"><a href="#页面描述" class="headerlink" title="页面描述"></a>页面描述</h2></li><li>nstances currently registered with Eureka：服务注册列表信息。</li><li>DS Replicas代表的集群部署时，server地址。<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1></li><li><p>在pom文件中添加依赖项。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"># 需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息，在application.yml或application.properties中添加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springclouduser   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span></span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/#Eureka服务地址。</span></span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaClient注解或@ EnableDiscoveryClient，开启对Eureka客户端的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样三步骤就讲微服务注册到服务中心中，可以看到服务中心已经获取到当前服务信息。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一文搭建Maven骨架</title>
      <link href="/2018/09/23/maven-skeleton-generation/"/>
      <url>/2018/09/23/maven-skeleton-generation/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#Maven骨架介绍">Maven骨架介绍</a><ul><li><a href="#Maven-archetype">Maven archetype</a></li></ul></li><li><a href="#maven骨架创建过程">Maven骨架创建过程</a><ul><li><a href="#使用archetype创建项目">使用archetype创建项目</a></li></ul></li><li><a href="#使用本地Maven骨架">使用本地Maven骨架</a></li></ul><h1 id="Maven骨架介绍"><a href="#Maven骨架介绍" class="headerlink" title="Maven骨架介绍"></a>Maven骨架介绍</h1><h2 id="Maven-archetype"><a href="#Maven-archetype" class="headerlink" title="Maven archetype"></a>Maven archetype</h2><p>Archetype是一个Maven项目模板工具包，通过Archetype我们可以快速搭建Maven项目，通俗理解就是项目的基础架构，项目初始化的过程。我们在使用Idea开发工具的时候会有如下图操作：<br><img src="/2018/09/23/maven-skeleton-generation/./pic.png" alt="IDEA" title="IDEA"><br>在这里选择的Maven进行生成的项目都是利用Maven骨架来进行生成的，通过选择骨架生成项目结构的方式方便了我们手动去搭建相关项目内容。可以直接通过自带骨架或自己构建的骨架进行项目的快速搭建，节约成本。<br>我们构建一个完整的骨架整体的操作逻辑如下图所示：<br><img src="/2018/09/23/maven-skeleton-generation/./pic1.png" alt="Maven archetype" title="Maven archetype"><br>接下来将详细剖析每一步内容。  </p><h1 id="Maven骨架创建过程"><a href="#Maven骨架创建过程" class="headerlink" title="Maven骨架创建过程"></a>Maven骨架创建过程</h1><h2 id="使用archetype创建项目"><a href="#使用archetype创建项目" class="headerlink" title="使用archetype创建项目"></a>使用archetype创建项目</h2><ol><li>第一步建立Maven的项目，其实就是我们想要生成骨架的项目结构。  </li><li><p>在pom.xml中添加插件maven-archetype-plugin。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开命令行进入到项目主目录中，运行如下命令：<font style="color:red"><code>mvn archetype:create-from-project</code></font><br>此时会在该项目的target目录下发现如下文件：<br><img src="/2018/09/23/maven-skeleton-generation/./pic2.png" alt="maven骨架目录" title="maven骨架目录"><br>我们可以清晰的发现archetype目录下是我们的项目结构，项目结构下面src/main/resources/META-INF/包含archetype-metadata.xml，这个文件是用来自定义骨架内容的，接下内容中会对信息进行详细的说明。</p></li><li>进入到target/generated-sources/archetype目录下，使用mvn clean install进行打包到本地文件中。<br>这时候你会在maven的本地仓库中多出一个文件archetype-catalog.xml<br><img src="/2018/09/23/maven-skeleton-generation/./pic3.png" alt="archetype-catalog.xml" title="archetype-catalog.xml"><br>打开文件发现这里面有我们添加的Maven骨架信息。<br><img src="/2018/09/23/maven-skeleton-generation/./pic4.png" alt="maven骨架目录" title="maven骨架目录"><br><em><code>注意：如果想要删除本地的内容就直接删除archetype节点即可。</code></em><h1 id="使用本地Maven骨架"><a href="#使用本地Maven骨架" class="headerlink" title="使用本地Maven骨架"></a>使用本地Maven骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>          禁止询问，如果不加命令行会询问你填写版本号等信息是否正确。  </span><br><span class="line">-DarchetypeCatalog=local         生成项目解析方式，local=本地骨架 internal=内部的  remote=这是Maven中央存储库或其镜像的捷径  </span><br><span class="line">-DgroupId=com.jtech.wpark.test   生成项目的groupId  </span><br><span class="line">-DartifactId=tetetetetet         生成项目的artifactId  </span><br><span class="line">-DarchetypeGroupId=com.jtech     骨架的groupId  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT 骨架版本号  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype   骨架的artifactId</span><br></pre></td></tr></table></figure></li></ol><p><code>archetypeCatalog</code>如果想要来自不同仓库的骨架信息，可以在maven的Setting.xml中设置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;</span><br><span class="line">  &lt;url&gt;https://repository.domain.com/path/to/repo/&lt;/url&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- in case of a repository with authentication --&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;          // 私服的Id</span><br><span class="line">  &lt;username&gt;xxxx&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;xxxx&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></p><p>如果Maven中央存储库目录文件是空的，则使用内部目录。  </p><h1 id="Maven私服上传"><a href="#Maven私服上传" class="headerlink" title="Maven私服上传"></a>Maven私服上传</h1><p>使用mvn clean deploy对骨架上传到私服中，这里会存在一个问题，也就是上传的地址需要在pom.xml配置下，pom.xml文件路径为<code>target/generated-sources/archetype/pom.xml</code>文件。<br><img src="/2018/09/23/maven-skeleton-generation/./pic5.png" alt="配置上传路径" title="配置上传路径"><br>需要对该pomw文件添加distributionManagement节点，节点内容主要是私服地址信息，配置之后使用mvn clean deplod会将骨架上传到私服中去。</p><h1 id="使用私服服务器骨架"><a href="#使用私服服务器骨架" class="headerlink" title="使用私服服务器骨架"></a>使用私服服务器骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>  </span><br><span class="line">-DarchetypeCatalog=internal,remote            类型改变  </span><br><span class="line">-DarchetypeRepository=http:<span class="comment">//xxxxxx:8181/nexus/content/groups/public 私服地址  </span></span><br><span class="line">-DarchetypeGroupId=com.jtech  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT  </span><br><span class="line">-DgroupId=com.jtech.wpark.test  </span><br><span class="line">-DartifactId=tetetetetet  </span><br><span class="line">-Dversion=<span class="number">0.1</span>-SNAPSHOT</span><br></pre></td></tr></table></figure><p>这里需要注意一下,我们发现修改了远程私服进行构建项目时，指定了Repository为什么没有下载下来反而会出现如下错误信息：<br><img src="/2018/09/23/maven-skeleton-generation/./pic6.png" alt="错误信息" title="错误信息"><br>解决方案是：<br>修改maven的setting.xml文件，将文件修改为如下：  </p><ol><li><p>添加repository</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;snapshot&lt;/id&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">      &lt;repository&gt;</span><br><span class="line">        &lt;snapshots /&gt;</span><br><span class="line">          &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">          &lt;name&gt;my-snapshot&lt;/name&gt;</span><br><span class="line">          &lt;url&gt;http:<span class="comment">//127.0.0.1:8181/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">      &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">  &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;snapshot&lt;/activeProfile&gt;</span><br><span class="line">  &lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加server</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;   </span><br><span class="line">    &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对私服的repository，以及Server，这里的Server ID和对应的archetype repository的Id是一致的。这样才会在私服中下载下来相应的archetype文件。 </p><h1 id="自定义骨架内容"><a href="#自定义骨架内容" class="headerlink" title="自定义骨架内容"></a>自定义骨架内容</h1><p>当我们按照上面步骤走完之后发现项目中多出了不需要的文件，这时候我们就需要对骨架的内容进行自定义。<br><img src="/2018/09/23/maven-skeleton-generation/./pic7.png" alt="多余内容" title="多余内容"><br>这里面.idea和yaoyuan.iml文件都不是我们想要的，这时候我们想到之前说过的一个文件archetype-metadata.xml，我们打开这个文件看一下。  （这里的xml指的是target生成的文件目录下的）<br><img src="/2018/09/23/maven-skeleton-generation/./pic8.png" alt="xml内容" title="xml内容"><br>包含了一堆没用的文件进来了，这时候我们将这些东西删除掉，在mvn install一下。<br><img src="/2018/09/23/maven-skeleton-generation/./pic9.png" alt="生成内容" title="生成内容">  </p><p><code>注意：这个文件很重要，主要是如果文件夹为空的时候当我们生成骨架的时候是不会包含当前文件的，你需要对上面xml进行配置包含当前文件即可。</code></p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载器详解</title>
      <link href="/2018/09/23/java-class-loader/"/>
      <url>/2018/09/23/java-class-loader/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#类加载器详解">类加载器详解</a><ul><li><a href="#一、类加载器5大部分">一、类加载器5大部分</a><ul><li><a href="#加载">加载</a></li><li><a href="#验证">验证</a></li><li><a href="#准备">准备</a></li><li><a href="#解析">解析</a></li><li><a href="#初始化">初始化</a></li></ul></li><li><a href="#二、类加载器">二、类加载器</a></li><li><a href="#三、自定义类加载器">三、自定义类加载器</a>  </li></ul></li></ul><h1 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h1><h2 id="一、类加载器5大部分"><a href="#一、类加载器5大部分" class="headerlink" title="一、类加载器5大部分"></a>一、类加载器5大部分</h2><p>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。<br><img src="/2018/09/23/java-class-loader/./pic1.png" alt="加载机制" title="JVM类加载机制">  </p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;</code>方法之中，这里我们后面会解释。<br>但是注意如果声明为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info</span><br><span class="line">CONSTANT_Field_info</span><br><span class="line">CONSTANT_Method_info</span><br></pre></td></tr></table></figure></p><p>等类型的常量。<br>下面我们解释一下符号引用和直接引用的概念：<br>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。<br>初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。<code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;clinit&gt;</code>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。（clinit初始化是对类成员信息进行初始化，init是对对象实例进行初始化操作）<br>注意以下几种情况不会执行类初始化：<br>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>定义对象数组，不会触发该类的初始化。<br>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。<br>通过类名获取Class对象，不会触发类的初始化。<br>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。  </p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：  </p><ol><li>启动类加载器(<code>Bootstrap ClassLoader</code>)：负责加载 JAVA_HOME\lib（JRE/lib/rt.jar） 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。  </li><li>扩展类加载器(<code>Extension ClassLoader</code>)：负责加载 JAVA_HOME\lib\ext（JRE/lib/ext/*.jar） 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。  </li><li>应用程序类加载器(<code>Application ClassLoader</code>)：负责加载用户路径（classpath）上的类库。</li><li>自定义的类加载器（<code>User ClassLoader</code>）：负责加载用户自定义的路径上的类库。<br>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承<code>java.lang.ClassLoader</code>实现自定义的类加载器。</li></ol><p><img src="/2018/09/23/java-class-loader/./pic2.png" alt="委托图" title="委托图"><br>类加载器的委托机制：  </p><ol><li>首先当前线程去加载线程中的第一个类  </li><li>如果A中引用了B，java虚拟机将使用加载类A的类加载取来加载B  </li><li>还可以直接使用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。   </li></ol><p>每个类加载器加载类时，又先委托给其上级类加载器。   </p><ol><li>当所有祖先类加载器没有加载到类，回到发起者类加载器，还加载不了就抛出异常<code>ClassNotFoundException</code>，不是再去找发起类加载器的儿子节点，因为没有getChild方法。  </li></ol><p>eg.比如说我们自定义一个类A，当我们去获取当前类加载器的名称时，肯定是AppClassLoader加载器，因为我们当前类只有CLASSPATH路径下有没如果我们将当前的项目打包成test.jar将jar包放入到JRE/lib/ext路径下，这时候我们在CLASSPATH中类就不会被加载，首先加载的是ext下的类A。这时候我们输出类A加载器名称的时就会输出ExtClassLoader。下面做演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.printf(ClassLoaderTest.class.getClassLoader().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClassLoaderTest是我们新建立的类，获取当前类的加载器时输出内容为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure></p><p>如果打包成jar包放到，ext文件下我们来看一下内容：<br><img src="/2018/09/23/java-class-loader/./pic.png" alt="ext目录结构" title="ext目录结构"></p><p>这是输出一下内容查看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = com.classloadertest.ClassLoaderTest.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(classLoader.getClass().getName()); </span><br><span class="line">    classLoader=classLoader.getParent();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure><p>循环输出类加载器结构的时候会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>因为Bootstrap类加载器实现不是由Java实现所以获取不到字节码，也就是为null的时候意味着是树状结构的顶层。</p><h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><p>有些时候我们需要实现自定义的类加载器来加载一些类，这时候我们可以继承ClassLoader来进行实现自定义的类加载器。我们先看一下jdk中的ClassLoader的源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归先父类进行尝试加载。</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>首先检测当前类有没有加载，如果加载在就不需要加载直接返回字节码</li><li>如果没有被加载，这时候会委托加载机制，通过递归从父加载器开始找，直到父类加载器为bootstrap ClassLoader为止，如果父类加载器找到了该字节码后没直接返回如果没有就返回让子类加载器加载，当子类加载器时，</li><li>如果还没有找到，这时候调用findClass方法进行查找。</li><li>最后根据resolve的值，判断这个class是否需要解析。<br><img src="/2018/09/23/java-class-loader/./pic3.png" alt="流程图" title="流程图"></li></ol><p>首先类加载器进行加载时当前线程的上线文的<code>ClassLoader</code>也就是<code>APPClassLoader</code>，当加载类时调用<code>LoadClass</code>方法，当调用的时候会检测当前类有没有被加载如果被加载了，就不需要在加载了直接返回，反之调用父类加载器的<code>LoadClass</code>方法，当父类加载器的父加载器不是null的时候就再去调用<code>LoadClass</code>方法，这时候的类加载器是<code>ExtClassLoader</code>加载器，父类加载是<code>BootStrap ClassLoader</code>，这时候继续递归调用<code>LoadClass</code>方法，这时候类加载器为<code>BootStrap ClassLoader</code>， 这时候就不需要再往下寻找了， <code>parent ClassLoader</code>为null。这是调用<code>findBootstrapClassOrNull(name)</code>方法，如果c不为null，这时候就直接返回，但是如果为null就调用<code>findClass</code>进行查询加载，如果还为null，这时候就会调用父类加载器<code>ExtClassLoader</code>的<code>findClass</code>方法，如果还是没有找到，则调用线程本身的类加载器调用findClass方法返回相应字节码，如果还没有找到抛出异常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载器采用了设计模式是模板方法，也就是LoadClass方法是不需要进行改变的，我们需要关注的就是findClass()方法就好了。所以我们写自己的ClassLoader只需要继承ClassLoader并重写findClass方法即可。</span><br></pre></td></tr></table></figure></p><p>参考地址：<br><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a><br><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态代理的工作原理简要分析</title>
      <link href="/2018/09/20/how-dynamic-agents-work/"/>
      <url>/2018/09/20/how-dynamic-agents-work/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#动态代理的工作原理">1. 动态代理的工作原理</a><ul><li><a href="#什么是代理">1.1. 什么是代理</a></li><li><a href="#什么是动态代理">1.2. 什么是动态代理</a></li><li><a href="#动态代理的原理">1.3. 动态代理的原理</a></li><li><a href="#实现AOP功能的封装和配置">1.4. 实现AOP功能的封装和配置</a></li></ul></li></ul><h1 id="动态代理的工作原理"><a href="#动态代理的工作原理" class="headerlink" title="动态代理的工作原理"></a>动态代理的工作原理</h1><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>比如说我们去租房子，需要通过中介代理来进行看房子，由于代理的手中有大量资源，有大部分房源都在代理手中掌握，所以不需要我们自己去一个一个去找寻，通过这样我们无需知道房东是谁就可以租到合适的房子，这就是代理，代理模式两个优点一是可以隐藏委托类的实现，二是可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><h2 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h2><p>代理类在运行时创建的过程叫做动态代理。也就是说这个代理类不是我们是事先写好的，而是由程序运行时自动生成的代理类，比如我们举一个静态代理例子：<br>我们首先定义一个接口<code>ISayHello</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个被代理对象：<code>SayHello</code>，并且继承自上面的接口，并实现接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> <span class="keyword">implements</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"hello world proxy！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是重点我们接下来要写代理类，代理类和被代理类之间是依赖组合关系，也就是说被代理类和代理类是同时存在的，也就是生命周期是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayProxy</span> <span class="keyword">implements</span> <span class="title">ISayHello</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> SayHello sayHello;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SayProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sayHello=<span class="keyword">new</span> SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">before();</span><br><span class="line">sayHello.sayHello();</span><br><span class="line">after();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello Before"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello After"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以达到动态扩充被代理类的内容，上面的内容是静态的动态代理，也就是代理类是我们已经写好的，接下来我们就要演示如何实现动态代理类。</p><h2 id="动态代理的原理"><a href="#动态代理的原理" class="headerlink" title="动态代理的原理"></a>动态代理的原理</h2><ol><li>JVM可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理。</li><li>JVM生成的代理类必须实现一个或多个接口，所以JVM生成的动态代理类只能用作具有相同接口的目标类代理。</li><li>CGLIB库可以生成一个类的子类，一个类的子类也可以用作该类的代理，所以如果要为一个没有实现接口的类生成动态代理类那么可使用CGLIB。</li></ol><p>Java提供了相应的代理类<code>java.lang.reflect.Proxy</code>，通过这个类能够动态生成代理类对象，接下来我们来做一下演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理相关内容实现</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);</span><br><span class="line">System.out.println(<span class="string">"代理类名称："</span> + clazz.getName(System.out.println(<span class="string">"代理类类加载器："</span> + clazz.getClassLoader());</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor item : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名字："</span> + item.getName());</span><br><span class="line">Parameter[] parameters = item.getParameters();</span><br><span class="line"><span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数类型："</span> + parameter.getParameterizedType() + <span class="string">"参数名称："</span> + parameter.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取<code>Collection</code>的代理类，Proxy提供了<code>getProxyClass</code>方法来进行获取代理类，这个方法有两个参数，第一个参数是加载这个代理类对象的类加载器，第二个参数是代理类对象实现的接口。我们来看一下输出结果内容：</p><p>代理类名称：<code>com.sun.proxy.$Proxy0</code></p><p>代理类类加载器：<code>null</code></p><p>方法名字：<code>com.sun.proxy.$Proxy0</code> </p><p>参数类型：<code>interface java.lang.reflect.InvocationHandler</code> 参数名称：<code>arg0</code></p><p>分析一下上面代码内容，首先我们创建了实现<code>Collection</code>接口的动态代理类对象，并返回动态代理类的字节码，这时候我们用反射方式查看一下动态代理对象的构造方法以及动态代理对象的名称和动态代理构造器方法。<br>我们仔细看到加载<code>com.sun.proxy.$Proxy0</code>的类加载器是<code>Bootstrap</code>类加载器，由于<code>Collection</code>加载器就是<code>Bootstrap</code>类加载器。所以返回的是<code>null</code>，因为该类加载器不是java实现的。构造函数的参数类型是InvocationHandler这个接口类型主要是做什么呢？我们接下俩一步一步来进行解密，这里留一下一个小小的悬念。<br>接下来通过反射的方式获取下当前代理类所实现的方法有哪些：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名称："</span> + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">方法名称：add  </span><br><span class="line">方法名称：remove  </span><br><span class="line">方法名称：equals  </span><br><span class="line">方法名称：toString  </span><br><span class="line">方法名称：hashCode  </span><br><span class="line">方法名称：clear  </span><br><span class="line">方法名称：contains  </span><br><span class="line">方法名称：isEmpty  </span><br><span class="line">方法名称：iterator  </span><br><span class="line">方法名称：size  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：spliterator  </span><br><span class="line">方法名称：addAll  </span><br><span class="line">方法名称：stream  </span><br><span class="line">方法名称：forEach  </span><br><span class="line">方法名称：containsAll  </span><br><span class="line">方法名称：removeAll  </span><br><span class="line">方法名称：removeIf  </span><br><span class="line">方法名称：retainAll  </span><br><span class="line">方法名称：parallelStream  </span><br><span class="line">方法名称：isProxyClass</span><br><span class="line">方法名称：getInvocationHandler  </span><br><span class="line">方法名称：newProxyInstance  </span><br><span class="line">方法名称：getProxyClass  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：getClass    </span><br><span class="line">方法名称：notify  </span><br><span class="line">方法名称：notifyAll</span><br></pre></td></tr></table></figure></p><p>由于代理类实现了Collection接口，所以接口中所有类方法都会被继承，还有Object中的方法，当然Object中不是所有方法都会交给代理类来执行，只有<code>hashCode,equals和toString方法</code>会交给代理类处理。也就是说当我们调用collection.getClass()会输出com.sun.proxy.$Proxy0而不是输出目标对象ArrayList，这就说明Object中的方法不是所有方法都派发给目标对象来执行，只有上面说的三个方法才会委托给InvocationHandler中的invoke方法来进行执行。而其他的方法有自己的实现。<br>  到这里我们的动态代理对象字节码分析完毕，这时候我们要创建动态代理的对象实例。<br>我们上面了解到动态代理对象是只有一个构造函数，这个构造函数传递参数是InvocationHandler接口，这时候我们就需要创建一个自己MyInvocationHandler对象实现InvocationHandler接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line">ArrayList target = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用前:"</span> + method.getName());</span><br><span class="line"><span class="comment">//代理对象方法调用</span></span><br><span class="line">Object o = method.invoke(target, args);</span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用后:"</span> + method.getName());</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来详细分析下这个接口中的方法，该接口中只有一个方法，也就是invoke方法，这个方法主要是什么作用呢？当我们调用代理类的方法是首先会调用MyInvocationHandler中invoke方法，通过调用这个方法来调用目标对象的方法体。实际上动态代理类实现的方法如下所示，例如我们现在实现的Collection接口的size方法，代理类对象的方法大致实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  $Proxy0  implements Collection&#123;</span><br><span class="line"></span><br><span class="line">InvocationHandler hander;</span><br><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler  handler)&#123;</span><br><span class="line"><span class="keyword">this</span>.handler=handler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> handler.invoke(<span class="keyword">this</span>,<span class="keyword">this</span>.getClass().getMethod(“size”),<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Handler的invoke 方法三要素：代理对象，代理对象方法，代理对象参数。<br>也就是说代理对象首先先调用我们构造函数中传递的handler对象的invoke方法，通过调用invoke方法来调用目标对象中存在的size方法。这也是Aop的原理，AOP的实现就是用了动态代理的方式进行操作的，目标对象返回的结果就是代理类返回的结果。<br>创建动态代理对象如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getConstructor(InvocationHandler.class);</span><br><span class="line">Collection collection = (Collection) constructor.newInstance(<span class="keyword">new</span> MyInvocationHandler());</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br></pre></td></tr></table></figure></p><p>这时候输出结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:size  </span><br><span class="line">方法调用后:size  </span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>正如我们上面分析的内容，我们来看一下动态代理类内部结构图：<br><img src="/2018/09/20/how-dynamic-agents-work/./pic1.png" alt="代理内部结构图" title="动态代理类内部结构图">  </p><p>当客户端调用代理对象的方法时，首先先经过InvocationHandler的invoke方法，这个方法体中可以扩充我们想要的内容，比如前置通知，后置通知，参数过滤等一系列操作，然后再通过该方法传入的method调用目标对象的方法，达到代理的作用。  </p><h2 id="实现AOP功能的封装和配置"><a href="#实现AOP功能的封装和配置" class="headerlink" title="实现AOP功能的封装和配置"></a>实现AOP功能的封装和配置</h2><p>实现思路是我们在配置文件中配置我们需要代理的目标对象，通知对象，通过配置文件进行切换是否生成代理对象，通过代理对象工厂进行判断是否生成代理类。工厂类BeanFactory负责创建目标类或代理类的实例对象，其getBean方法根据参数字符串返回一个响应的实例对象，也就是上面是通过ProxyFactoryBean进行判断是否生成代理对象，如果配置文件中配置的对象为ProxyFactoryBean的话，通过调用ProxyFactoryBean中的getProxy生成代理对象并返回，反之直接创建该对象实例并返回。<br>直接上代码首先看一下BeanFactory，主要是创建代理对象或者非代理对象实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//从配置文件中读取相应配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanFactory</span><span class="params">(InputStream ips)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   properties.load(ips);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String className = properties.getProperty(name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object bean = clazz.newInstance();</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ProxyFactoryBean) &#123;</span><br><span class="line">ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean) bean;</span><br><span class="line">String tagertClassName = properties.getProperty(name + <span class="string">".target"</span>);</span><br><span class="line">Class tagertClazz = Class.forName(tagertClassName); String adviceClassName = properties.getProperty(name + <span class="string">".advice"</span>);Class adviceClazz = Class.forName(adviceClassName); proxyFactoryBean.setAdvice((Advice)adviceClazz.newInstance());</span><br><span class="line">proxyFactoryBean.setTarget(tagertClazz.newInstance());</span><br><span class="line"><span class="keyword">return</span> proxyFactoryBean.getProxy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line"> System.out.println(ex.getMessage()); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码主要内容是首先构造函数是InputStream流用来加载properties配置文件的内容，配置相关内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean</span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice</span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>xxx也就是我们要获取的bean对象，如果对象类型为ProxyFactoryBean的话，就给该对象设置代理对象和通知对象。接下来我们看看ProxyFactoryBean中到底做了什么东西？前面我们已经提到了ProxyFactoryBean主要是创建代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得代理类</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Advice通知</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">                getTarget().getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        getAdvice().before();</span><br><span class="line">                        Object result = method.invoke(getTarget(), args);</span><br><span class="line">                        getAdvice().after();</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>target主要是目标代理对象，也就是我们要代理的目标对象，Advice对象主要是我们的通知对象，通知对象中只包含前置通知和后置通知这两个。主要是getProxy获取代理对象这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">getTarget().getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">getAdvice().before();</span><br><span class="line">Object result = method.invoke(getTarget(), args);</span><br><span class="line">getAdvice().after();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中我们可以看到直接调用了Proxy.newProxyInstance方法，而不再是调用Proxy.getClassProxy这个方法获取字节码的方式，这就告诉我们Proxy的创建可以分为两种方式进行创建，这种方式比较简便，方法中有三个参数第一个参数指定类加载器，第二个参数是代理对象要实现的接口有哪些，第三个方法就是InvocationHandler，这里我们传入的参数目标类的加载器，以及目标类实现的接口，第三个参数我们这边才用的是匿名内部类的方式传递。其中Invoke方法中要调用目标对象的方法，也就是method.invoke(target,args);<br>接下来我们看一下通知类Advice中写了什么内容。<br>首先我们声明了接口Advice<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又写了MyAdvice类继承并实现Advice接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通知方法中没有写太多东西就是输出一些信息表示已经应用了通知内容。<br>接下来就是调用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream ips = TestApplication.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">Object bean = <span class="keyword">new</span> com.test.Aop.BeanFactory(ips).getBean(<span class="string">"xxx"</span>);</span><br><span class="line">Collection collection = (Collection) bean;</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">collection.add(<span class="string">"444"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br><span class="line">System.out.println(bean.getClass().getName());</span><br></pre></td></tr></table></figure></p><p>由于我是用Spring boot 搭建的项目所以配置文件名称为application.properties，这个不重要，重要的是配置文件内容，上面我已经提到了第一种配置内容为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean  </span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice  </span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>当我们调用getBean获取xxx时，如果xxx配置为ProxyFactoryBean的话就会创建代理类我们看一下输出内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">4</span><br><span class="line">com.sun.proxy.<span class="variable">$Proxy0</span></span><br></pre></td></tr></table></figure></p><p>最后输出内容为￥Proxy0表示创建代理对象成功，并调用了通知方法，如果配置文件修改为如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx= java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>输出内容则为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>因为没有创建代理对象所以获取类型是返回ArrayList类型。完结  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的blog之旅又要开始了</title>
      <link href="/2018/09/18/hello-world/"/>
      <url>/2018/09/18/hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">距离我的个人博客服务器到期到现在也有一段时间了，这段时间里面已经停止了些东西，最近要把写文章这件事慢慢的拾起来，制定写作计划。</span><br></pre></td></tr></table></figure><h2 id="博客主要内容"><a href="#博客主要内容" class="headerlink" title="博客主要内容"></a>博客主要内容</h2><p>博客主要内容是针对技术的分享与交流，主要技术有spring，spring boot，spring cloud，java，mybatis等技术框架的技术分享，也业余分享python等，大数据相关技术的内容的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-远程仓库</title>
      <link href="/2016/01/14/git-learning-5-remote/"/>
      <url>/2016/01/14/git-learning-5-remote/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件，指令讲解"><a href="#一、文件，指令讲解" class="headerlink" title="一、文件，指令讲解"></a><strong>一、文件，指令讲解</strong></h2><p>首先讲一下远程仓库和本地仓库在文件上面的区别，首先我们来看下对比图（当然这里说的区别是在于.git文件下面的文件内容，至于里面内容我们不会关注）這裡我们进行了相同的操作就是本地仓库里面新建了version.txt内容也是一样的v1.0：</p><p><img src="/2016/01/14/git-learning-5-remote/1.png" alt="图1"></p><p><img src="/2016/01/14/git-learning-5-remote/2.png" alt="图2"></p><p>图一为本地仓库，图二为克隆的远程仓库，首先我们应该看一下config里面的区别：</p><p><img src="/2016/01/14/git-learning-5-remote/3.png" alt="图3"></p><p><img src="/2016/01/14/git-learning-5-remote/4.png" alt="图4"></p><p>很容易看到了区别就是图四为远程仓库内容。</p><p>从这个文件中我们可以了解到：</p><ol><li><p>本地库的当前分支为master，其关联的远程库名称为origin（不同的名称可以指向同一个远程库，参见git remote命令）</p></li><li><p>远程库origin所在的位置为(URL)：<a href="https://github.com/dwlsxj/BattleHeart.git" target="_blank" rel="noopener">https://github.com/dwlsxj/BattleHeart.git</a><br>然后进行了version.txt的编辑和提交。这是我们刚才新建version.txt（远程）以及再添加内容为“v1.0”，在添加到暂存区，提交到本地提交中，最后提交到远程服务器，下面是我们生成的commit对象和git对象还有就是tree对象内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/18/6c4629f6de8c956548570a113fa181d9b22692   commit对象</span><br><span class="line">.git/objects/90/e34626d7993cf8d6c5e3e458744df4a9a31594   tree对象</span><br><span class="line">.git/objects/c6/94c68edd99aeefa053f25308cd71ecca922036   blob对象</span><br></pre></td></tr></table></figure><p>接下来我们就来看一下这个commit对象和tree对象下面的树分支和commit的指向内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 186c46</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 90e346</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -t c694c6</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 186c46</span><br><span class="line">tree 90e34626d7993cf8d6c5e3e458744df4a9a31594</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452303321 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452303321 +0800</span><br><span class="line">inital commit</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 90e346</span><br><span class="line">100644 blob c694c68edd99aeefa053f25308cd71ecca922036    version.txt</span><br><span class="line"></span><br><span class="line">$ git cat-file -p c694c6</span><br><span class="line">V1.0</span><br></pre></td></tr></table></figure><p>当我们git  push origin master（命令格式：git push [remote-name] [branch-name]）时候会生成一个我们会发现.git/refs/文件夹下多了一个remote文件夹</p><p><img src="/2016/01/14/git-learning-5-remote/5.png" alt="图5"></p><p>我们跟进去看一下会有一个默认origin服务器名称，下面会有一个master分支，也就是这个代表的是远程服务器的master分支并不代表我们本地的master分支。看一下这个master分支内容和本地分支的内容是否一致，因为我们刚才将提交的内容提交到origin服务器上，应该两个分支引用指向的commit记录是一样的。</p><p><img src="/2016/01/14/git-learning-5-remote/6.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/  -type f</span><br><span class="line">.git/objects/18/6c4629f6de8c956548570a113fa181d9b22692</span><br><span class="line">.git/objects/90/e34626d7993cf8d6c5e3e458744df4a9a31594</span><br><span class="line">.git/objects/9f/aadaec6f7c8657372544e6f414f9b0b6910279</span><br><span class="line">.git/objects/c6/94c68edd99aeefa053f25308cd71ecca922036</span><br></pre></td></tr></table></figure><p>提交到本地版本控制中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;second commit version.txt&apos;</span><br><span class="line">[master 5777c82] second commit version.txt</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>提交之后产生的commit对象和新的tree对象内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/18/6c4629f6de8c956548570a113fa181d9b22692</span><br><span class="line">.git/objects/57/77c8270e24ff7417fa6f8d27f73c068acd42b0</span><br><span class="line">.git/objects/90/e34626d7993cf8d6c5e3e458744df4a9a31594</span><br><span class="line">.git/objects/9f/aadaec6f7c8657372544e6f414f9b0b6910279</span><br><span class="line">.git/objects/a4/3a49679a6ecd3cbcdd889aeb9906b8620e7976</span><br><span class="line">.git/objects/c6/94c68edd99aeefa053f25308cd71ecca922036</span><br></pre></td></tr></table></figure><p>看一下了两个master分支内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/master</span><br><span class="line">5777c8270e24ff7417fa6f8d27f73c068acd42b0</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">186c4629f6de8c956548570a113fa181d9b22692</span><br></pre></td></tr></table></figure><p>啊哈，果然不出我们所料，这就是说明本地提交的记录还没有提交的远程服务器上面所以说这个远程服务器的master分支还是指向了原来的commit对象。<br>当我们使用的了git   fetch  [remote-name]从服务器里面拉去数据的时候会产生一个FETCH_HEAD指针。这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。这时候我们会发现有一个FETCH_HEAD指针是一个指向远程最后一次获取的指针位置。首先我们看一下这个FETCH_HEAD指针的主要作用：</p><p><img src="/2016/01/14/git-learning-5-remote/7.png" alt=""></p><p>也就是说我们每次获取的本地没有的文件后都会有一个fetch_HEAD，这个指针和本地的HEAD指针有着区别，这样我们现在还看不出来因为本地和服务器上的记录都是一样的。这时候我们来在服务器上面添加一个readme文件提交上去，再在本地获取。<br>添加readme文件这里是在服务器上直接提交的记录，所以跟本地数据没有任何关系。</p><p><img src="/2016/01/14/git-learning-5-remote/8.png" alt=""></p><p>当我们使用git  fetch  origin命令的之后，我们来看一下.git/objects在服务器上产生的新的commit记录和tree对象还有git对象内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find    .git/objects/ -type f</span><br><span class="line">.git/objects/18/6c4629f6de8c956548570a113fa181d9b22692</span><br><span class="line">.git/objects/50/204399d2b99a020ac03dbca151570a959b7523</span><br><span class="line">.git/objects/56/f565ecbaa66b236c42914bfd7e93a5eb0844f7</span><br><span class="line">.git/objects/57/77c8270e24ff7417fa6f8d27f73c068acd42b0</span><br><span class="line">.git/objects/90/e34626d7993cf8d6c5e3e458744df4a9a31594</span><br><span class="line">.git/objects/9f/aadaec6f7c8657372544e6f414f9b0b6910279</span><br><span class="line">.git/objects/a4/3a49679a6ecd3cbcdd889aeb9906b8620e7976</span><br><span class="line">.git/objects/c6/94c68edd99aeefa053f25308cd71ecca922036</span><br><span class="line">.git/objects/e0/26393257f8b7519ac7c378c6ff470ca737fe10</span><br></pre></td></tr></table></figure><p>这里面有三个对象是git  fetch后新增加的就是如下几个，然后我们通过查看其类型以及其中的内容就能看到确实是从服务器上拉取出来的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 502043</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 502043</span><br><span class="line">tree e026393257f8b7519ac7c378c6ff470ca737fe10</span><br><span class="line">parent 186c4629f6de8c956548570a113fa181d9b22692</span><br><span class="line">author BattleHeart &lt;dwlsxj2013@hotmail.com&gt; 1452324317 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj2013@hotmail.com&gt; 1452324317 +0800</span><br><span class="line"></span><br><span class="line">Create commit Readme</span><br><span class="line"></span><br><span class="line">Create commit Readme</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 56f565</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 56f565</span><br><span class="line"># BattleHeart</span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">$ git cat-file -t e02639</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p e02639</span><br><span class="line">100644 blob 56f565ecbaa66b236c42914bfd7e93a5eb0844f7    README.md</span><br><span class="line">100644 blob c694c68edd99aeefa053f25308cd71ecca922036    version.txt</span><br></pre></td></tr></table></figure><p>其实这时候我们来看一下git的历史记录图。</p><p><img src="/2016/01/14/git-learning-5-remote/9.png" alt=""></p><p>这里的lol命令是我取的别名log  –oneline  –decorate  –graph  –all。可以看到这个命令分了两个，就是说origin/master是服务器的master分支。我们来看一下master分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/heads/master                       本地分支引用</span><br><span class="line">5777c8270e24ff7417fa6f8d27f73c068acd42b0</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/remotes/origin/master     服务器master分支引用</span><br><span class="line">50204399d2b99a020ac03dbca151570a959b7523</span><br></pre></td></tr></table></figure><p>也就是说本地分支引用是没有变化的，变化的是服务器master分支引用的地址从186c46变化到了最新的502043这个commit提交记录上面了。其实这之后FETCH_HEAD也会将最新的commit记录在里面（这里不是指向master分支上而是指向了commit记录上面），也就是说FETCH_HEAD指的是: 某个branch在服务器上的最新状态。其中每一行对应于远程服务器的一个分支.当前分支指向FETCH_HEAD, 就是这个文件第一行对应的那个分支。这里服务器里面只有一个master分支是默认的分支。</p><p><img src="/2016/01/14/git-learning-5-remote/10.png" alt=""></p><p>虽然说拉去出来的数据但是并不是我们想要的，拉去的数据并没有放在本地仓库指向的内容里面而是服务器分支指向的内容里面。这时候我们是用git merge来进行合并。也就是说这个FETCH_HEAD里面存在的是服务器上每一个分支上面最后一个提交记录内容，当然我们也可以使用git  merge  FETCH_HEAD这个命令来合并分支，但是多条分支记录的时候他只会取出第一条merge记录。这时候我们就需要使用服务器的分支来进行合并了，比如origin/test指针就可以git  merge  origin/test。这与后面要讲的git  pull的区别就是从服务器上面获取下来的内容分支之类的不会直接合并到本地，而是自己去合并但是git pull是git pull = git fetch + git merge的操作。</p><p>git  pull命令：<br>接下来我们就来演示下git pull内容，首先我们在服务上面新建了一个空的仓库，把这个空的仓库拉到本地来，新建一个文件a，在文件a里面添加一条记录this is file a on local master，把他提交到本地仓库里面，我们看一下如下操作：<br>新建一个文件a并赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;this is file a on local master&apos; &gt; a</span><br></pre></td></tr></table></figure><p>看一下文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat a</span><br><span class="line">this is file a on local master</span><br></pre></td></tr></table></figure><p>添加到暂存区内将添加的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>将文件添加版本记录中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;local first commit&apos;</span><br><span class="line">[master (root-commit) 7358cc0] local first commit</span><br><span class="line">warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">create mode 100644 a</span><br></pre></td></tr></table></figure><p>这时候看一下产生的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/34/da50374fa7eaa9d2ea609198237ed8af97c7e9</span><br><span class="line">.git/objects/73/58cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">.git/objects/7e/8f2d0c90cdd5dffd9bfb5f32604f74199725e4</span><br></pre></td></tr></table></figure><p>分别查看一下这些对象的类型以及对象的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 34da50</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 34da50</span><br><span class="line">100644 blob 7e8f2d0c90cdd5dffd9bfb5f32604f74199725e4    a</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7e8f2d</span><br><span class="line">this is file a on local master</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7358cc</span><br><span class="line">tree 34da50374fa7eaa9d2ea609198237ed8af97c7e9</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452330539 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452330539 +0800</span><br><span class="line"></span><br><span class="line">local first commit</span><br></pre></td></tr></table></figure><p>这时候我们将新的文件提交到服务器上面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Writing objects: 100% (3/3), 235 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/dwlsxj/test.git</span><br><span class="line">* [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><p>OK提交成功了，这时候.git/refs就会生成一个remote文件文件里面有默认服务器名称origin文件夹，该文件夹下面保存了服务器上最新的master分支指向的内容。让我们来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/refs/remotes/origin/master               服务器master分支</span><br><span class="line">7358cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master                              本地master分支</span><br><span class="line">7358cc0797e6bf72393ab54c543c6261784c27dc</span><br></pre></td></tr></table></figure><p>这时候是一样的，因为服务器分支和本地分支是一样的。接下来我们在服务器分支上面修改下a文件如下图所示：</p><p><img src="/2016/01/14/git-learning-5-remote/11.png" alt=""></p><p>这时候我们会想到服务器上面会产生commit记录这时候服务器的master分支的指向就不再是本地这个指向了。<br>这时候我们也来修改下本地的a文件。添加文本内容为this is file a on local master second edit。提交到版本控制中。看一下所有的操作内容:<br>编辑文件a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim a</span><br></pre></td></tr></table></figure><p>将a文件添加到暂存区内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br></pre></td></tr></table></figure><p>看一下新生成的git对象内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/34/da50374fa7eaa9d2ea609198237ed8af97c7e9</span><br><span class="line">.git/objects/73/58cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">.git/objects/7e/8f2d0c90cdd5dffd9bfb5f32604f74199725e4</span><br><span class="line">.git/objects/af/cc87af98402de78840dc0737700a62345abff4</span><br></pre></td></tr></table></figure><p>将修改的a文件提交到记录里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;local second commit on master&apos;</span><br><span class="line">[master warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">de7c4cd] local second commit on master</span><br><span class="line">warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这时候我们来看一下提交记录的图，这时候HEAD指针是指向最新的master分支的，但是服务器的master分支则是指向原有的commit记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git lol</span><br><span class="line">* de7c4cd (HEAD -&gt; master) local second commit on master</span><br><span class="line">* 7358cc0 (origin/master) local first commit</span><br></pre></td></tr></table></figure><p>看一下产生的tree对象以及tree对象内容，还有commit对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/34/da50374fa7eaa9d2ea609198237ed8af97c7e9</span><br><span class="line">.git/objects/66/e33f7b7a44ad93bcb3a049075e666b9041f63c</span><br><span class="line">.git/objects/73/58cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">.git/objects/7e/8f2d0c90cdd5dffd9bfb5f32604f74199725e4</span><br><span class="line">.git/objects/af/cc87af98402de78840dc0737700a62345abff4</span><br><span class="line">.git/objects/de/7c4cd49e32f197afc6161d0d6f5e6d413212c8</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 66e33f</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 66e33f</span><br><span class="line">100644 blob afcc87af98402de78840dc0737700a62345abff4    a</span><br><span class="line"></span><br><span class="line">$ git cat-file -p  afcc87</span><br><span class="line">this is file a on local master</span><br><span class="line">this is file a on local master second edit</span><br><span class="line"></span><br><span class="line">$ git cat-file -p  de7c4c</span><br><span class="line">tree 66e33f7b7a44ad93bcb3a049075e666b9041f63c</span><br><span class="line">parent 7358cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452331483 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452331483 +0800</span><br><span class="line"></span><br><span class="line">local second commit on master</span><br></pre></td></tr></table></figure><p>OK，到了这里我们就要开始见证奇迹的时候到了，因为我们同时修改了a文件都是从第一次提交的commit记录里面衍生出来的（服务器上和本地提交），接下来就是见证奇迹了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/dwlsxj/test</span><br><span class="line">7358cc0..67f70c5  master     -&gt; origin/master</span><br><span class="line">Auto-merging a</span><br><span class="line">CONFLICT (content): Merge conflict in a</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>Pull之后我们先不着急看a文件的内容，我们先来看一下生成的对象内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/34/da50374fa7eaa9d2ea609198237ed8af97c7e9</span><br><span class="line">.git/objects/59/7f7359a768d3e98b65cd8b1558e09489d920b3</span><br><span class="line">.git/objects/66/e33f7b7a44ad93bcb3a049075e666b9041f63c</span><br><span class="line">.git/objects/67/f70c522e9e5b748445abbb41ea0cfa0fd171f9</span><br><span class="line">.git/objects/73/58cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">.git/objects/7e/8f2d0c90cdd5dffd9bfb5f32604f74199725e4</span><br><span class="line">.git/objects/af/cc87af98402de78840dc0737700a62345abff4</span><br><span class="line">.git/objects/de/7c4cd49e32f197afc6161d0d6f5e6d413212c8</span><br><span class="line">.git/objects/de/fb97746b25d3963454d4ff69fc903956b12075</span><br><span class="line">.git/objects/f5/537ea43f681442d2656105a2f348284181ef95</span><br></pre></td></tr></table></figure><p>接下来就要看一下新增加的对象内容，其实我们猜想就能才想到肯定有三个对象是git对象和commit对象、tree对象因为这是在服务器上提交记录产生的。那么还多一个对象是什么呢？我们来看一下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -t 597f73   该对象是服务器上提交内容对象</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>对象的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -p 597f73</span><br><span class="line">this is file a on local master</span><br><span class="line">this is file a on server master</span><br></pre></td></tr></table></figure><p>接下来67f70c是提交记录，是和上面blob一起的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -t 67f70c</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -p 67f70c</span><br><span class="line">tree f5537ea43f681442d2656105a2f348284181ef95</span><br><span class="line">parent 7358cc0797e6bf72393ab54c543c6261784c27dc</span><br><span class="line">author BattleHeart &lt;dwlsxj2013@hotmail.com&gt; 1452330567 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj2013@hotmail.com&gt; 1452330567 +0800</span><br><span class="line"></span><br><span class="line">this is file a on server master</span><br><span class="line"></span><br><span class="line">this is file a on server master</span><br></pre></td></tr></table></figure><p>接下来是tree对象内容，都是服务器上第二次提交产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -t f5537ea</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p f5537ea</span><br><span class="line">100644 blob 597f7359a768d3e98b65cd8b1558e09489d920b3    a</span><br><span class="line">$ git cat-file -t defb97</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>哎呦，这个对象叼了，这个对象是在本地产生的，产生的冲突文件，我们会发现我没有将Administrator这一行去掉是因为我们现在文件是由冲突的，我们可以看到master|MERGING</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git cat-file -p defb97</span><br><span class="line">this is file a on local master</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">this is file a on local master second edit</span><br><span class="line">=======</span><br><span class="line">this is file a on server master</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 67f70c522e9e5b748445abbb41ea0cfa0fd171f9</span><br></pre></td></tr></table></figure><p>那么下来我们看一下commit的图是如何的：</p><p><img src="/2016/01/14/git-learning-5-remote/12.png" alt=""></p><p>我们发现origin/master分支指向也更新为了最新的记录。并且现在还是两个分支，因为还有冲突没有解决。这时候我们需要解决冲突在提交就好了。</p><p><img src="/2016/01/14/git-learning-5-remote/13.png" alt=""></p><p>并将其提交到记录里面这时候我们就会发现最后的commit图就合并到了一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master|MERGING)</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">$ git commit -m &apos;merge&apos;</span><br><span class="line">[master 0dd66df] merge</span><br><span class="line"></span><br><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/rrr/test (master)</span><br><span class="line">$ git lol</span><br><span class="line">*   0dd66df (HEAD -&gt; master) merge</span><br><span class="line"></span><br><span class="line">|\</span><br><span class="line"></span><br><span class="line">| * 67f70c5 (origin/master) this is file a on server master</span><br><span class="line"></span><br><span class="line">* | de7c4cd local second commit on master</span><br><span class="line"></span><br><span class="line">|/</span><br><span class="line"></span><br><span class="line">* 7358cc0 local first commit</span><br></pre></td></tr></table></figure><p>最后来一张图清晰地告诉大家git fetch和git push的区别。</p><p><img src="/2016/01/14/git-learning-5-remote/14.png" alt=""></p><h2 id="二、结束语"><a href="#二、结束语" class="headerlink" title="二、结束语"></a><strong>二、结束语</strong></h2><p>本篇文章分析完毕，希望各位能够喜欢并且指正里面的错误，分析的有不正确的就指出来。谢谢啦。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-重写历史记录</title>
      <link href="/2016/01/14/git-learning-4-rewriting-history/"/>
      <url>/2016/01/14/git-learning-4-rewriting-history/</url>
      
        <content type="html"><![CDATA[<h2 id="一、git对象文件创建"><a href="#一、git对象文件创建" class="headerlink" title="一、git对象文件创建"></a>一、git对象文件创建</h2><p>开篇先补充一个知识点，就是比如我建立一个文件之后，使用git add就会生成一个git对象，但是git对象生成后可以在.git/objects里面对应，首先我们来初始化一个仓库git init。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>然后我们来创建两个文件文件名分别为a和b。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch a b</span><br></pre></td></tr></table></figure><p>将a文件添加到暂存区，然后再将b添加到暂存区，我们会想到这时候有两个git对象产生，但是git对象对应.git/objects文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/e6</span><br><span class="line">.git/objects/e6/<span class="number">9</span>de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>我们来查看下.git/objects文件下面会产生几条git对象库。这时候超出了我们想象，我们认为对象文件也应该创建两个但是仅仅创建了一个，这是为什么呢？那么着一个文件又指的是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line"></span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>上述命令查看了当前sha-1是git对象（blob）。这时候我们根本就看不出来这个a和b的存放位置。我们将暂存区的文件提交到记录中，git commit –m “initial commit”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">[master (root-commit) 5b077dd] initial commit</span><br><span class="line">2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 a</span><br><span class="line">create mode 100644 b</span><br></pre></td></tr></table></figure><p>这时候我们再来看一下.git/object文件下内容，产生了一个tree对象和commit对象，这个commit对象指向了tree对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/29</span><br><span class="line">.git/objects/29/6e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">.git/objects/5b</span><br><span class="line">.git/objects/5b/077ddc03fa28dff8a1ac0d85969fcc2ac40c0b</span><br><span class="line">.git/objects/e6</span><br><span class="line">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>分别查看下各自的对象类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 296e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">Tree</span><br><span class="line">$ git cat-file -t 5b077ddc03fa28dff8a1ac0d85969fcc2ac40c0b</span><br><span class="line">Commit</span><br><span class="line">$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">Blob</span><br></pre></td></tr></table></figure><p>那么这时候我们要查看一下tree对象里面的内容，应该是a和b分别创建的git对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 296e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line"></span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a</span><br><span class="line"></span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    b</span><br></pre></td></tr></table></figure><p>OK，我们到了这里才看到了，原来产生的两个git对象都存放在了e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391这个文件里面，接下来我要讲一下为什么会存放在一起。<br>首先来说一下sha-1的生成，一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和，也就是说我们创建一个文件a他会根据文件a里面的数据和头部信息拼在一起生成一个sha-1的值，这个头部信息是固定的，如下图所示：</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/1.png" alt=""></p><p>正因为a和b文件的内容一样都是blob空文本所以生成sha-1是一样的所以会放在一个文件里面。</p><h2 id="二、重写历史记录"><a href="#二、重写历史记录" class="headerlink" title="二、重写历史记录"></a>二、重写历史记录</h2><p>以下的命令帮我们重写历史记录</p><ul><li>git  commit  –amend可以产生一个新的提交用来替换掉当前所提交的这个commit</li><li>git  rebase  维护线性历史</li><li>git  reset比如说我们做了一个合并的提交我们想要撤销掉提交然历史记录跟没有产生这样的历史记录一个合并</li><li>git  reflog它维护了一个HEAD引用的历史信息，通常配合git reset来使用</li></ul><h2 id="三、指令详解"><a href="#三、指令详解" class="headerlink" title="三、指令详解"></a>三、指令详解</h2><ol><li>git commit –amend有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有–amend 选项的提交命令尝试重新提交：<br>新建两个文件a和b这时候我们只提交一个文件a到暂存区里面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch  a b</span><br><span class="line">$ git add a</span><br></pre></td></tr></table></figure><p>提交a文件到暂存区内这时候我们就要来看一下生成的对象以及对象类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/e6</span><br><span class="line">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>发现生成了一个e6的文件夹和9de29bb2d1d6434b8b29ae775ad8c2e48c5391文件名的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><p>查看下新生成对象的类型是git对象blob。接下来我们将a文件进行提交到记录里面去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;commit file a&apos;</span><br><span class="line">[master (root-commit) 96696f0] commit file a</span><br><span class="line">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 a</span><br><span class="line">提交完成后，我们再来看一下.git/objects文件下面的内容。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/49</span><br><span class="line">.git/objects/49/6d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">.git/objects/96</span><br><span class="line">.git/objects/96/696f06370488cc9b271dbd870d8ba0d4e7ce3c</span><br><span class="line">.git/objects/e6</span><br><span class="line">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>分别查看下96696f和496d64的对象类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 496d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 96696f06370488cc9b271dbd870d8ba0d4e7ce3c</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>这时候确定了96696f为commit对象，那么496d64就是tree对象。查看下他们的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 96696f06370488cc9b271dbd870d8ba0d4e7ce3c</span><br><span class="line">tree 496d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452085041 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452085041 +0800</span><br><span class="line"> </span><br><span class="line">commit file a</span><br></pre></td></tr></table></figure><p>commit对象内容下面是指向496d64这个tree对象，并且有作者和提交时写的提交信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 496d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a</span><br></pre></td></tr></table></figure><p>Tree对象内容则是他的叶子内容，因为我们只提交了a文件所以只有a文件这个内容。<br>这时候我们发现应该a文件和b文件一起提交而不是分开提交，这时候就是用到接下来的命令–amend命令。那么首先要做的就先把b文件放到暂存区理面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add b</span><br></pre></td></tr></table></figure><p>这时候再使用git  commit  –amend就会将暂存区的文件一起提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit –amend</span><br></pre></td></tr></table></figure><p>当我们输入的时候git commit –amend命令后我们先不着急操作，我们先来看一下产生的文件内容.git/objects文件里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/29/6e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">.git/objects/49/6d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">.git/objects/96/696f06370488cc9b271dbd870d8ba0d4e7ce3c</span><br><span class="line">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure><p>会新生成一个296e56这样一个对象。那么这个对象是什么呢？我们来仔细观察下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 296e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 296e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    a</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    b</span><br></pre></td></tr></table></figure><p>啊哈，原来是个tree对象当然这里同样也产生了blob对象只是内容和a内容一样所以合并成一个文件了，因为296e56树下面有两个子节点。</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/2.png" alt=""></p><p>我们这时候再进行填写注释，我们会发现我上一次提交的信息他给展现出来了，这里我们可以修改成first commit。当我们保存退出后就会产生如下输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br><span class="line">[master 433aedb] first commit</span><br><span class="line">Date: Wed Jan 6 20:57:21 2016 +0800</span><br><span class="line">2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 a</span><br><span class="line">create mode 100644 b</span><br></pre></td></tr></table></figure><p>这回我们再来看一下.git/objects里面内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/29</span><br><span class="line">.git/objects/29/6e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">.git/objects/43</span><br><span class="line">.git/objects/43/3aedb274b59386535efa27c874d1ff5ded4a9b</span><br><span class="line">.git/objects/49</span><br><span class="line">.git/objects/49/6d6428b9cf92981dc9495211e6e1120fb6f2ba</span><br><span class="line">.git/objects/96</span><br><span class="line">.git/objects/96/696f06370488cc9b271dbd870d8ba0d4e7ce3c</span><br><span class="line">.git/objects/e6</span><br><span class="line">.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>多出来了一个433aed对象，那么这个对象是什么东西呢？以及里面存放的东西是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 433aedb274b59386535efa27c874d1ff5ded4a9b</span><br><span class="line">commit</span><br><span class="line"> </span><br><span class="line">$ git cat-file -p 433aedb274b59386535efa27c874d1ff5ded4a9b</span><br><span class="line">tree 296e56023cdc034d2735fee8c0d85a659d1b07f4</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452085041 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452085549 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>我们看到了这个是个commit对象并且这个commit对象指向了新生成的树对象，以及commit对象没有父节点也就是说本次提交相当于第一次提交。</p><ol start="2"><li>git rebase<br>新建两个文件a和b文件，添加文件a的内容为this is file a，添加文件内容b为this is file b。并将其添加到暂存区内。</li></ol><p><img src="/2016/01/14/git-learning-4-rewriting-history/3.png" alt=""></p><p>git  add  .添加到暂存区内，查看一下.git/objects里面的内容，会产生两个git对象，对象类型为blob。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/77</span><br><span class="line">.git/objects/77/486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">.git/objects/ba</span><br><span class="line">.git/objects/ba/f5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>查看下git对象的类型以及git对象下的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 77486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t baf5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p baf5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">this is file a</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 77486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">this is file b</span><br></pre></td></tr></table></figure><p>将两个文件同时提交到记录里面。Git commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;first commit&apos;</span><br><span class="line">[master (root-commit) 4bd85c6] first commit</span><br><span class="line">warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">warning: LF will be replaced by CRLF in b.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">2 files changed, 2 insertions(+)</span><br><span class="line">create mode 100644 a</span><br><span class="line">create mode 100644 b</span><br></pre></td></tr></table></figure><p>这时候我们来看一下objects文件下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/4b</span><br><span class="line">.git/objects/4b/d85c6b6ed389f268ca7c183e560fb9cb33430e</span><br><span class="line">.git/objects/77</span><br><span class="line">.git/objects/77/486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">.git/objects/ba</span><br><span class="line">.git/objects/ba/f5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">.git/objects/bd</span><br><span class="line">.git/objects/bd/887f9b4dc0d570bd7cae7e604e0da5dd3f466a</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>这时候会多两个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t bd887f</span><br><span class="line">Tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 4bd85c</span><br><span class="line">Commit</span><br></pre></td></tr></table></figure><p>这时候整体记录的内容结构如下图所示：</p><p>这时候我们新建一个分支test，并切换到test分支上面，在分支上面修改下a文件内容添加内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch test</span><br></pre></td></tr></table></figure><p>这时候结构是这个样子的。</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/5.png" alt=""></p><p>这时候我们要在master分支上面修改下a文件并且提交a文件内容，这时候会产生新的commit对象以及tree对象和新生成git对象。<br>首先我们要做到在master分值上面先修改下a文件然后commit到记录里面，然后在修改下b文件在提交到记录里面。这是会产生两条记录让我们来看一下：<br>首先做的就是添加a文件内容为this is master branch，并且添加到暂存区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim a</span><br><span class="line"></span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>在来查看下新生成的git对象（blob），这个对象的sha-1为a4cb8b4（与上次对比）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">.git/objects/4b</span><br><span class="line">.git/objects/4b/d85c6b6ed389f268ca7c183e560fb9cb33430e</span><br><span class="line">.git/objects/77</span><br><span class="line">.git/objects/77/486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">.git/objects/a4</span><br><span class="line">.git/objects/a4/cb8b4e0819ae97811f650886390e17e54bc93c</span><br><span class="line">.git/objects/ba</span><br><span class="line">.git/objects/ba/f5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">.git/objects/bd</span><br><span class="line">.git/objects/bd/887f9b4dc0d570bd7cae7e604e0da5dd3f466a</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>查看下a4cb8b4类型是blob那么查看下当前文件下的内容正是我们添加的内容一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t a4cb8b4</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -p a4cb8b4</span><br><span class="line">this is file a</span><br><span class="line">this is master branch</span><br></pre></td></tr></table></figure><p>这时候提交到版本控制里面去，将修改的文件a。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;master commit&apos;</span><br><span class="line">[master warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">a6bcbb7] master commit</span><br><span class="line">warning: LF will be replaced by CRLF in a.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>当然提交上去的时候这时候必然会产生commit对象和新的tree对象。让我们看一下谁是commit对象，谁是tree对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects/ -type f</span><br><span class="line">.git/objects/4b/d85c6b6ed389f268ca7c183e560fb9cb33430e</span><br><span class="line">.git/objects/77/486f708f7f7a0dab6f951148b75365081fcc3c</span><br><span class="line">.git/objects/a4/cb8b4e0819ae97811f650886390e17e54bc93c</span><br><span class="line">.git/objects/ba/f5b90e3bc9f0c775c8d52764d353212259ffb3</span><br><span class="line">.git/objects/bd/887f9b4dc0d570bd7cae7e604e0da5dd3f466a</span><br><span class="line">.git/objects/99/1f631d3674f37a8595fd782ce9fd57d354103a</span><br><span class="line">.git/objects/a6/bcbb77ada043da6df0a55918cac224bae50ef1</span><br></pre></td></tr></table></figure><p>这时候我们发现比上一次对象多出了两个对象分别是991f63和a6bcbb，多出了这两个对象，那么我们来看一下这两个对象就是是什么类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 991f63</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 991f63</span><br><span class="line">100644 blob a4cb8b4e0819ae97811f650886390e17e54bc93c    a</span><br><span class="line">100644 blob 77486f708f7f7a0dab6f951148b75365081fcc3c    b</span><br></pre></td></tr></table></figure><p>OK，991f63是tree对象，而且tree对象下面的内容中有一个是我们刚修改的a文件的git对象和第一次提交的b文件的git对象。<br>那么a6bcbb就是commit对象，且commit对象的指向是上面的tree对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t a6bcbb</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">$ git cat-file -p a6bcbb</span><br><span class="line">tree 991f631d3674f37a8595fd782ce9fd57d354103a</span><br><span class="line">parent 4bd85c6b6ed389f268ca7c183e560fb9cb33430e</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452165520 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452165520 +0800</span><br><span class="line">master commit</span><br></pre></td></tr></table></figure><p>Ok，这时候整体的提交之后的示意图如下所示：</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/6.png" alt=""></p><p>这时候按照上面步骤看一下b的，这时候git对象变成了af379ed，commit对象变成了359118，tree对象变成了73f2e9。下面是操作记录：</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/7.png" alt=""></p><p>这时候生成commit结构图：</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/8.png" alt=""></p><p>接下来就要换做另一个分支了，按照上面的步骤从新来一遍，先修改下a文件，然后提交到暂存区，然后在修改下b文件再提交到暂存区，这里演示和分析过程就不做了。偷个懒，因为和上面分析过程是一样的不在这里做重复说明了，这时候我们会看到一个分支，分支的commit提交记录是这样的。</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/9.png" alt=""></p><p>详细的结构图我也画了一份出来了，这样方便我们对原文本的追踪以及对整体原理的理解，通过分析哪些对象是新生成的那些对象是原有的就能分析出整体的结构走向。下面就上整体详细的分析图。</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/10.png" alt=""></p><p>这时候我们会发现有两个分支出来了，因为我们现在test分支上面，我们使用git rebase master命令来维护一个线性的记录。<br>当我是用vim的时候肯定会产生冲突，这时候我们解决下冲突文件a和b文件再调用git  rebase  –continue命令即可，这里要详细讲解下合成的原理以及内容，当我git  rebase master的时候会产生两个树对象和一个git对象出来，这时候我们的HEAD头部将会切换到master分支上面，也就是说接下来的操作是在master分支指向的最后一个分支上面进行与test分支上面每一个进行合并，这里我们来看一下git对象的内容是：这个树对象的sha-1是：1de9f3f3cb3c87aaf2e43732ae13bf2aff1f8cda，我们会发现这个tree文件下面git对象是我们之前创建的，并不是这一次产生的，这个git对象是cce4bf，我们查看下他的内容如下所示：（这tree对象下面blob是test分支最后生成的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p cce4bf</span><br><span class="line">this is file a</span><br><span class="line">this is test branch (file a)</span><br></pre></td></tr></table></figure><p>而产生的第二个tree对象是3ada29384374b5219c3564ce1fa999ac4fde99aa是这个，我们发现他的git对象子节点也是之前创建的baf5b9，这个对象的内容是：（这个tree对象下面的blob是master分支第一次产生的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p baf5b9</span><br><span class="line">this is file a</span><br></pre></td></tr></table></figure><p>这时候我们会发现还有一个git对象blob，这个git对象里面到底是什么东西呢？这会引起我们很大的想象，为什么会产生上面两个tree并指向了之前的git对象呢？下面揭开谜底，原来新生成的blob对象就是a文件产生的冲突文件，文件的sha-1是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/72/038d17664a165e8a0bc65b9b028f3322e7f418 blob</span><br><span class="line">$ git cat-file -p 72038d</span><br><span class="line">this is file a</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">this is master branch</span><br><span class="line">=======</span><br><span class="line">this is test branch (file a)</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; this is commit on test branch</span><br></pre></td></tr></table></figure><p>这个文件是怎么产生的，这要说一下冲突产生的算法，我喜欢用数学的思维方式思考：给定两个提交 A和 B，合并提交（commit）操作 A∨B 就可以描述为： [A∨B ]=[ A]+[ B]−[ C ] 这里的 C是A 和 B的合并共有项(最近提交树祖先共同含有的部分)，我们必须要“减去” C，因为如果不这样的话，我们就会有两个A∧B。也就是第一个树对象是B也就是不是HEAD指针指向的master分支下的a的内容，HEAD指针下的内容就是A，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is file a</span><br><span class="line">this is master branch</span><br></pre></td></tr></table></figure><p>A和B的共同之处就是this is file a这个内容（C），A+B-C就是我们现在看到冲突的文件blob（72038d）<br>这时候我们解决完冲突时候，git  add  . 之后就会生成一个新的blob对象就是这个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/07/cf0edd220a022c7447a8cf111bac3ed3422db9  blob对象</span><br><span class="line">this is file a</span><br><span class="line">this is master branch</span><br><span class="line">this is test branch (file a)</span><br></pre></td></tr></table></figure><p>这个对象我们在调用git  rebase  –continue的时候就会产生新的commit对象和tree对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/77/14fb6ec6a19ba0d546d1cd10f89261445d3553  commit对象</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 7714fb</span><br><span class="line">tree 000fbac4af12a11f969d5e46d86d135f62adff8b</span><br><span class="line">parent 35911829097e90763845733d090e17c32d9a218c</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452168533 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452169355 +0800</span><br><span class="line"></span><br><span class="line">this is commit on test branch</span><br><span class="line"></span><br><span class="line">.git/objects/00/0fbac4af12a11f969d5e46d86d135f62adff8b  tree对象</span><br><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/test (test)</span><br><span class="line">$ git cat-file -p 000fba</span><br><span class="line">100644 blob 07cf0edd220a022c7447a8cf111bac3ed3422db9    a</span><br><span class="line">100644 blob af379ed27a46022aca5a851bc55a8f69fd7afe3a    b</span><br></pre></td></tr></table></figure><p>这里我们会发现b文件af379e是HEAD指针的指向的master分支的b文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/af/379ed27a46022aca5a851bc55a8f69fd7afe3a blob</span><br><span class="line">$ git cat-file -p af379e</span><br><span class="line">this is file b</span><br><span class="line">this is branch master(b)</span><br></pre></td></tr></table></figure><p>这时候我们在进行第二次处理冲突内容，也就是b文件的内容，这时候产生的内容和上面的一样的内容。这时候下面的内容就变成这样：（第二部分的分析请读者自行分析）一样的步骤。<br>结构图就变成如下的样子：</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/11.png" alt=""></p><p>整体的commit对象的图就变成这样：(<code>c4’和c5’都是C3的基础上进行合并的</code>)</p><p><img src="/2016/01/14/git-learning-4-rewriting-history/12.png" alt=""></p><h3 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h3><p>接下来的内容就是上图中的节点，至于中间产生的节点只有第一次使用git  rebase  –continue的时候的结果，第二次的结果还请读者自行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/43be0ce752cdabca0968e721fb030000093baa4d commit对象</span><br><span class="line">tree eefcff716912aa684576546f63a06f3a52ce0959</span><br><span class="line">parent 7714fb6ec6a19ba0d546d1cd10f89261445d3553</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452168857 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452169398 +0800</span><br><span class="line"></span><br><span class="line">下面tree对象</span><br><span class="line">.git/objects/eefcff716912aa684576546f63a06f3a52ce0959 tree对象</span><br><span class="line">$ git cat-file -p eefcff</span><br><span class="line">100644 blob 07cf0edd220a022c7447a8cf111bac3ed3422db9    a</span><br><span class="line">100644 blob 19f1ba2426ee5e72b95412c2707e75d9feb2833e    b</span><br><span class="line"></span><br><span class="line">下面得内容</span><br><span class="line">.git/objects/07cf0edd220a022c7447a8cf111bac3ed3422db9  blob对象在上面</span><br><span class="line">tree对象里</span><br><span class="line">this is file a</span><br><span class="line">this is master branch</span><br><span class="line">this is test branch (file a)</span><br><span class="line"></span><br><span class="line">.git/objects/19/f1ba2426ee5e72b95412c2707e75d9feb2833e  blob</span><br><span class="line">this is file b</span><br><span class="line">this is branch master(b)</span><br><span class="line">this is test branch (file b)</span><br><span class="line"></span><br><span class="line">第一次commit对象</span><br><span class="line">.git/objects/7714fb6ec6a19ba0d546d1cd10f89261445d3553  commit对象</span><br><span class="line">$ git cat-file -p 7714fb</span><br><span class="line">tree 000fbac4af12a11f969d5e46d86d135f62adff8b</span><br><span class="line">parent 35911829097e90763845733d090e17c32d9a218c</span><br><span class="line">author BattleHeart &lt;dwlsxj@126.com&gt; 1452168533 +0800</span><br><span class="line">committer BattleHeart &lt;dwlsxj@126.com&gt; 1452169355 +0800</span><br><span class="line"></span><br><span class="line">this is commit on test branch</span><br><span class="line"></span><br><span class="line">.git/objects/00/0fbac4af12a11f969d5e46d86d135f62adff8b  tree对象</span><br><span class="line">Administrator@USER-20150201IC MINGW64 ~/Desktop/test (test)</span><br><span class="line">$ git cat-file -p 000fba</span><br><span class="line">100644 blob 07cf0edd220a022c7447a8cf111bac3ed3422db9    a</span><br><span class="line">100644 blob af379ed27a46022aca5a851bc55a8f69fd7afe3a    b</span><br><span class="line"></span><br><span class="line">.git/objects/07/cf0edd220a022c7447a8cf111bac3ed3422db9  blob对象</span><br><span class="line">this is file a</span><br><span class="line">this is master branch</span><br><span class="line">this is test branch (file a)</span><br><span class="line"></span><br><span class="line">.git/objects/af/379ed27a46022aca5a851bc55a8f69fd7afe3a blob</span><br><span class="line">$ git cat-file -p af379e</span><br><span class="line">this is file b</span><br><span class="line">this is branch master(b)</span><br></pre></td></tr></table></figure><ol start="3"><li>git reflog 罗列出所有的commit对象的sha-1码和commit提交内容，看到我们上面merge操作我们想要换药到之前的操作就用git reset –hard  HEAD@{5}这里的HEAD@{5}是根据reflog查出来的，hard就是将暂存区内容还原到之前。</li></ol><h2 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h2><p>本文的分析全是有本人自己分析，分析的时间有点长，结果有点有仓促，如果有哪里写的不清楚或者不详细的请指正，小丁再次谢过。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-撤销修改</title>
      <link href="/2016/01/14/git-learning-3-revert-operation/"/>
      <url>/2016/01/14/git-learning-3-revert-operation/</url>
      
        <content type="html"><![CDATA[<h2 id="一、撤销指令"><a href="#一、撤销指令" class="headerlink" title="一、撤销指令"></a><strong>一、撤销指令</strong></h2><ul><li>git checkout还原工作区的功能</li><li>git reset  还原暂存区的功能</li><li>git clean  还没有被添加进暂存区的文件也就是git还没有跟踪的文件可以使用这个命令清除他们</li><li>git revert 撤销本次提交。</li></ul><h2 id="二、指令讲解"><a href="#二、指令讲解" class="headerlink" title="二、指令讲解"></a><strong>二、指令讲解</strong></h2><ol><li>Git checkout</li></ol><p>首先我们对文件的一个修改，对master.txt进行了修改</p><p><img src="/2016/01/14/git-learning-3-revert-operation/1.png" alt=""></p><p> 修改结果我们利用上面的知识来进行查看。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/2.png" alt=""></p><p>新增加了Test这么一段话，如果我们想要将工作区的内容添加到暂存区会使用git  add这个命令，如果我们想要还原工作区内容这时候就要用的git checkout命令，实际上做的工作是用暂存区的内容来覆盖我们工作区的内容。看下面操作：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/3.png" alt=""></p><p>查看一下git status</p><p><img src="/2016/01/14/git-learning-3-revert-operation/4.png" alt=""></p><p>发现我们之前的修改被还原了。</p><p>这时候我们在对master.txt进行修改并添加到暂存区里面去。修改内容如下</p><p><img src="/2016/01/14/git-learning-3-revert-operation/5.png" alt=""></p><p>修改完成之后我们来进行提交到暂存区，使用git add 命令。这时候再次查看下状态就变成了changes to be committed的状态。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/6.png" alt=""></p><p>我们可以使用git  reset  HEAD（HEAD~2）这种方式进行还原到某一个提交记录上。因为HEAD所指向的commit就是我们想要恢复的内容，也就是我们HEAD指向的commit就是我们要用这些数据覆盖暂存区数据。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/7.png" alt=""></p><p>这时候我们在git status看一下，暂存区的内容就被还原了。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/8.png" alt=""></p><p>我们可以使用这种还原工作区</p><p><img src="/2016/01/14/git-learning-3-revert-operation/9.png" alt=""></p><p>Git checkout v0 — master.txt ,v0是指向首次提交的commit的记录（这里的v0是给commit打的一个tag记录）。我们来看一下工作区和暂存区的区别：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/10.png" alt=""></p><p>发现少了一行提交内容。我们这时候再用当前HEAD指向的commit还原一下工作区就可以了。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/11.png" alt=""></p><p>这时候就没有了区别了。使用提交记录还原暂存区的内容格式和checkout是一致的这里就不做演示了。（例如用v0 tag的记录还原暂存区，git reset v0 – master.txt还原指定文件）</p><p>在工作区内新建两个文件然后不将文件添加到暂存区内，使用git clean进行清理。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/12.png" alt=""></p><p>这时候使用git clean –n将要删除的文件展示出来。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/13.png" alt=""></p><p>这时候再用git  clean –f进行删除掉这些文件。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/14.png" alt=""></p><p>我们在这里新建一个vim  .gitignore的文件过滤掉后缀为o和a的文件。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/15.png" alt=""></p><p>添加到历史记录里面去，然后在新建文件进行清理。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/16.png" alt=""></p><p>新建了三个文件test.o、test1.a、test2.c这时候我们来使用git clean –n的时候就会显示一条清除记录就是test2.c，默认他不清理gitignore里面的文件。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/17.png" alt=""></p><p>这里我们正好相反我们想要保留ignore以外的文件，清理掉ignore里面的文件。这时候我们就会用到下面的这个指令git  chean  -n  -X后面跟一个大写的X，我们发现得到了我们想要的结果。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/18.png" alt=""></p><p>我们执行它，清理掉这些文件。git  chean  -X –f这时候就清理了.o和.a的文件</p><p><img src="/2016/01/14/git-learning-3-revert-operation/19.png" alt=""></p><p>我们可以使用git revert产生一个新的提交来覆盖我们不想要的上面的ignore提交记录。git revert  HEAD</p><p>下面来演示下git revert的工作原理：</p><p>第一种情况：当我们第一次提交记录时就revert。当我们用touch 生成一个文件a，生成后将a文件放入到暂存区，这时候就会产生一个a的git对象，这个对象存放在.git/objects目录，如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/20.png" alt=""></p><p>当我们还有add的时候objects文件下面就两个默认文件夹。当git add的时候就会产生一个git对象。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/21.png" alt=""></p><p>这个就是git对象，一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。这里不作详解。那么整体的sha-1校验和就是文件名+子目录名。当我调用git commit 的时候会产生一个树对象一个commit对象，并且commit对象指向树对象。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/22.png" alt=""></p><p>接下来我们来看一下那个sha-1是树对象哪一个是commit对象，并且验证下commit对象下面是不是树对象。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/23.png" alt=""></p><p>整体生成本次提交的结构如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/24.png" alt=""></p><p>当我们git revert的时候会产生一个新的tree对象，这个tree对象是创建一个撤销上次修改的tree对象。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/25.png" alt=""></p><p>就变成了现在这个样子了。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/26.png" alt=""></p><p>还有第二种情况就是我们第二次提交之后再进行revert的时候这时候就会生成一个新的commit指向原来的tree对象。接下来我们就来演示下</p><p>首先第一步就是初始化一个仓库这里就不多说了，第二部就是下面图的步骤先新建两个文件a,b两个文件，然后将a和b文件分别添加到暂存区中，这时候就会产生git对象，我们来看一下git对象的类型，确定是blob类型，然后将暂存区的文件提交到记录中。演示如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/27.png" alt=""></p><p>接下来就在查看下.git/objects文件下面生成的对象以及对象的类型，然后我们就开始准备第二题提交，首先编辑下a文件添加到暂存区里面这时候会产生一个git对象（blob）。如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/28.png" alt=""></p><p>这时候就能看到我们新增加的git对象内容以及sha-1。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/29.png" alt=""></p><p>接下来我们就要查看新生成对象的类型，在进行第二次提交git  commit，当我们提交之后会生成新的对象，再看一下新对象类型的属性，刚好查看第一个对象是commit对象看一下他的内容。详细请见下图：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/31.png" alt=""></p><p>接下来就要看一下tree对象以及tree对象下的元素都有哪些，详情请见下图</p><p><img src="/2016/01/14/git-learning-3-revert-operation/32.png" alt=""></p><p>那么这是我们看一下它产生的记录结构如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/33.png" alt=""></p><p>当我们revert之后，就会生成一个新的commit将指向第一次提交的tree对象。我们来看一下新生成的commit对象的sha-1。</p><p><img src="/2016/01/14/git-learning-3-revert-operation/34.png" alt=""></p><p>这时候看一下它产生的记录结构如下图所示：</p><p><img src="/2016/01/14/git-learning-3-revert-operation/35.png" alt=""></p><h2 id="三、结束语"><a href="#三、结束语" class="headerlink" title="三、结束语"></a><strong>三、结束语</strong></h2><p>本文内容皆为研究成果以及学习文章后总结，如果上述问题有错误之处请指正，我发现截图太多了，应该换一种方式。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-工作区、暂存区、分支</title>
      <link href="/2016/01/13/git-study-2/"/>
      <url>/2016/01/13/git-study-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h1><ol><li>初始化一个仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git  init</span><br><span class="line">git  clone</span><br></pre></td></tr></table></figure></li></ol><p>git仓库分为两种情况：<br>第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  init  –bare  git 创建一个裸仓库</span><br></pre></td></tr></table></figure></p><ol start="2"><li>git仓库有三个区域</li></ol><ul><li>工作区working directory日常编辑代码的地方</li><li>历史仓库history repository是commit指向的一个树形结构</li><li>暂存区Staging area相当于是工作区与历史提交中间的缓存，它代表着是你要提交代码的一个工作状态，它维护的是一个虚拟的树形结构<br><img src="/2016/01/13/git-study-2/1.png" alt="图片1" title="图片1"></li></ul><p>讲述完了git的区域，接下来讲解下git文件的状态，其实git的状态无外乎两种：已跟踪和未跟踪，已跟踪的文件说明的是被纳入版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p><img src="/2016/01/13/git-study-2/2.png" alt="图片2" title="图片2"></p><p>讲解下文件变化周期，比如我们在项目中添加了一个文件a,这时候文件a处于的状态则是Untracked未跟踪状态，当我们git add的时候这时候就会将文件放到暂存区中这时候状态变为Stage，当我们commit这个暂存区的文件后这个文件就变成未修改状态，因为没有进行修改过了相对于版本控制中的文件，当我们修改了a文件后这时候从unmodified变成modified（修改状态），这是再git add的时候就会将修改的文件变成stage，放入暂存区用于等待commit。</p><p>接下来就详细讲解下这些命令：<br>往暂存区里面添加东西使用如下git指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  add</span><br></pre></td></tr></table></figure></p><p>从暂存区提交到历史记录使用如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  commit</span><br></pre></td></tr></table></figure></p><p>查看工作区和暂存区之间的区别，来确保提交时我们所需要的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  status</span><br></pre></td></tr></table></figure></p><p>从暂存区里面删除内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm</span><br></pre></td></tr></table></figure></p><p>工作区内重命名文件或者移动文件，然后再把他们添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  mv</span><br></pre></td></tr></table></figure></p><p>确保工作区内里面不需要的文件不被添加进去添加到暂存区和历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br></pre></td></tr></table></figure></p><h1 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h1><ol><li>新建一个仓库，并且新建一个文件a，将其添加到暂存区。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git  init  git_init</span><br><span class="line">cd  git_init</span><br><span class="line">touch a             //新建a文件</span><br><span class="line">git  add  a         //将a添加到暂存区</span><br></pre></td></tr></table></figure><p>git status会显示我们要提交的内容a文件，这时候a两个文件都是Changes to be committed也就是待commit的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      new file:   a</span><br><span class="line">git  commit  -m  “initial commit”//提交a文件到版本控制中。</span><br></pre></td></tr></table></figure></p><ol start="2"><li>touch b新建文件b，将其放入暂存区，观察git status返回的状态信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch b     //新建文件b</span><br><span class="line">git add b   //将b放入暂存区中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      new file:   b</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑一下a文件，这时候在调用git status</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      modified:   a</span><br><span class="line">      new file:   bb</span><br></pre></td></tr></table></figure><p>这时候a文件是出于修改状态，那么如果我们在进行修改a文件时候，在调用下git status会发生什么奇怪的事呢？let’s  go。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      modified:   a</span><br><span class="line">      new file:   bb</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) </span><br><span class="line">      modified:   a</span><br></pre></td></tr></table></figure></p><p>这时候我们会发现两个modified a，这是为什么呢？但是两个文件分别存在暂存区和非暂存区，实际上暂存区内只保存了git add的版本，而最新修改的一份没有提交到暂存区内还在工作区域中，所以我们会看到两个，如果这时候调用git commit的话就只会讲已经在暂存区的文件存入到版本控制中，而最新修改的那一次记录没有被提交。<br>当然这里还提供了跳过暂存区的方法就是git commit –a –m“注释内容”可以直接跳过暂存区直接提交到记录里面去。 </p><p>将a移除整个项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm  a</span><br></pre></td></tr></table></figure></p><p>清楚缓存中的内容，也就是已经暂存的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm  a  –cached</span><br></pre></td></tr></table></figure></p><p>给文件重命名将a文件名换成c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  mv  a  c</span><br></pre></td></tr></table></figure></p><h1 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a>Git暂存区</h1><p>假设工作区里面有这么一些文件如下图所示：</p><p><img src="/2016/01/13/git-study-2/3.png" alt="图片3" title="图片3"></p><p>在第一次add都还没有进行的时候，暂存区还没有被创建出来，当我们add的时候会创建一个暂存区出来（文件分开add产生两个数据对象），如下图所示：</p><p><img src="/2016/01/13/git-study-2/4.png" alt="图片4" title="图片4"></p><p>.git目录下面多了一个index的文件，那么这个index文件就是我们所说的暂存区的文件，那么每一条索引都是hash值表示以及它对应的文件名。每个索引还包含了他的文件模式权限还有status number来表示他的合并状态、时间戳等。每一个索引都是跟对象库的文件是对应的。比如说file.txt这里对应的是标号1，那么file2.txt对应的就是标号2(上图所示标号)，这个index里面除了维护了索引之外还维护了提前计算好的tree对象的内容，也就是我们的顶层的目录tree以及folder的tree对象内容，当我们提交的时候他可以迅速的根据我们已经计算好的内容生成一个tree对象，然后添加到历史记录里面。</p><p><img src="/2016/01/13/git-study-2/5.png" alt="图片5" title="图片5"></p><p>当我们修改了file2.txt的时候，这时候git add到暂存区时，发现对象库里面新创了一个对象，那么暂存区的这条索引就被指向新对象的索引替换掉。这时候git暂存区又从新计算了下顶层目录tree对象的一个内容。当我们提交的时候我们直接使用已经计算好的内容创建好一个新的tree对象，生成一个commit对象将master分支上面的HEAD指针指向当前commit对象上去。如下图所示：</p><p><img src="/2016/01/13/git-study-2/6.png" alt="图片6" title="图片6"></p><p>这里的标号8指向的就是新生成的commit对象。</p><h1 id="Git本地分支与合并"><a href="#Git本地分支与合并" class="headerlink" title="Git本地分支与合并"></a>Git本地分支与合并</h1><ol><li><p>创建分支git branch</p></li><li><p>给固定的commit做标记 git  tag</p></li><li><p>分支之间进行切换 git  checkout</p></li><li><p>切换分支之前保存本地修改 git  stash</p></li><li><p>合并分支 git  merge</p></li></ol><p>例子创建一个分支名字叫test并切换到当前的分支上去。</p><p><img src="/2016/01/13/git-study-2/7.png" alt="图片7" title="图片7"></p><p>这时候分支的名称不再是master而是改变成为test分支。编辑下a文件用test分支进行提交</p><p><img src="/2016/01/13/git-study-2/8.png" alt="图片8" title="图片8"></p><p>切换到master分支上面我们看一下a的内容</p><p><img src="/2016/01/13/git-study-2/9.png" alt="图片9" title="图片9"></p><p>并没有test分支在a中添加的内容这时候我们切换分支时会使用我们分支上最新的一个提交来还原我们的暂存区和工作区内容，那么可以让我们在不同的分支之间独立的做自己的工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  log  –oneline  –decorate  –graph  –all</span><br></pre></td></tr></table></figure></p><p>我们可以看到提交的记录或提交这些提交的引用</p><p><img src="/2016/01/13/git-study-2/10.png" alt="图片10" title="图片10"></p><p>给第一个提交加一个名称tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  tag  “v0”  f6699b3</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/11.png" alt="图片11" title="图片11"></p><p>在查看下git  log  –oneline  –decorate  –graph  –all</p><p><img src="/2016/01/13/git-study-2/12.png" alt="图片12" title="图片12"></p><p>多了一个tag：v0使用git show v0查看下内容，这是打的tag是一个轻量级的只是一个固定的引用。</p><p><img src="/2016/01/13/git-study-2/13.png" alt="图片13" title="图片13"></p><p>而使用git tag –a的方式进行添加时会是一个tag对象，他有tag的属性，包括提交人时间等信息。</p><p><img src="/2016/01/13/git-study-2/14.png" alt="图片14" title="图片14"></p><p><img src="/2016/01/13/git-study-2/15.png" alt="图片15" title="图片15"></p><p>Tag指向了一个提交commit</p><p>Tag也可以使用checkout进行操作</p><p><img src="/2016/01/13/git-study-2/16.png" alt="图片16" title="图片16"></p><p>但是它当前的没有指向一个分支而是指向了一个commit，这时候就会出现一个问题就是我们切换分支的时候这一部分内容就有可能被遗弃掉，也就是说head引用直接指向了一个commit而不是一个分支名，checkout提供了针对当前commit新建一个分支的方法并切换到当前分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  checkout  -b  “ttt_v0”</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/17.png" alt="图片17" title="图片17"></p><p>接下来切换master分支</p><p><img src="/2016/01/13/git-study-2/18.png" alt="图片18" title="图片18"></p><p>这时候会用的git  stash进行保存工作区，因为我们切换checkout的时候会覆盖掉当前的内容所以我们先将其保存起来。如果想要保存暂存区就可以使用-a来保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git  stash  save  -a   “stash1”</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/19.png" alt="图片19" title="图片19"></p><p>这时候我们来查看下缓存区状态git  status的时候是很干净的如下图：</p><p><img src="/2016/01/13/git-study-2/20.png" alt="图片20" title="图片20"></p><p>下面我们切换到master分之下，在切换会ttt_v0下时我们要还原stash里面的内容</p><p><img src="/2016/01/13/git-study-2/21.png" alt="图片21" title="图片21"></p><p>会有一个stash的缓存内容存在，下面我们来恢复stash里面的内容，并将缓存区内容还原。</p><p>git  stash   pop  –index  stash@{0}   这里的标记红色的表示stash里面的第0个stash</p><p><img src="/2016/01/13/git-study-2/22.png" alt="图片22" title="图片22"></p><p>我们会发现之前修改的a文件已经在暂存区内贮备提交了</p><p>使用git  stash  apply  –index  stash@{0}这种方式时git stash list里面的内容是不会被清理掉的这里–index是恢复暂存区内容</p><p>使用git  stash  drop  stash@{0}清除掉，如果不加stash@{0}引用的话他默认会清楚stash栈最上面的一个。</p><p>清楚多个stash的时候使用git  stash  clear</p><h1 id="查看与对比历史记录"><a href="#查看与对比历史记录" class="headerlink" title="查看与对比历史记录"></a>查看与对比历史记录</h1><ol><li><p>git show</p></li><li><p>git log</p></li><li><p>git diff</p></li></ol><p>输入git  log  –oneline  –decorate  –graph  –all查看完整的历史示意图。</p><p><img src="/2016/01/13/git-study-2/23.png" alt="图片23" title="图片23"></p><p>git  log  -p常用的选项是 -p，用来显示每次提交的内容差异， 你也可以加上 -2 来仅显示最近两次提交：</p><p><img src="/2016/01/13/git-study-2/24.png" alt="图片24" title="图片24"></p><p>我们可以根据查看git  show  f6699b3的信息</p><p><img src="/2016/01/13/git-study-2/25.png" alt="图片25" title="图片25"></p><p>最新的一次提交可以用git  show  master 或者git  show  HEAD，也可以使用git  show  master^表示master分支的第一次提交master^2表示第二次提交</p><p>通常我们会用git diff来回答两个问题：第一个就是当前做了什么还没有提交暂存区？第二个问题就是当前那些文件已经暂存了等待提交？</p><p>git  diff 这个命令是查看当前工作区与暂存区快照的差异，也就是那些还没有暂存起来。</p><p><img src="/2016/01/13/git-study-2/26.png" alt="图片26" title="图片26"></p><p>图中显示的是暂存区和工作区的区别在于a文件被修改了添加了next edit file。请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。</p><p>回顾：</p><p>所谓的分支就是一个commit记录的引用如下图所示：</p><p><img src="/2016/01/13/git-study-2/27.png" alt="图片27" title="图片27"></p><p>在这些分支上工作会产生各自的历史记录（commit记录）所谓的分支切换就是指的Head指针的切换以及暂存区和工作区的一个还原，比如说我们现在当前Head指向的位置处再建两个分支之后他们所指向的commit都是同一个如下图所示：</p><p><img src="/2016/01/13/git-study-2/28.png" alt="图片28" title="图片28"></p><p>分支切换后如下图所示：</p><p><img src="/2016/01/13/git-study-2/29.png" alt="图片29" title="图片29"></p><p>而tag指向了一个固定的commit记录，如下图所示：</p><p><img src="/2016/01/13/git-study-2/30.png" alt="图片30" title="图片30"></p><p>分为两种一种是轻量级的一种是标签对象，主要区别就是轻量级的tag只是一个固定的连接，但是标签对象就是创建标签的时候会产生一个标签对象，这个标签对象存储在.git/object目录里面，tag对象里面包括对数据对象的指向，以及创建时间数据对象类型和创建人等信息。</p><p><img src="/2016/01/13/git-study-2/31.png" alt="图片31" title="图片31"></p><p>举个例子来说明一下分支切换以及合并：</p><p>开始的状态是这样的，我们提交了三次commit后的示意图如下：</p><p><img src="/2016/01/13/git-study-2/32.png" alt="图片32" title="图片32"></p><p>当我们使用了git  branch test的时候，将会在当前位置处新建一个分支，分支的名称叫test，但是分支并没有切换依然是master分支（Head的指向）如下图所示：</p><p><img src="/2016/01/13/git-study-2/33.png" alt="图片33" title="图片33"></p><p>我们在master分支上面工作会产生master分支上面的commit记录如下图所示：</p><p><img src="/2016/01/13/git-study-2/34.png" alt="图片34" title="图片34"></p><p>这个时候我们是用git  checkout  test的时候HEAD指针就会指向test，并且还原暂存区和工作区内容。如下图所示：</p><p><img src="/2016/01/13/git-study-2/35.png" alt="图片35" title="图片35"></p><p>继续在test分支上面进行工作，会产生test对应分支上面的commit记录</p><p><img src="/2016/01/13/git-study-2/36.png" alt="图片36" title="图片36"></p><p>我们来说一下合并，合并分为两种一种是fast-farword  merge也就是说test所指向的commit记录他其实是master所指向的commit所衍生出来的如下图所示：</p><p><img src="/2016/01/13/git-study-2/37.png" alt="图片37" title="图片37"></p><p>蓝色部分是master分支，红色部分是master分支所衍生出来的分支。这时候我们在master分支上面进行合并git  merge  test不会产生新的commit记录出来，master分支指向test分支所指向的commit记录上去，然后把工作区和暂存区还原成了test的暂存区和工作区内容。如下图所示：</p><p><img src="/2016/01/13/git-study-2/38.png" alt="图片38" title="图片38"></p><p>另外一种就是non-fast-farword  merge也就是我们的三方合并。</p><p><img src="/2016/01/13/git-study-2/39.png" alt="图片39" title="图片39"></p><p>我们可以看到master指向的commit和test只想的commit有一个共同的父节点就是70e4d8这个节点。Master指向的commit和test指向的commit并没有一个衍生的关系，这时候我们在master分支上面git merge test，会生成一个新的commit来承载两个分支的历史内容</p><p><img src="/2016/01/13/git-study-2/40.png" alt="图片40" title="图片40"></p><p>五、结束语<br>这篇文章非一天写完的我也是在学习的过程中总结，以及参考大婶们写的文章加自己的理解写成的，如果这里有些错的或者有雷同的请各位大神指点一二。小丁谢过，写一篇文章确实不容易，能支持的就支持下不能支持的就当没看过这篇文章就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-基础配置</title>
      <link href="/2016/01/13/git-config/"/>
      <url>/2016/01/13/git-config/</url>
      
        <content type="html"><![CDATA[<h1 id="git的简单配置"><a href="#git的简单配置" class="headerlink" title="git的简单配置"></a>git的简单配置</h1><p>配置提交代码的信息，例如是谁提交的代码之类的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  –global user.name BattleHeaert 这里是设置提交代码的人的名称</span><br><span class="line">git config  –global user.email github@126.com 这里是设置提交代码的人的邮箱</span><br></pre></td></tr></table></figure></p><p>查看当前的用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  user.name</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config   –get  user.name</span><br></pre></td></tr></table></figure></p><p>这时候会显示BattleHeart这个用户名，但是如果我们再添加一个用户的名称的时候这时候就会显示最后一个添加的用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –add  user.name  BH</span><br></pre></td></tr></table></figure></p><p>当我们再次使用git  config  user.name时这时候显得是就是BH如下图所示<br><img src="/2016/01/13/git-config/1.png" alt="图片1" title="图片1"><br>我们可以使用如下指令来列出基本的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –list</span><br></pre></td></tr></table></figure></p><p>基本信息如下图所示（这里其实是有两个user.name的结果，只不过使用的是最后一个值）<br><img src="/2016/01/13/git-config/2.png" alt="图片2" title="图片1"><br>那么我们来取消一个user.name使用以下指令来进行操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –unset  user.name  BH</span><br></pre></td></tr></table></figure></p><p>这里user.name后面必须添加上取消的name的名称否则它是找不到你要取消那个名称的，会提示警告user.name有多个值。</p><p>如果只有一个键值对的时候就可以不用带后面name的名称直接使用如下方式即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –unset  user.name</span><br></pre></td></tr></table></figure></p><p>修改一个键值对的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  user.name  BH</span><br></pre></td></tr></table></figure></p><p>修改后的结果如下图<br><img src="/2016/01/13/git-config/3.png" alt="图片3" title="图片3">  </p><h1 id="给git子命令的参数起别名"><a href="#给git子命令的参数起别名" class="headerlink" title="给git子命令的参数起别名"></a>给git子命令的参数起别名</h1><p>例如给checkout起别名叫co<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  alias.co  checkout</span><br></pre></td></tr></table></figure></p><p>设置带参数的命令别名给log  –online起别名如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  alias.lol  “log  –online”</span><br></pre></td></tr></table></figure></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>献给所有新学Git的系列，这是文章的开篇，后续会陆陆续续将文章发布出来。如果文章用有不正确的地方请给我大神指点，小丁在此谢过了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
