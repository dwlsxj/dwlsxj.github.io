<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="BattleHeart" />



<meta name="description" content="ArrayBlockingQueue是基于数组实现的共享通道，为什么说是共享通道，假说线程A希望给线程B发一个消息，用什么方式来告知线程B是比较合适的呢？可以使用BlockingQueue来实现。">
<meta name="keywords" content="并发编程,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="SynchronousQueue原理详解-公平模式">
<meta property="og:url" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/index.html">
<meta property="og:site_name" content="BattleHeart">
<meta property="og:description" content="ArrayBlockingQueue是基于数组实现的共享通道，为什么说是共享通道，假说线程A希望给线程B发一个消息，用什么方式来告知线程B是比较合适的呢？可以使用BlockingQueue来实现。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/24.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/25.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/26.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/27.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/16.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/17.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/18.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/19.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/20.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/21.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/22.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/23.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/1.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/2.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/3.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/4.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/5.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/6.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/7.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/8.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/9.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/10.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/11.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/12.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/13.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/14.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/15.png">
<meta property="og:updated_time" content="2019-05-11T03:22:50.954Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SynchronousQueue原理详解-公平模式">
<meta name="twitter:description" content="ArrayBlockingQueue是基于数组实现的共享通道，为什么说是共享通道，假说线程A希望给线程B发一个消息，用什么方式来告知线程B是比较合适的呢？可以使用BlockingQueue来实现。">
<meta name="twitter:image" content="https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/24.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="BattleHeart" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
    <link href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/orange/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>SynchronousQueue原理详解-公平模式 | BattleHeart</title>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdnjs.cloudflare.com/ajax/libs/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/jquery-ui.min.js", "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">BattleHeart</a></h1>
        </hgroup>

        
        <p class="header-subtitle">个人博客</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="dwlsxj:@126.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dwlsxj" title="GitHub"></a>
                            
                                <a class="fa 博客园" href="https://www.cnblogs.com/dwlsxj/" title="博客园"></a>
                            
                                <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=31908845" title="网易云音乐"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELK/">ELK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.cnblogs.com/dwlsxj/">BalleHeart</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.80iter.com/">80ITer</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于后端开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">BattleHeart</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">BattleHeart</a></h1>
            </hgroup>
            
            <p class="header-subtitle">个人博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="dwlsxj:@126.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dwlsxj" title="GitHub"></a>
                            
                                <a class="fa 博客园" target="_blank" href="https://www.cnblogs.com/dwlsxj/" title="博客园"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=31908845" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-synchronousqueue-principle-fair-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/04/synchronousqueue-principle-fair-pattern/" class="article-date">
      <time datetime="2019-05-04T08:44:16.000Z" itemprop="datePublished">2019-05-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SynchronousQueue原理详解-公平模式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/个人技术/">个人技术</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="SynchronousQueue原理详解-公平模式"><a href="#SynchronousQueue原理详解-公平模式" class="headerlink" title="SynchronousQueue原理详解-公平模式"></a>SynchronousQueue原理详解-公平模式</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>SynchronousQueue是一个双栈双队列算法，无空间的队列或栈，任何一个对SynchronousQueue写需要等到一个对SynchronousQueue的读操作，反之亦然。一个读操作需要等待一个写操作，相当于是交换通道，提供者和消费者是需要组队完成工作，缺少一个将会阻塞线程，知道等到配对为止。</p>
<p>SynchronousQueue是一个队列和栈算法实现，在SynchronousQueue中双队列FIFO提供公平模式，而双栈LIFO提供的则是非公平模式。</p>
<p>对于SynchronousQueue来说，他的put方法和take方法都被抽象成统一方法来进行操作，通过抽象出内部类Transferer，来实现不同的操作。</p>
<blockquote>
<p>注意事项：本文分析主要是针对jdk1.8的版本进行分析，下面的代码中的线程执行顺序可能并不能完全保证顺序性，执行时间比较短，所以暂且认定有序执行。</p>
<p>约定：图片中以Reference-开头的代表对象的引用地址，通过箭头方式进行引用对象。</p>
</blockquote>
<p>Transferer.transfer方法主要介绍如下所示：        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行put和take方法.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 非空时,表示这个元素要传递给消费者（提供者-put）;</span></span><br><span class="line"><span class="comment">     *          为空时, 则表示当前操作要请求消费一个数据（消费者-take）。</span></span><br><span class="line"><span class="comment">     *          offered by producer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed 决定是否存在timeout时间。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos 超时时长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回非空, 代表数据已经被消费或者正常提供; 如果为空,</span></span><br><span class="line"><span class="comment">     *         则表示由于超时或中断导致失败。可通过Thread.interrupted来检查是那种。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下SynchronousQueue的字段信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** CPU数量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋次数，如果transfer指定了timeout时间，则使用maxTimeSpins,如果CPU数量小于2则自旋次数为0，否则为32</span></span><br><span class="line"><span class="comment"> * 此值为经验值，不随CPU数量增加而变化，这里只是个常量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋次数，如果没有指定时间设置，则使用maxUntimedSpins。如果NCPUS数量大于等于2则设定为为32*16，否则为0；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NCPUS：代表CPU的数量</li>
<li>maxTimedSpins：自旋次数，如果transfer指定了timeout时间，则使用maxTimeSpins,如果CPU数量小于2则自旋次数为0，否则为32，此值为经验值，不随CPU数量增加而变化，这里只是个常量。</li>
<li>maxUntimedSpins：自旋次数，如果没有指定时间设置，则使用maxUntimedSpins。如果NCPUS数量大于等于2则设定为为32*16，否则为0；</li>
<li>spinForTimeoutThreshold：为了防止自定义的时间限过长，而设置的，如果设置的时间限长于这个值则取这个spinForTimeoutThreshold 为时间限。这是为了优化而考虑的。这个的单位为纳秒。</li>
</ul>
<h2 id="公平模式-TransferQueue"><a href="#公平模式-TransferQueue" class="headerlink" title="公平模式-TransferQueue"></a>公平模式-TransferQueue</h2><p>TransferQueue内部是如何进行工作的，这里先大致讲解下，队列采用了互补模式进行等待，QNode中有一个字段是isData，如果模式相同或空队列时进行等待操作，互补的情况下就进行消费操作。</p>
<p>入队操作相同模式</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/24.png" alt=""></p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/25.png" alt=""></p>
<p>不同模式时进行出队列操作：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/26.png" alt=""></p>
<p>这时候来了一个isData=false的互补模式，队列就会变成如下状态：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/27.png" alt=""></p>
<p>TransferQueue继承自Transferer抽象类，并且实现了transfer方法，它主要包含以下内容:</p>
<h3 id="QNode"><a href="#QNode" class="headerlink" title="QNode"></a>QNode</h3><p>代表队列中的节点元素，它内部包含以下字段信息：</p>
<ol>
<li>字段信息描述</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>下一个节点</td>
<td>QNode</td>
</tr>
<tr>
<td>item</td>
<td>元素信息</td>
<td>Object</td>
</tr>
<tr>
<td>waiter</td>
<td>当前等待的线程</td>
<td>Thread</td>
</tr>
<tr>
<td>isData</td>
<td>是否是数据</td>
<td>boolean</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>方法信息描述</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>casNext</td>
<td>替换当前节点的next节点</td>
</tr>
<tr>
<td>casItem</td>
<td>替换当前节点的item数据</td>
</tr>
<tr>
<td>tryCancel</td>
<td>取消当前操作，将当前item赋值为this(当前QNode节点)</td>
</tr>
<tr>
<td>isCancelled</td>
<td>如果item是this(当前QNode节点)的话就返回true，反之返回false</td>
</tr>
<tr>
<td>isOffList</td>
<td>如果已知此节点离队列，判断next节点是不是为this，则返回true，因为由于* advanceHead操作而忘记了其下一个指针。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">     * two actions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">     *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">     *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">     *    call is of complementary mode, try to fulfill by CAS'ing</span></span><br><span class="line"><span class="comment">     *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">     *    returning matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">     * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">     * threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">     * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">     * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">     * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">     * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">     * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">     * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// 分为两种状态1.有数据=true 2.无数据=false</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 循环内容</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 尾部节点。</span></span><br><span class="line">        QNode t = tail;</span><br><span class="line">        <span class="comment">// 头部节点。</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        <span class="comment">// 判断头部和尾部如果有一个为null则自旋转。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// 还未进行初始化的值。</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// 自旋</span></span><br><span class="line">        <span class="comment">// 头结点和尾节点相同或者尾节点的模式和当前节点模式相同。</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 空或同模式。</span></span><br><span class="line">            <span class="comment">// tn为尾节点的下一个节点信息。</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            <span class="comment">// 这里我认为是阅读不一致，原因是当前线程还没有阻塞的时候其他线程已经修改了尾节点tail会导致当前线程的tail节点不一致。</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 这里如果指定timed判断时间小于等于0直接返回。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 判断新增节点是否为null,为null直接构建新节点。</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 如果next节点不为null说明已经有其他线程进行tail操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将t节点替换为s节点</span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">            <span class="comment">// 等待有消费者消费线程。</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 如果返回的x，指的是s.item,如果s.item指向自己的话清除操作。</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有取消联系</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点替换头结点</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// 取消item值，这里是take方法时会进行item赋值为this</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                <span class="comment">// 将等待线程设置为null</span></span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            <span class="comment">// 获取头结点下一个节点</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="comment">// 如果当前线程尾节点和全局尾节点不一致,重新开始</span></span><br><span class="line">            <span class="comment">// 头结点的next节点为空，代表无下一个节点，则重新开始，</span></span><br><span class="line">            <span class="comment">// 当前线程头结点和全局头结点不相等，则重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下awaitFulfill方法内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果指定了timed则为System.nanoTime() + nanos，反之为0。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 获取当前线程。</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果头节点下一个节点是当前s节点(以防止其他线程已经修改了head节点)</span></span><br><span class="line">    <span class="comment">// 则运算(timed ? maxTimedSpins : maxUntimedSpins)，否则直接返回。</span></span><br><span class="line">    <span class="comment">// 指定了timed则使用maxTimedSpins，反之使用maxUntimedSpins</span></span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经被中断。</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">//尝试取消，将当前节点的item修改为当前节点(this)。</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="comment">// 获取当前节点内容。</span></span><br><span class="line">        Object x = s.item;</span><br><span class="line">        <span class="comment">// 判断当前值和节点值不相同是返回，因为弹出时会将item值赋值为null。</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先先判断有没有被中断，如果被中断则取消本次操作，将当前节点的item内容赋值为当前节点。</li>
<li>判断当前节点和节点值不相同是返回</li>
<li>将当前线程赋值给当前节点</li>
<li>自旋，如果指定了timed则使用<code>LockSupport.parkNanos(this, nanos);</code>，如果没有指定则使用<code>LockSupport.park(this);</code>。</li>
<li>中断相应是在下次才能被执行。</li>
</ol>
<p>通过上面源码分析我们这里做出简单的示例代码演示一下put操作和take操作是如何进行运作的，首先看一下示例代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue进行put和take操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先上来之后进行的是两次take操作，然后再put操作，默认队列上来会进行初始化，初始化的内容如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化后队列的状态如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/16.png" alt="16"></p>
<p>当线程1执行put操作时，来分析下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QNode t = tail;</span><br><span class="line">QNode h = head;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>首先执行局部变量t代表队尾指针，h代表队头指针，判断队头和队尾不为空则进行下面的操作，接下来是if…else语句这里是分水岭，当相同模式操作的时候执行if语句，当进行不同模式操作时执行的是else语句，程序是如何控制这样的操作的呢？接下来我们慢慢分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// 队列为空或者模式相同时进行if语句</span></span><br><span class="line">    QNode tn = t.next;</span><br><span class="line">    <span class="keyword">if</span> (t != tail)                  <span class="comment">// 判断t是否是队尾，不是则重新循环。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;               <span class="comment">// tn是队尾的下个节点，如果tn有内容则将队尾更换为tn，并且重新循环操作。</span></span><br><span class="line">        advanceTail(t, tn);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// 如果指定了timed并且延时时间用尽则直接返回空，这里操作主要是offer操作时，因为队列无存储空间的当offer时不允许插入。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)                  <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">        s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line">    <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    advanceTail(t, s);              <span class="comment">// 队尾移动</span></span><br><span class="line">    Object x = awaitFulfill(s, e, timed, nanos);	<span class="comment">//自旋并且设置线程。</span></span><br><span class="line">    <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">        clean(t, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">        advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">            s.item = s;</span><br><span class="line">        s.waiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是if语句中的内容，进入到if语句中的判断是如果头结点和尾节点相等代表队列为空，并没有元素所有要进行插入队列的操作，或者是队尾的节点的isData标志和当前操作的节点的类型一样时，会进行入队操作，isData标识当前元素是否是数据，如果为true代表是数据，如果为false则代表不是数据，换句话说只有模式相同的时候才会往队列中存放，如果不是模式相同的时候则代表互补模式，就不走if语句了，而是走了else语句，上面代码中做有注释讲解，下面看一下这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)                  <span class="comment">// 这里是新节点生成。</span></span><br><span class="line">    s = <span class="keyword">new</span> QNode(e, isData);</span><br><span class="line"><span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))        <span class="comment">// 将尾节点的next节点修改为当前节点。</span></span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>当执行上面代码后，队列的情况如下图所示：(这里视为<code>插入第一个元素</code>图，方便下面的引用)</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/17.png" alt="17"></p>
<p>接下来执行这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advanceTail(t, s);              <span class="comment">// 队尾移动</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/18.png" alt="18"></p>
<p>修改了tail节点后，这时候就需要进行自旋操作，并且设置QNode的waiter等待线程，并且将线程等待，等到唤醒线程进行唤醒操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);	<span class="comment">//自旋并且设置线程。</span></span><br></pre></td></tr></table></figure>
<p>方法内部分析局部内容，上面已经全部内容的分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">    --spins;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">    s.waiter = w;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br></pre></td></tr></table></figure>
<p>如果自旋时间spins还有则进行循环递减操作，接下来判断如果当前节点的waiter是空则价格当前线程赋值给waiter，上图中显然是为空的所以会把当前线程进行赋值给我waiter，接下来就是等待操作了。</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/19.png" alt="19"></p>
<p>上面线程则处于等待状态，接下来是线程二进行操作，这里不进行重复进行，插入第二个元素队列的状况，此时线程二也处于等待状态。</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/20.png" alt="20"></p>
<p>上面的主要是put了两次操作后队列的情况，接下来分析一下take操作时又是如何进行操作的，当take操作时，isData为false，而队尾的isData为true两个不相等，所以不会进入到if语句，而是进入到了else语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 互补模式</span></span><br><span class="line">    QNode m = h.next;               <span class="comment">// 获取头结点的下一个节点，进行互补操作。</span></span><br><span class="line">    <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)</span><br><span class="line">        <span class="keyword">continue</span>;                   <span class="comment">// 这里就是为了防止阅读不一致的问题</span></span><br><span class="line"></span><br><span class="line">    Object x = m.item;</span><br><span class="line">    <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// 如果x=null说明已经被读取了。</span></span><br><span class="line">        x == m ||                   <span class="comment">// x节点和m节点相等说明被中断操作，被取消操作了。</span></span><br><span class="line">        !m.casItem(x, e)) &#123;         <span class="comment">// 这里是将item值设置为null</span></span><br><span class="line">        advanceHead(h, m);          <span class="comment">// 移动头结点到头结点的下一个节点</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">    LockSupport.unpark(m.waiter);</span><br><span class="line">    <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取头结点的下一个节点用于互补操作，也就是take操作，接下来进行阅读不一致的判断，防止其他线程进行了阅读操作，接下来获取需要弹出内容x=1，首先进行判断节点内容是不是已经被消费了，节点内容为null时则代表被消费了，接下来判断节点的item值是不是和本身相等如果相等话说明节点被取消了或者被中断了，然后移动头结点到下一个节点上，然后将<code>refenrence-715</code>的item值修改为null，<code>至于为什么修改为null这里留下一个悬念，这里还是比较重要的，大家看到这里的时候需要注意下</code>，显然这些都不会成立，所以if语句中内容不会被执行，接下来的队列的状态是是这个样子的：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/21.png" alt="21"></p>
<p>OK，接下来就开始移动队头head了，将head移动到m节点上，执行代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advanceHead(h, m);</span><br></pre></td></tr></table></figure>
<p>此时队列的状态是这个样子的：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/22.png" alt="22"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.unpark(m.waiter);</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br></pre></td></tr></table></figure>
<p>接下来将执行唤醒被等待的线程，也就是thread-0，然后返回获取item值1，take方法结束，但是这里并没有结束，因为唤醒了put的线程，此时会切换到put方法中，这时候线程唤醒后会执行<code>awaitFulfill</code>方法，此时循环时，有与item值修改为null则直接返回内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object x = s.item;</span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
<p>这里的代码我们可以对照<code>插入第一个元素</code>图，s节点也就是当前m节点，获取值得时候已经修改为null，但是当时插入的值时1，所以两个不想等了，则直接返回null值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">    advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">        s.item = s;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br></pre></td></tr></table></figure>
<p>又返回到了transfer方法的if语句中，此时x和s并不相等所以不用进行clean操作，首先判断s节点是否已经离队了，显然并没有进行离队操作，<code>advanceHead(t, s);</code>操作不会被执行因为上面已近将头节点修改了，但是第一次插入的时候头结点还是<code>reference-716</code>，此时已经是<code>reference-715</code>,而t节点的引用地址是<code>reference-716</code>，所以不会操作，接下来就是将waiter设置为null，也就是忘记掉等待的线程。</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/23.png" alt="22"></p>
<p>分析了正常的take和put操作，接下来分析下中断操作，由于中断相应后，会被执行<code>if(w.isInterrupted())</code>这段代码，它会执行<code>s.tryCancel(e)</code>方法，这个方法的作用的是将QNode节点的item节点赋值为当前QNode，这时候x和e值就不相等了（<code>if (x != e)</code>），x的值是s.item，则为当前QNode，而e的值是用户指定的值，这时候返回x(s.item)。返回到函数调用地方<code>transfer</code>中，这时候要执行下面语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到clean方法执行清理当前节点，下面是方法clean代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets rid of cancelled node s with original predecessor pred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At any given time, exactly one node on list cannot be</span></span><br><span class="line"><span class="comment">     * deleted -- the last inserted node. To accommodate this,</span></span><br><span class="line"><span class="comment">     * if we cannot delete s, we save its predecessor as</span></span><br><span class="line"><span class="comment">     * "cleanMe", deleting the previously saved version</span></span><br><span class="line"><span class="comment">     * first. At least one of node s or the node previously</span></span><br><span class="line"><span class="comment">     * saved can always be deleted, so this always terminates.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (pred.next == s) &#123; <span class="comment">// Return early if already unlinked</span></span><br><span class="line">        QNode h = head;</span><br><span class="line">        QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line">        <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">            advanceHead(h, hn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line">        <span class="keyword">if</span> (t == h)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="comment">// 判断现在的t是不是末尾节点，可能其他线程插入了内容导致不是最后的节点。</span></span><br><span class="line">        <span class="keyword">if</span> (t != tail)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果不是最后节点的话将其现在t.next节点作为tail尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advanceTail(t, tn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点不是尾节点进入到这里面。</span></span><br><span class="line">        <span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">            <span class="comment">// 获取当前节点（被取消的节点）的下一个节点。</span></span><br><span class="line">            QNode sn = s.next;</span><br><span class="line">            <span class="comment">// 修改上一个节点的next(下一个)元素为下下个节点。</span></span><br><span class="line">            <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                <span class="comment">//返回。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        QNode dp = cleanMe;</span><br><span class="line">        <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// 尝试清除上一个标记为清除的节点。</span></span><br><span class="line">            QNode d = dp.next;	<span class="comment">//1.获取要被清除的节点</span></span><br><span class="line">            QNode dn;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// 被清除节点不为空</span></span><br><span class="line">                d == dp ||                 <span class="comment">// 被清除节点已经离队</span></span><br><span class="line">                !d.isCancelled() ||        <span class="comment">// 被清除节点是标记为Cancel状态的。</span></span><br><span class="line">                (d != t &amp;&amp;                 <span class="comment">// 被清除节点不是尾节点</span></span><br><span class="line">                 (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">// 被清除节点下一个节点不为null</span></span><br><span class="line">                 dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">                 dp.casNext(d, dn)))       <span class="comment">// 将被清除的节点的前一个节点的下一个节点修改为被清除节点的下一个节点。</span></span><br><span class="line">                casCleanMe(dp, <span class="keyword">null</span>);      <span class="comment">// 清空cleanMe节点。</span></span><br><span class="line">            <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred)) <span class="comment">// 这里将上一个节点标记为被清除操作，但是其实要操作的是下一个节点。</span></span><br><span class="line">            <span class="keyword">return</span>;          <span class="comment">// Postpone cleaning s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果节点中取消的头结点的下一个节点，只需要移动当前head节点到下一个节点即可。</li>
<li>如果取消的是中间的节点，则将当前节点next节点修改为下下个节点。</li>
<li>如果修改为末尾的节点，则将当前节点放入到QNode的clearMe中，等待有内容进来之后下一次进行清除操作。</li>
</ol>
<p><strong>实例一</strong>：清除头结点下一个节点，下面是实例代码进行讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除头结点的下一个节点实例代码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">      	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子说明我们启动了两个线程，分别向SynchronousQueue队列中添加了元素1和元素2，添加成功之后的，让主线程休眠一会，然后将第一个线程进行中断操作，添加两个元素后节点所处在的状态为下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/1.png" alt="1"></p>
<p>当我们调用<code>thread1.interrupt</code>时，此时线程1等待的消费操作将被终止，会相应上面<code>awaitFulfill</code>方法，该方法会运行下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">    <span class="comment">//尝试取消，将当前节点的item修改为当前节点(this)。</span></span><br><span class="line">    s.tryCancel(e);</span><br><span class="line"><span class="comment">// 获取当前节点内容。</span></span><br><span class="line">Object x = s.item;</span><br><span class="line"><span class="comment">// 判断当前值和节点值不相同是返回，因为弹出时会将item值赋值为null。</span></span><br><span class="line"><span class="keyword">if</span> (x != e)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>
<p>首先上来现将s节点(上图中的Reference-715引用对象)的item节点设置为当前节点引用(Reference-715引用对象)，所以s节点和e=1不相等则直接返回，此时节点的状态变化如下所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/2.png" alt="2"></p>
<p>退出<code>awaitFulfill</code>并且返回的是s节点内容（实际上返回的就是s节点），接下来返回到调用<code>awaitFulfill</code>的方法<code>transfer</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line"><span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// 是否是被取消了</span></span><br><span class="line">    clean(t, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断的事x节点和s节点是否相等，上面我们也说了明显是相等的所以这里会进入到clean方法中，<code>clean(QNode pred, QNode s)</code>clean方法一个是前节点，一个是当前被取消的节点，也就是当前s节点的前节点是head节点，接下来我们一步一步的分析代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.waiter = <span class="keyword">null</span>; <span class="comment">// 删除等待的线程。</span></span><br></pre></td></tr></table></figure>
<p>进入到方法体之后首先先进行的是将当前节点的等待线程删除，如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/3.png" alt="3"></p>
<p>接下来进入while循环，循环内容时<code>pred.next == s</code>如果不是则表示已经移除了节点，反之还在队列中，则进行下面的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next;   <span class="comment">// 如果取消的是第一个节点则进入下面语句</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先h节点为head节点，hn为头结点的下一个节点，在进行判断头结点的下一个节点不为空并且头结点下一个节点是被中断的节点(取消的节点)，则进入到if语句中，if语句其实也很简单就是将头结点修改为头结点的下一个节点(s节点，别取消节点，并且将前节点的next节点修改为自己，也就是移除了之前的节点，我们看下advanceHead方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, h, nh))</span><br><span class="line">        h.next = h; <span class="comment">// forget old next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先上来先进行CAS移动头结点，再讲原来头结点h的next节点修改为自己(h)，为什么这样做呢？因为上面进行<code>advanceHead</code>之后并没有退出循环，是进行continue操作，也就是它并没有跳出while循环，他还会循环一次prev.next此时已经不能等于s所以退出循环，如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/4.png" alt="5"></p>
<p><strong>实例二</strong>：清除中间的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue实例二，清除中间的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">        <span class="comment">//休眠一会。</span></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面例子，首先先进行put操作三次，也就是入队3条数据，分别是整型值1，整型值2，整型值3，然后将当前线程休眠一下，对中间线程进行中断操作，通过让主线程休眠一会保证线程执行顺序性(当然上面线程不一定能保证执行顺序，因为put操作一下子就执行完了所以这点时间是可以的)，此时队列所处的状态来看一下下图：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/5.png" alt="5"></p>
<p>当休眠一会之后，进入到threa2进行中断操作，目前上图中表示<code>Reference-723</code>被中断操作，此时也会进入到<code>awaitFulfill</code>方法中，将<code>Reference-723</code>的item节点修改为当前节点，如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/6.png" alt="6"></p>
<p>进入到clear方法中此时的prev节点为<code>Reference-715</code>，s节点是被清除节点，还是首先进入clear方法中先将waiter设置为null，取消当前线程内容，如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/7.png" alt="7"></p>
<p>接下来进入到循环中，进行下面处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QNode h = head;</span><br><span class="line">QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line"><span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;</span><br><span class="line">    advanceHead(h, hn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line"><span class="keyword">if</span> (t == h)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">QNode tn = t.next;</span><br><span class="line"><span class="keyword">if</span> (t != tail)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advanceTail(t, tn);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个if语句已经分析过了所以说这里不会进入到里面去，接下来是进行尾节点t是否是等于head节点如果相等则代表没有元素，在判断当前方法的t尾节点是不是真正的尾节点tail如果不是则进行修改尾节点，先来看一下现在的状态：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/8.png" alt="8"></p>
<p><code>tn != null</code>判断如果tn不是尾节点，则将tn作为尾节点处理，如果处理之后还不是尾节点还会进行处理直到tail是尾节点未知，我们现在这个是尾节点所以跳过这段代码。<code>s != t</code>通过上图可以看到s节点是被清除节点，并不是尾节点所以进入到循环中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s != t) &#123;        <span class="comment">// If not tail, try to unsplice</span></span><br><span class="line">    QNode sn = s.next;</span><br><span class="line">    <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取的s节点的下一个节点，上图中表示<code>Reference-725</code>节点，判断sn是都等于当前节点显然这一条不成立，pred节点为<code>Reference-715</code>节点，将715节点的next节点变成<code>Reference-725</code>节点，这里就将原来的节点清理出去了，现在的状态如下所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/9.png" alt="9"></p>
<p><strong>实例三</strong>：删除的节点是尾节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SynchronousQueue实例三，删除的节点为尾节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(<span class="keyword">true</span>);</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread3.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子主要说明一个问题就是删除的节点如果是末尾节点的话，<code>clear</code>方法又是如何处理的，首先启动了三个线程其中主线程休眠了一会，为了能让插入的顺序保持线程1，线程2，线程3这样子，启动第二个线程后，又将第二个线程中断，这是第二个线程插入的节点为尾节点，然后再启动第三个节点插入值，再中断了第三个节点末尾节点，说一下为啥这样操作，因为当清除尾节点时，并不是直接移除当前节点，而是将被清除的节点的前节点设置到QNode的CleanMe中，等待下次clear方法时进行清除上次保存在CleanMe的节点，然后再处理当前被中断节点，将新的被清理的节点prev设置为cleanMe当中，等待下次进行处理，接下来一步一步分析，首先我们先来看一下第二个线程启动后节点的状态。</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/10.png" alt="10"></p>
<p>此时运行<code>thread2.interrupt();</code>将第二个线程中断，这时候会进入到clear方法中，前面的代码都不会被返回，会执行下面的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QNode dp = cleanMe;</span><br><span class="line"><span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123;    <span class="comment">// Try unlinking previous cancelled node</span></span><br><span class="line">    QNode d = dp.next;</span><br><span class="line">    QNode dn;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">        d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">        !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">        (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">         (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">         dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">         dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">        casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (dp == pred)</span><br><span class="line">        <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>首先获得TransferQueue当中cleanMe节点，此时获取的为null，当判断dp!=null时就会被跳过，直接执行</p>
<p><code>casCleanMe(null, pred)</code>此时pred传入的值时t节点指向的内容，也就是当前节点的上一个节点，它会被标记为清除操作节点(其实并不清楚它而是清除它下一个节点，也就是说item=this的节点)，此时看一下节点状态为下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/11.png" alt="11"></p>
<p>接下来第三个线程启动了这时候又往队列中添加了元素3，此时队列的状况如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/12.png" alt="12"></p>
<p>此时thread3也被中断操作了，这时候还是运行上面的代码，但是这次不同的点在于cleanMe已经不是空值，是有内容的，首先获取的是cleanMe的下一个节点（d），然我来把变量标记在图上然后看起来好分析一些，如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/13.png" alt="13"></p>
<p>dp表示d节点的前一个pred节点，dn表示d节点的next节点，主要逻辑在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">    d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">    !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">    (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">     (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">     dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">     dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line">    casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (dp == pred)</span><br><span class="line">    <span class="keyword">return</span>;      <span class="comment">// s</span></span><br></pre></td></tr></table></figure>
<p>首先判断d节点是不是为null，如果d节点为null代表已经清除掉了，如果cleanMe节点的下一个节点和自己相等，说明需要清除的节点已经离队了，判断下个节点是不是需要被清除的节点，目前看d节点是被清除的节点，然后就将被清除的节点的下一个节点赋值给dn并且判断d节点是不是末尾节点，如果不是末尾节点则进行<code>dp.casNext</code>方法，这个地方是关键点，它将被清除节点d的前节点的next节点修改为被清除节点d的后面节点dn，然后调用caseCleanMe将TransferQueue中的cleanMe节点清空，此时节点的内容如下所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/14.png" alt="14"></p>
<p>可以看出将上一次标记为清除的节点清除了队列中，清除完了就完事儿？那这次的怎么弄呢?因为现在运行的是thread3的中断程序，所以上面并没有退出，而是再次进入循环，循环之后发现dp为null则会运行<code>casCleanMe(null, pred)</code>，此时当前节点s的前一个节点已经被清除队列，但是并不影响后续的清除操作，因为前节点的next节点还在维护中，也是前节点的next指向还是<code>reference-725</code>,如下图所示：</p>
<p><img src="/2019/05/04/synchronousqueue-principle-fair-pattern/15.png" alt="15"></p>
<p>就此分析完毕如果有不正确的地方请指正。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/05/04/synchronousqueue-principle-fair-pattern/">SynchronousQueue原理详解-公平模式</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">BattleHeart</a></p>
        <p><span>发布时间:</span>2019-05-04, 16:44:16</p>
        <p><span>最后更新:</span>2019-05-11, 11:22:50</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/05/04/synchronousqueue-principle-fair-pattern/" title="SynchronousQueue原理详解-公平模式">https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/</a>
            <span class="copy-path" data-clipboard-text="原文: https://www.battleheart.cn/2019/05/04/synchronousqueue-principle-fair-pattern/　　作者: BattleHeart" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/05/18/synchronousqueue-principle-unfair-pattern/">
                    SynchronousQueue原理详解-非公平模式
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/04/11/stack-working-principle/">
                    系统栈的工作原理
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SynchronousQueue原理详解-公平模式"><span class="toc-number">1.</span> <span class="toc-text">SynchronousQueue原理详解-公平模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、介绍"><span class="toc-number">1.1.</span> <span class="toc-text">一、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公平模式-TransferQueue"><span class="toc-number">1.2.</span> <span class="toc-text">公平模式-TransferQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QNode"><span class="toc-number">1.2.1.</span> <span class="toc-text">QNode</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"SynchronousQueue原理详解-公平模式　| BattleHeart　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/05/18/synchronousqueue-principle-unfair-pattern/" title="上一篇: SynchronousQueue原理详解-非公平模式">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/04/11/stack-working-principle/" title="下一篇: 系统栈的工作原理">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/18/synchronousqueue-principle-unfair-pattern/">SynchronousQueue原理详解-非公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/synchronousqueue-principle-fair-pattern/">SynchronousQueue原理详解-公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/stack-working-principle/">系统栈的工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/git-server-transfer/">git仓库迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/LinkedBlockingQueue-Principle/">LinkedBlockingQueue原理解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/arrayblockingqueue-principle/">ArrayBlockingQueue原理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/block-and-lock-free/">阻塞算法和非阻塞算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/you-have-to-know-the-concept-of-multithreading/">你必须知道的多线程几个概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/spring-boot-and-dubbo-starter/">SpringBoot快速整合dubbo</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/22/how-use-synchronized/">深入理解synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-autoconfiguration-fashion/">SpringBoot自动装配详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-thymeleaf-and-shiro/">spring-boot与thymeleaf模板整合shiro标签内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/use-hexo-to-build-a-blog/">使用Hexo搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/spring-boot-admin-monitor/">Spring Boot Admin监控系统搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/logback-with-elk/">使用Logback输出日志到ELK</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/elk-environment-construction-in-windows/">Windows环境下搭建ELK环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-sleuth/">分布式服务跟踪之Spring Cloud Sleuth快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/">集群监控Spring Cloud Turbine消息队列篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine/">集群监控之Spring Cloud Turbine快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-zuul/">API网关服务-Spring Cloud Zuul快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-config/">配置管理中心Spring Cloud Config快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-hystrix/">服务容错保护Spring Cloud Hystrix之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-ribbon/">客户端负载均衡Spring Cloud Ribbon之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/spring-cloud-tutorial-eureka/">服务治理-Spring Cloud Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/maven-skeleton-generation/">一文搭建Maven骨架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/java-class-loader/">Java类加载器详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/how-dynamic-agents-work/">动态代理的工作原理简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/hello-world/">我的blog之旅又要开始了</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-5-remote/">带你走进git-远程仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-4-rewriting-history/">带你走进git-重写历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-3-revert-operation/">带你走进git-撤销修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-study-2/">带你走进git-工作区、暂存区、分支</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-config/">带你走进git-基础配置</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2019 BattleHeart
            </div>
            <div class="footer-right">
                <a href="http://battleHeart.cn/" target="_blank" title="快速、简洁且高效的博客框架">BattleHeart</a>  Blog 
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>