<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="BattleHeart" />



<meta name="description" content="Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。">
<meta name="keywords" content="并发编程,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="图解AQS原理之ReentrantLock详解-非公平锁">
<meta property="og:url" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/index.html">
<meta property="og:site_name" content="BattleHeart">
<meta property="og:description" content="Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/1.jpg">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/2.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/3.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/4.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/5.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/6.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/7.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/8.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/9.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/10.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/11.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/12.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/13.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/15.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/16.png">
<meta property="og:updated_time" content="2019-06-02T01:33:08.957Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="图解AQS原理之ReentrantLock详解-非公平锁">
<meta name="twitter:description" content="Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。">
<meta name="twitter:image" content="https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/1.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="BattleHeart" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
    <link href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/orange/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>图解AQS原理之ReentrantLock详解-非公平锁 | BattleHeart</title>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdnjs.cloudflare.com/ajax/libs/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/jquery-ui.min.js", "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">BattleHeart</a></h1>
        </hgroup>

        
        <p class="header-subtitle">个人博客</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="dwlsxj:@126.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/dwlsxj" title="GitHub"></a>
                            
                                <a class="fa 博客园" href="https://www.cnblogs.com/dwlsxj/" title="博客园"></a>
                            
                                <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=31908845" title="网易云音乐"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELK/">ELK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://www.cnblogs.com/dwlsxj/">BalleHeart</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于后端开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">BattleHeart</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">BattleHeart</a></h1>
            </hgroup>
            
            <p class="header-subtitle">个人博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="dwlsxj:@126.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dwlsxj" title="GitHub"></a>
                            
                                <a class="fa 博客园" target="_blank" href="https://www.cnblogs.com/dwlsxj/" title="博客园"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=31908845" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-reentrantlock-principle-nonfairsync" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/02/reentrantlock-principle-nonfairsync/" class="article-date">
      <time datetime="2019-06-02T01:30:59.000Z" itemprop="datePublished">2019-06-02</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      图解AQS原理之ReentrantLock详解-非公平锁
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/个人技术/">个人技术</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="图解AQS原理之ReentrantLock详解-非公平锁"><a href="#图解AQS原理之ReentrantLock详解-非公平锁" class="headerlink" title="图解AQS原理之ReentrantLock详解-非公平锁"></a>图解AQS原理之ReentrantLock详解-非公平锁</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并发编程中，<code>ReentrantLock</code>的使用是比较多的，包括之前讲的<code>LinkedBlockingQueue</code>和<code>ArrayBlockQueue</code>的内部都是使用的<code>ReentrantLock</code>，谈到它又不能的不说AQS，AQS的全称是<code>AbstractQueuedSynchronizer</code>，这个类也是在<code>java.util.concurrent.locks</code>下面，提供了一个FIFO的队列，可以用于构建锁的基础框架，内部通过原子变量<code>state</code>来表示锁的状态，当<code>state</code>大于0的时候表示锁被占用，如果state等于0时表示没有占用锁，<code>ReentrantLock</code>是一个重入锁，表现在<code>state</code>上，如果持有锁的线程重复获取锁时，它会将<code>state</code>状态进行递增，也就是获得一个信号量，当释放锁时，同时也是释放了信号量，信号量跟随减少，如果上一个线程还没有完成任务，则会进行入队等待操作。</p>
<blockquote>
<p>本文分析内容主要是针对jdk1.8版本</p>
<p>约束：文中图片的ref-xxx代表引用地址</p>
<p>图片中的内容prve更正为prev，由于文章不是一天写的所以有些图片更正了有些没有。</p>
</blockquote>
<h3 id="AQS主要字段"><a href="#AQS主要字段" class="headerlink" title="AQS主要字段"></a>AQS主要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头节点指针，通过setHead进行修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列的尾指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<h3 id="AQS需要子类实现的方法"><a href="#AQS需要子类实现的方法" class="headerlink" title="AQS需要子类实现的方法"></a>AQS需要子类实现的方法</h3><p>AQS是提供了并发的框架，它内部提供一种机制，它是基于模板方法的实现，整个类中没有任何一个abstract的抽象方法，取而代之的是，需要子类去实现的那些方法通过一个方法体抛出UnsupportedOperationException异常来让子类知道，告知如果没有实现模板的方法，则直接抛出异常。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>tryAcquire</td>
<td>以独占模式尝试获取锁，独占模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td>
</tr>
<tr>
<td>tryRelease</td>
<td>尝试独占模式下释放状态</td>
</tr>
<tr>
<td>tryAcquireShared</td>
<td>尝试在共享模式获得锁，共享模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td>
</tr>
<tr>
<td>tryReleaseShared</td>
<td>尝试共享模式下释放状态</td>
</tr>
<tr>
<td>isHeldExclusively</td>
<td>是否是独占模式，表示是否被当前线程占用</td>
</tr>
</tbody>
</table>
<p>AQS是基于FIFO队列实现的，那么队列的Node节点又是存放的什么呢？</p>
<h3 id="Node字段信息"><a href="#Node字段信息" class="headerlink" title="Node字段信息"></a>Node字段信息</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHARED</td>
<td>Node</td>
<td>new Node()</td>
<td>一个标识，指示节点使用共享模式等待</td>
</tr>
<tr>
<td>EXCLUSIVE</td>
<td>Nodel</td>
<td>Null</td>
<td>一个标识，指示节点使用独占模式等待</td>
</tr>
<tr>
<td><code>CANCELLED</code></td>
<td>int</td>
<td>1</td>
<td>节点因超时或被中断而取消时设置状态为取消状态</td>
</tr>
<tr>
<td><code>SIGNAL</code></td>
<td>int</td>
<td>-1</td>
<td>当前节点的后节点被park，当前节点释放时，必须调用unpark通知后面节点，当后面节点竞争时，会将前面节点更新为<code>SIGNAL</code></td>
</tr>
<tr>
<td><code>CONDITION</code></td>
<td>int</td>
<td>-2</td>
<td>标识当前节点已经处于等待中，通过条件进行等待的状态</td>
</tr>
<tr>
<td><code>PROPAGATE</code></td>
<td>int</td>
<td>-3</td>
<td>共享模式下释放节点时设置的状态，被标记为当前状态是表示无限传播下去</td>
</tr>
<tr>
<td><code>0</code></td>
<td>int</td>
<td></td>
<td>不属于上面的任何一种状态</td>
</tr>
<tr>
<td>waitStatus</td>
<td>int</td>
<td>0</td>
<td>等待状态，默认初始化为0，表示正常同步等待，</td>
</tr>
<tr>
<td>pre</td>
<td>Node</td>
<td>Null</td>
<td>队列中上一个节点</td>
</tr>
<tr>
<td>next</td>
<td>Node</td>
<td>Null</td>
<td>队列中下一个节点</td>
</tr>
<tr>
<td>thread</td>
<td>Thread</td>
<td>Null</td>
<td>当前Node操作的线程</td>
</tr>
<tr>
<td>nextWaiter</td>
<td>Node</td>
<td>Null</td>
<td>指向下一个处于阻塞的节点</td>
</tr>
</tbody>
</table>
<p>通过上面的内容我们可以看到waitStatus其实是有5个状态的，虽然这里面0并不是什么字段，但是他是waitStatus状态的一种，表示不是任何一种类型的字段，上面也讲解了关于AQS中子类实现的方法，AQS提供了独占模式和共享模式两种，但是<code>ReentrantLock</code>实现的是独占模式的方式，下面来通过源码的方式解析<code>ReentrantLock</code>。</p>
<h2 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h2><p>首先在源码分析之前我们先来看一下ReentrantLock的类的继承关系，如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/1.jpg" alt="1"></p>
<p>可以看到<code>ReentrantLock</code>继承自<code>Lock</code>接口，它提供了一些获取锁和释放锁的方法，以及条件判断的获取的方法，通过实现它来进行锁的控制，它是显示锁，需要显示指定起始位置和终止位置，<code>Lock</code>接口的方法介绍：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock</td>
<td>用来获取锁，如果锁已被其他线程获取，则进行等待。</td>
</tr>
<tr>
<td>tryLock</td>
<td>表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</td>
</tr>
<tr>
<td>tryLock(long time, TimeUnit unit)</td>
<td>和tryLock()类似，区别在于它在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</td>
</tr>
<tr>
<td>lockInterruptibly</td>
<td>获取锁，如果获取锁失败则进行等到，如果等待的线程被中断会相应中断信息。</td>
</tr>
<tr>
<td>unlock</td>
<td>释放锁的操作</td>
</tr>
<tr>
<td>newCondition</td>
<td>获取Condition对象，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件wait()方法，而调用后，当前线程释放锁。</td>
</tr>
</tbody>
</table>
<p>ReentrantLock也实现了上面接口的内容，前面讲解了很多理论行的内容，接下来我们以一个简单的例子来进行探讨</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">      	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先声明内部类AddDemo，AddDemo的主要作用是将原子变量count进行递增的操作</li>
<li>AddDemo内部声明了ReentrantLock对象进行同步操作</li>
<li>AddDemo的add方法，进行递增操作，细心地同学发现，使用了lock方法获取锁，但是没有释放锁，这里面没有释放锁可以更让我们清晰的分析内部结构的变化。</li>
<li>主线程开启了两个线程进行同步进行递增的操作，最后让线程休眠一会输出累加的最后结果。</li>
</ol>
<p><code>ReentrantLock</code>内部提供了两种AQS的实现，一种公平模式，一种是非公平模式，如果没有特别指定在构造器中，默认是非公平的模式，我们可以看一下无参的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用有参构造函数时，指定使用哪种模式来进行操作，参数为布尔类型，如果指定为false的话代表非公平模式，如果指定为true的话代表的是公平模式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用的是非公平模式，后面再来进行分析公平模式，上面也讲到了分为两种模式，这两种模式为<code>FairSync</code>和<code>NonfairSync</code>两个内部静态类不可变类，不能被继承和实例化，这两个类是我们今天分析的重点，为什么说是重点呢，这里讲的内容是有关于AQS的，而<code>FairSync</code>和<code>NonfairSync</code>实现了抽象内部类<code>Sync</code>，<code>Sync</code>实现了<code>AbstractQueuedSynchronizer</code>这个类，这个类就是我们说的AQS也是主要同步操作的类，下面我们来看一下公平模式和非公平模式下类的继承关系，如下图所示：</p>
<p>非公平模式：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/2.png" alt="2"></p>
<p>公平模式：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/3.png" alt="3"></p>
<p>通过上面两个继承关系UML来看其实无差别，差别在于内部实现的原理不一样，回到上面例子中使用的是非公平模式，那先以非公平模式来进行分析，</p>
<p>假设第一个线程启动调用AddDemo的add方法时，首先执行的事<code>reentrantLock.lock()</code>方法，这个lock方法调用了<code>sync.lock()</code>,sync就是我们上面提到的两种模式的对象，来看一下源码内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了<code>sync.lock()</code>,其实是调用了<code>NonfairSync</code>对象的<code>lock</code>方法，也就是下面的方法内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平模式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行锁动作，先进行修改状态，如果锁被占用则进行请求申请锁，申请锁失败则将线程放到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 继承自AQS的tryAcquire方法，尝试获取锁操作，这个方法会被AQS的acquire调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到<code>lock</code>方法首先先对<code>state</code>状态进行修改操作，如果锁没有被占用则获取锁，并设置当前线程独占锁资源，如果尝试获取锁失败了，则进行<code>acqurie</code>方法的调用，例子中第一个线程当尝试获取锁是内部<code>state</code>状态为<code>0</code>，进行修改操作的时候，发现锁并没有被占用，则获得锁，此时我们来看一下内部变化的情况，如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/4.png" alt="4"></p>
<p>此时只是将<code>state</code>的状态更新为<code>1</code>，表示锁已经被占用了，独占锁资源的线程是<code>Thread0</code>，也就是<code>exclusiveOwnerThread</code>的内容，头节点和尾节点都没有被初始化，当第二个线程尝试去获取锁的时候，发现锁已经被占用了，因为上一个线程并没有释放锁，所以第二线程直接获取锁时获取失败则进入到<code>acquire</code>方法中，这个方法是<code>AbstractQueuedSynchronizer</code>中的方法<code>acquire</code>，先来看一下具体的实现源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我个人理解<code>acquire</code>方法不间断的尝试获取锁，如果锁没有获取到则现将节点加入到队列中，并将当前线程设置为独占锁资源，也就是独占了锁的意思，别的线程不能拥有锁，然后如果当前节点的前节点是头节点话，再去尝试争抢锁，则设置当前节点为头节点，并将原头节点的下一个节点设置为null，帮助GC回收它，如果不是头节点或争抢锁不成功，则会现将前面节点的状态设置直到设置为<code>SIGNAL</code>为止，代表下面有节点被等待了等待上一个线程发来的信号，然后就挂起当前线程。</p>
<p>我们接下来慢慢一步一步的分析，我们先来看一下<code>NonfairSync</code>中的<code>tryAcquire</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用的是他的父类方法，也就是<code>ReentrantLock</code>下<code>Sync</code>中的<code>nonfairTryAcquire</code>方法，这个方法主要就是去申请锁的操作，来看一下具体源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;			<span class="comment">//首先是一个被final修饰的方法</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();	<span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();															<span class="comment">//获取state的状态值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;																		<span class="comment">//如果状态等于0代表线程没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;			<span class="comment">//cas修改state值</span></span><br><span class="line">            setExclusiveOwnerThread(current);				<span class="comment">//设置当前线程为独占模式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//如果state状态不等于0则先判断是否是当前线程占用锁，如果是则进行下面的流程。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;										<span class="comment">//这个地方就说明重入锁的原理，如果拥有锁的是当前线程，则每次获取锁state值都会跟随递增</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow									//溢出了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);														<span class="comment">//直接设置state值就可以不需要CAS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;																		<span class="comment">//都不是就返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以看到其实他是有三种操作逻辑：</p>
<ul>
<li>如果<code>state</code>为0，则代表锁没有被占用，尝试去修改state状态，并且将当前线程设置为独占锁资源，表示获得锁成功</li>
<li>如果<code>state</code>大于0并且拥有锁的线程和当前申请锁的线程一致，则代表重入了锁，<code>state</code>值会进行递增，表示获得锁成功</li>
<li>如果<code>state</code>大于0并且拥有锁的线程和当前申请锁的线程不一致则直接返回false，代表申请锁失败</li>
</ul>
<p>当第二个线程去争抢锁的时候，state值已经设置为1了也就是已经被第一个线程占用了锁，所以这里它会返回false，而通过<code>acquire</code>方法内容可以看到if语句中是<code>!tryAcquire(arg)</code>，也就是<code>!false=ture</code>，它会进行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code>方法，这个方法里面又有一个<code>addWaiter</code>方法，从方法语义上能看到是添加等待队列的操作，方法的参数代表的是模式，<code>Node.EXCLUSIVE</code>表示的是在独占模式下等待，我们先来看一下<code>addWaiter</code>里面是如何进行操作，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//首先生成当前线程拥有的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 下面的内容是尝试快速进行插入末尾的操作，在没有其他线程同时操作的情况</span></span><br><span class="line">    Node pred = tail;												<span class="comment">//获取尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;											<span class="comment">//尾节点不为空，代表队列不为空</span></span><br><span class="line">        node.prev = pred;										<span class="comment">//尾节点设置为当前节点的前节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//修改尾节点为当前节点</span></span><br><span class="line">            pred.next = node;								<span class="comment">//原尾节点的下一个节点设置为当前节点</span></span><br><span class="line">            <span class="keyword">return</span> node;										<span class="comment">//返回node节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);															<span class="comment">//如果前面入队失败，这里进行循环入队操作，直到入队成功</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面代码中可以看到，它有一个快速入队的操作，如果快速入队失败则进行死循环进行入队操作，当然我们上面例子中发现队列其实是为空的，也就是pred==null，不能进行快速入队操作，则进入到<code>enq</code>进行入队操作，下面看一下<code>enq</code>方法实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;																<span class="comment">//死循环进行入队操作，直到入队成功</span></span><br><span class="line">        Node t = tail;												<span class="comment">//获取尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize		//判断尾节点为空，则必须先进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))<span class="comment">//生成一个Node，并将当前Node作为头节点</span></span><br><span class="line">                tail = head;									<span class="comment">//head和tail同时指向上面Node节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;															</span><br><span class="line">            node.prev = t;										<span class="comment">//设置入队的当前节点的前节点设置为尾节点	</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;	<span class="comment">//将当前节点设置为尾节点</span></span><br><span class="line">                t.next = node;								<span class="comment">//修改原有尾节点的下一个节点为当前节点</span></span><br><span class="line">                <span class="keyword">return</span> t;											<span class="comment">//返回最新的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面入队操作，可以清晰的了解入队操作其实就是Node节点的prev节点和next节点之前的引用，运行到这里我们应该能看到入队的状态了，如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/5.png" alt="5"></p>
<p>如上图可以清晰的看到，此时拥有锁的线程是Thread0，而当前线程是Threa1，头节点为初始化的节点，<code>Ref-707</code>引用地址所在的Node节点操作当前操作的节点信息，入队操作后并没有完成，而是继续往下进行，此时则进行<code>acquireQueued</code>这个方法，这个方法是不间断的去获取已经入队队列中的前节点的状态，如果前节点的状态为大于0，则代表当前节点被取消了，会一直往前面的节点进行查找，如果节点状态小于0并且不等于<code>SIGNAL</code>则将其设置为<code>SIGNAL</code>状态，设置成功后将当前线程挂起，挂起线程后也有可能会反复唤醒挂起操作，原因后面会讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;												<span class="comment">//取消节点标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;							<span class="comment">//中断标志位</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();		<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;		<span class="comment">//这里的逻辑是如果前节点为头结点并且获取到锁则进行头结点变换</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;	<span class="comment">//设置waitStatus状态</span></span><br><span class="line">                parkAndCheckInterrupt())									<span class="comment">//挂起线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);								<span class="comment">//取消操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的源码可以看到它在<code>acquireQueued</code>中对已经入队的节点进行尝试锁的获取，如果锁获得就修改头节点的指针，如果不是头节点或者争抢锁失败时，此时会进入到<code>shouldParkAfterFailedAcquire</code>方法，这个方法是获取不到锁时需要停止继续无限期等待锁，其实就是内部的操作逻辑也很简单，就是如果前节点状态为<code>0</code>时，需要将前节点修改为<code>SIGNAL</code>，如果前节点大于<code>0</code>则代表前节点已经被取消了，应该移除队列，并将前前节点作为当前节点的前节点，一直循环直到前节点状态修改为<code>SIGNAL</code>或者前节点被释放锁，当前节点获取到锁停止循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 此节点已经设置了状态，要求对当前节点进行挂起操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前节点被取消，则将取消节点移除队列操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus=0或者PROPAGATE时，表示当前节点还没有被挂起停止，需要等待信号来通知节点停止操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法其实很容易理解就是等待挂起信号，如果前节点的状态为0或PROPAGATE则将前节点修改为<code>SIGNAL</code>，则代表后面前节点释放锁后会通知下一个节点，也就是说唤醒下一个可以唤醒的节点继续争抢所资源，如果前节点被取消了那就继续往前寻找不是被取消的节点，这里不会找到前节点为null的情况，因为它默认会有一个空的头结点，也就是上图内容，此时的队列状态是如何的我们看一下，这里它会进来两次，以为我们上图可以看到当前节点前节点是<code>Ref-724</code>此时<code>waitStatus=0</code>，他需要先将状态更改为<code>SIGNAL</code>也就是运行最有一个else语句，此时又会回到外面的for循环中，由于方法返回的是false则不会运行<code>parkAndCheckInterrupt</code>方法，而是又循环了一次，此时发现当前节点争抢锁又失败了，然后此时队列的状态如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/6.png" alt="6"></p>
<p>再次进入到方法之后发现前驱节点的waitStatus=-1，表示当前节点需要进行挂起等到，此时返回的结果是true，则会运行<code>parkAndCheckInterrupt</code>方法，这个方法很简单就是将当前线程进行挂起操作，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);						<span class="comment">//挂起线程</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();			<span class="comment">//判断是否被中断，获取中断标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>park</code>挂起线程并且响应中断信息，其实我们从这里就能发现一个问题，Thread.interrupted方法是用来获取是否被中断的标志，如果被中断则返回true，如果没有被中断则返回false，当当前节点被中断后，其实就会返回true，返回true这里并没有结束，而是跳到调用地方，也就是<code>acquireQueued</code>方法内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>以一个案例来进行分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子可以发现，thread1调用中断方法interrupt()，当调用第一次方法的时候，它会进入到<code>parkAndCheckInterrupt</code>方法，然后线程响应中断，最后返回true，最后返回到<code>acquireQueued</code>方法内部，整个if语句为true，则开始设置interrupted=true，仅仅是设置了等于true，但是这离还会进入下一轮的循环，假如说上次的线程没有完成任务，则没有获取到锁，还是会进入到<code>shouldParkAfterFailedAcquire</code>由于已经修改了上一个节点的waitStatus=-1，直接返回true，然后再进入到<code>parkAndCheckInterrupt</code>又被挂起线程，但是如果上步骤操作他正抢到锁，则会返回ture，外面也会清除中断标志位，从这里可以清楚地看到<code>acquire</code>方法是一个不间断获得锁的操作，可能重复阻塞和解除阻塞操作。</p>
<p>上面阻塞队列的内容已经讲完了，接下来我们看一下unlock都为我们做了什么工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到他直接调用了独占模式的<code>release</code>方法，看一下具体源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;									<span class="comment">//调用ReentrantLock中的Sync里面的tryRelease方法</span></span><br><span class="line">        Node h = head;											<span class="comment">//获取头节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)	<span class="comment">//头节点不为空且状态不为0时进行unpark方法</span></span><br><span class="line">            unparkSuccessor(h);							<span class="comment">//唤醒下一个未被取消的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>release方法，首先先进行尝试去释放锁，如果释放锁仍然被占用则直接返回false，如果尝试释放锁时，发现锁已经释放，当前线程不在占用锁资源时，则会进入的下面进行一些列操作后返回true，接下来我们先来看一下<code>ReentrantLock</code>的<code>Sync</code>下的<code>tryRelease</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;														<span class="comment">//获取state状态，标志信息减少1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())	<span class="comment">//线程不一致抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;																			<span class="comment">//是否已经释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;																							<span class="comment">//state=0时表示锁已经释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;																					<span class="comment">//将标志free设置为true</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);												<span class="comment">//取消独占锁信息</span></span><br><span class="line">    &#125;	</span><br><span class="line">    setState(c);																							<span class="comment">//设置锁标志信息</span></span><br><span class="line">    <span class="keyword">return</span> free;																							</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的源码，表示首先先获取<code>state</code>状态，如果<code>state</code>状态减少1之后和0不相等则代表有重入锁，则表示当前线程还在占用所资源，直到线程释放锁返回ture标识，还是以上例子为主（此时<code>AddDemo</code>中的<code>unlock</code>不在被注释），分析其现在的队列中的状态</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/7.png" alt="7"></p>
<p>释放锁后，进入到if语句中，判断当前头节点不为空且<code>waitStatus!=0</code>，通过上图也可以发现头节点为-1，则进入到<code>unparkSuccessor</code>方法内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取节点的waitStatus状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  	<span class="comment">// 如果小于0则设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)	</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 唤醒下一个节点，唤醒下一个节点之前需要判断节点是否存在或已经被取消了节点，如果没有节点则不需唤醒操作，如果下一个节点被取消了则一直一个没有被取消的节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是现将头节点的状态更新为0，然后再唤醒下一个节点，如果下一个节点为空则直接返回不唤醒任何节点，如果下一个节点被取消了，那么它会从尾节点往前进行遍历，遍历与头节点最近的没有被取消的节点进行唤醒操作，在唤醒前看一下队列状态：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/8.png" alt="8"></p>
<p>然后唤醒节点后他会进入到<code>parkAndCheckInterrupt</code>方法里面，再次去执行下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;												<span class="comment">//取消节点标志位</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;							<span class="comment">//中断标志位</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();		<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;		<span class="comment">//这里的逻辑是如果前节点为头结点并且获取到锁则进行头结点变换</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;	<span class="comment">//设置waitStatus状态</span></span><br><span class="line">                parkAndCheckInterrupt())									<span class="comment">//挂起线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);								<span class="comment">//取消操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时获取p==head成立，并且可以正抢到所资源，所以它会进入到循环体内，进行设置头结点为当前节点，前节点的下一个节点设置为null，返回中断标志，看一下此时队列情况，如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/9.png" alt="9"></p>
<p><code>AbstractQueuedSynchronizer</code>的独占模式其实提供了三种不同的形式进行获取锁操作，看一下下表所示：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法描述</th>
<th>对应调用的内部方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>acquire</td>
<td>以独占模式进行不间断的获取锁</td>
<td>tryAcquire，acquireQueued</td>
</tr>
<tr>
<td>acquireInterruptibly</td>
<td>以独占模式相应中断的方式获取锁，发生中断抛出异常</td>
<td>tryAcquire，doAcquireInterruptibly</td>
</tr>
<tr>
<td>tryAcquireNanos</td>
<td>以独占模式相应中断的方式并且在指定时间内获取锁，会阻塞一段时间，如果还未获得锁直接返回，发生中断抛出异常</td>
<td>tryAcquire，doAcquireNanos</td>
</tr>
</tbody>
</table>
<p>通过上面图可以发现，他都会调用图表一中需要用户实现的方法，<code>ReentrantLock</code>实现了独占模式则内部实现的是<code>tryAcquire</code>和<code>tryRelease</code>方法，用来尝试获取锁和尝试释放锁的操作，其实上面内容我们用的是<code>ReentrantLock</code>中的<code>lock</code>方法作为同步器，细心的朋友会发现，这个<code>lock</code>，方法是ReentrantLock实现的，它内部调用了<code>acquire</code>方法，实现了不间断的获取锁机制，<code>ReentrantLock</code>中还有一个<code>lockInterruptibly</code>方法，它内部直接调用的是<code>AbstractQueuedSynchronizer</code>的<code>acquireInterruptibly</code>方法，两个之间的区别在于，两者都会相应中断信息，前者不会做任何处理还会进入等待状态，而后者则抛出异常终止操作，</p>
<p>这里为了详细看清楚它内部关系我这里用张图来进行阐述，如下所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/10.png" alt="10"></p>
<ol>
<li>左侧代表的事ReentrantLock，右侧代表的AQS</li>
<li>左侧内部黄色区域代表<code>NonfairSync</code></li>
<li>图中1和2代表AQS调用其他方法的过程</li>
</ol>
<p>接下来我们来看一下源码信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现他调用的<code>Sync</code>类中的<code>acquireInterruptibly</code>方法，但其实这个方法是AQS中的方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())												<span class="comment">//判断线程是否被中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();						<span class="comment">//中断则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))														<span class="comment">//尝试获取锁</span></span><br><span class="line">        doAcquireInterruptibly(arg);								<span class="comment">//进行添加队列，并且修改前置节点状态，且响应中断抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码，它也调用了子类实现的<code>tryAcquire</code>方法，这个方法和我们上文提到的<code>tryAcquire</code>是一样，<code>ReentrantLock</code>下的<code>NonfairSync</code>下的<code>tryAcquire</code>方法，这里这个方法就不多说了详细请看上文内容，这里主要讲一下<code>doAcquireInterruptibly</code>这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);						<span class="comment">//将节点添加到队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;																	<span class="comment">//失败匹配机制</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();							<span class="comment">//获取前节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;							<span class="comment">//如果前节点为头节点并且获得了锁</span></span><br><span class="line">                setHead(node);															<span class="comment">//设置当前节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC										//头节点的下一个节点设置为null</span></span><br><span class="line">                failed = <span class="keyword">false</span>;															<span class="comment">//匹配失败变为false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;		</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;		<span class="comment">//将前节点设置为-1，如果前节点为取消节点则往前一直寻找直到修改为-1为止。</span></span><br><span class="line">                parkAndCheckInterrupt())										<span class="comment">//挂起线程返回是否中断</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个方法和<code>acquireQueued</code>区别在于以下几点：</p>
<ol>
<li><code>acquireQueued</code>是在方法内部添加节点到队列尾部，而<code>doAcquireInterruptibly</code>是在方法内部进行添加节点到尾部，这个区别点并不是很重要</li>
<li>重点是<code>acquireQueued</code>响应中断，但是他不会抛出异常，而后者会抛出异常throw new InterruptedException()</li>
</ol>
<p>分析到这里我们来用前面的例子来进行模拟一下中中断的操作，详细代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AddDemo runnalbeDemo = <span class="keyword">new</span> AddDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(runnalbeDemo::add);</span><br><span class="line">        thread3.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(runnalbeDemo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程被中断了"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                reentrantLock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子其实和前面提到的例子没有什么太大的差别主要的差别是将<code>lock</code>替换为<code>lockInterruptibly</code>，其次就是在三个线程后面讲线程1进行中断操作，这里入队的操作不在多说，因为操作内容和上面大致相同，下面是四个个线程操作完成的状态信息：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/11.png" alt="11"></p>
<p>如果线程等待的过程中抛出异常，则当前线程进入到finally中的时候failed为true，因为修改该字段只有获取到锁的时候才会修改为false，进来之后它会运行<code>cancelAcquire</code>来进行取消当前节点，下面我们先来分析下源码内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空直接返回，节点不存在直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 设置节点所在的线程为空，清除线程操作</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的前节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">  	<span class="comment">// 如果前节点是取消节点则跳过前节点，一直寻找一个不是取消节点为止</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 获取头节点下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接设置为取消节点状态，没有使用CAS原因是因为直接设置只有其他线程可以跳过取消的节点</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点为尾节点，并且设置尾节点为找到的合适的前节点时，修改前节点的下一个节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是尾节点，则说明是中间节点，则需要通知后续节点，嘿，伙计你被唤醒了。</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;															<span class="comment">//前节点不是头结点</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||		<span class="comment">// 前节点的状态为SIGNAL </span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) <span class="comment">//或者前节点状态小于0而且修改前节点状态为SIGNAL成功 </span></span><br><span class="line">           	&amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;											<span class="comment">//前节点线程不为空</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">//唤醒下一个不是取消的节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先找到当前节点的前节点，如果前节点为取消节点则一直往前寻找一个节点。</li>
<li>取消的是尾节点，则直接将前节点的下一个节点设置为null</li>
<li>如果取消的是头节点的下一个节点，且不是尾节点的情况时，它是唤醒下一个节点，唤醒之前并没有将其移除队列，而是在唤醒下一个节点的时候，<code>shouldParkAfterFailedAcquire</code>里面将取消的节点移除队列，唤醒之后，当前节点的下一个节点也设置成自己，帮助GC回收它。</li>
<li>如果取消节点是中间的节点，则直接将其前节点的下一个节点设置为取消节点的下下个节点即可。</li>
</ol>
<p>第一种情况如果我们取消的节点是前节点是头节点，此时线程1的节点应该是被中断操作，此时进入到<code>cancelAcquire</code>之后会进入else语句中，然后进去到<code>unparkSuccessor</code>方法，当进入到这个方法之前我们看一下状态变化：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/12.png" alt="12"></p>
<p>我们发现线程1的Node节点的waitStatus变为1也就是<code>Node.CANCELLED</code>节点，然后运行<code>unparkSuccessor</code>方法，该方法上面就已经讲述了其中的源码，这里就不在贴源码了，就是要唤醒下一个没有被取消的节点，这里是<code>Ref-695</code>这个线程，当<code>Ref-695</code>被唤醒之后它会继续运行下面的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;						<span class="comment">//再一次循环发现还是没有争抢到锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;	<span class="comment">//再一次循环之后有运行到这里了</span></span><br><span class="line">                parkAndCheckInterrupt())									<span class="comment">//这里被唤醒了，又要进行循环操作了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现再一次循环操作后，还是没有正抢到锁，这时候还是会运行<code>shouldParkAfterFailedAcquire</code>方法，这个方法内部发现前节点的状态是<code>Node.CANCELLED</code>这时候它会在内部先将节点给干掉，也就是这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">     * indicate retry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还是会被挂起状态，因为没有释放锁操作，最后移除的节点如下所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/13.png" alt="13"></p>
<p>如果取消的事尾节点，也就是线程3被中断操作，这个是比较简单的直接将尾节点删除即可，其中会走如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/15.png" alt="15"></p>
<p>如果取消的节点是中间的节点，通过上例子中则是取消线程2，其实它内部只是将线程取消线程的前节点的下一个节点指向了取消节点的下节点，如下图所示：</p>
<p><img src="/2019/06/02/reentrantlock-principle-nonfairsync/16.png" alt="16"></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这章节分析的主要是<code>ReentrantLock</code>的内部原理，本来公平模式和非公平模式想放在一起来写，无奈发现篇幅有点长了，所以就分开进行写，这样读取来不会那么费劲，内部还有条件内容等待下章节分析，如果有分析不到位的请大家指正。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/06/02/reentrantlock-principle-nonfairsync/">图解AQS原理之ReentrantLock详解-非公平锁</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">BattleHeart</a></p>
        <p><span>发布时间:</span>2019-06-02, 09:30:59</p>
        <p><span>最后更新:</span>2019-06-02, 09:33:08</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/06/02/reentrantlock-principle-nonfairsync/" title="图解AQS原理之ReentrantLock详解-非公平锁">https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/</a>
            <span class="copy-path" data-clipboard-text="原文: https://www.battleheart.cn/2019/06/02/reentrantlock-principle-nonfairsync/　　作者: BattleHeart" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/05/18/synchronousqueue-principle-unfair-pattern/">
                    SynchronousQueue原理详解-非公平模式
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#图解AQS原理之ReentrantLock详解-非公平锁"><span class="toc-number">1.</span> <span class="toc-text">图解AQS原理之ReentrantLock详解-非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS主要字段"><span class="toc-number">1.1.1.</span> <span class="toc-text">AQS主要字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS需要子类实现的方法"><span class="toc-number">1.1.2.</span> <span class="toc-text">AQS需要子类实现的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node字段信息"><span class="toc-number">1.1.3.</span> <span class="toc-text">Node字段信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock源码分析"><span class="toc-number">1.2.</span> <span class="toc-text">ReentrantLock源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束语"><span class="toc-number">1.3.</span> <span class="toc-text">结束语</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"图解AQS原理之ReentrantLock详解-非公平锁　| BattleHeart　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/05/18/synchronousqueue-principle-unfair-pattern/" title="下一篇: SynchronousQueue原理详解-非公平模式">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/reentrantlock-principle-nonfairsync/">图解AQS原理之ReentrantLock详解-非公平锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/18/synchronousqueue-principle-unfair-pattern/">SynchronousQueue原理详解-非公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/synchronousqueue-principle-fair-pattern/">SynchronousQueue原理详解-公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/stack-working-principle/">系统栈的工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/git-server-transfer/">git仓库迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/LinkedBlockingQueue-Principle/">LinkedBlockingQueue原理解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/arrayblockingqueue-principle/">ArrayBlockingQueue原理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/block-and-lock-free/">阻塞算法和非阻塞算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/you-have-to-know-the-concept-of-multithreading/">你必须知道的多线程几个概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/spring-boot-and-dubbo-starter/">SpringBoot快速整合dubbo</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/22/how-use-synchronized/">深入理解synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-autoconfiguration-fashion/">SpringBoot自动装配详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-thymeleaf-and-shiro/">spring-boot与thymeleaf模板整合shiro标签内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/use-hexo-to-build-a-blog/">使用Hexo搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/spring-boot-admin-monitor/">Spring Boot Admin监控系统搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/logback-with-elk/">使用Logback输出日志到ELK</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/elk-environment-construction-in-windows/">Windows环境下搭建ELK环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-sleuth/">分布式服务跟踪之Spring Cloud Sleuth快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/">集群监控Spring Cloud Turbine消息队列篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine/">集群监控之Spring Cloud Turbine快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-zuul/">API网关服务-Spring Cloud Zuul快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-config/">配置管理中心Spring Cloud Config快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-hystrix/">服务容错保护Spring Cloud Hystrix之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-ribbon/">客户端负载均衡Spring Cloud Ribbon之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/spring-cloud-tutorial-eureka/">服务治理-Spring Cloud Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/maven-skeleton-generation/">一文搭建Maven骨架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/java-class-loader/">Java类加载器详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/how-dynamic-agents-work/">动态代理的工作原理简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/hello-world/">我的blog之旅又要开始了</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-5-remote/">带你走进git-远程仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-4-rewriting-history/">带你走进git-重写历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-3-revert-operation/">带你走进git-撤销修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-study-2/">带你走进git-工作区、暂存区、分支</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-config/">带你走进git-基础配置</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2019 BattleHeart
            </div>
            <div class="footer-right">
                <a href="http://battleHeart.cn/" target="_blank" title="快速、简洁且高效的博客框架">BattleHeart</a>  Blog 
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>