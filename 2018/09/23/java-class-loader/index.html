<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8" >
    <meta name="baidu-site-verification" content="dIcXMeY8Ya" />
    
    <title>Java类加载器详解 | BattleHeart</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" >
    <meta name="keywords" content="BattleHeart, 后端, Web, Python, Spring , Spring Cloud" >
    <meta name="description" content="BattleHeart个人小站" >

    
    <link rel="alternative" href="/atom.xml" title="BattleHeart" type="application/atom+xml" >
    
    
    <link rel="shortcut icon" href="/img/favicon.ico" >
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>

<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">BattleHeart</span>
                    <span class="description">个人博客</span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/2018/09/23/java-class-loader/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/2018/09/23/java-class-loader/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/2018/09/23/java-class-loader/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/2018/09/23/java-class-loader/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/dwlsxj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon" >
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章页 -->
<!-- 文章 -->
<article class="post article">
    <header class="text-center">
        <h3 class="post-title"><span>Java类加载器详解</span></h3>
    </header>
    <p class="post-meta text-center">
        BattleHeart 发表于
        <time datetime="2018-09-22T16:00:00.000Z">2018-09-23</time>
    </p>
    <div class="post-content">
        <ul>
<li><a href="#类加载器详解">类加载器详解</a><ul>
<li><a href="#一、类加载器5大部分">一、类加载器5大部分</a><ul>
<li><a href="#加载">加载</a></li>
<li><a href="#验证">验证</a></li>
<li><a href="#准备">准备</a></li>
<li><a href="#解析">解析</a></li>
<li><a href="#初始化">初始化</a></li>
</ul>
</li>
<li><a href="#二、类加载器">二、类加载器</a></li>
<li><a href="#三、自定义类加载器">三、自定义类加载器</a><h1 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h1><h2 id="一、类加载器5大部分"><a href="#一、类加载器5大部分" class="headerlink" title="一、类加载器5大部分"></a>一、类加载器5大部分</h2>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。<br><img src="/2018/09/23/java-class-loader/./pic1.png" alt="加载机制" title="JVM类加载机制">  <h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p>
<p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;</code>方法之中，这里我们后面会解释。<br>但是注意如果声明为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p>
<p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info</span><br><span class="line">CONSTANT_Field_info</span><br><span class="line">CONSTANT_Method_info</span><br></pre></td></tr></table></figure></p>
<p>等类型的常量。<br>下面我们解释一下符号引用和直接引用的概念：<br>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。  </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。<br>初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。<code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;clinit&gt;</code>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。（clinit初始化是对类成员信息进行初始化，init是对对象实例进行初始化操作）<br>注意以下几种情况不会执行类初始化：<br>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>定义对象数组，不会触发该类的初始化。<br>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。<br>通过类名获取Class对象，不会触发类的初始化。<br>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。  </p>
<h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：  </p>
<ol>
<li>启动类加载器(<code>Bootstrap ClassLoader</code>)：负责加载 JAVA_HOME\lib（JRE/lib/rt.jar） 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。  </li>
<li>扩展类加载器(<code>Extension ClassLoader</code>)：负责加载 JAVA_HOME\lib\ext（JRE/lib/ext/*.jar） 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。  </li>
<li>应用程序类加载器(<code>Application ClassLoader</code>)：负责加载用户路径（classpath）上的类库。</li>
<li>自定义的类加载器（<code>User ClassLoader</code>）：负责加载用户自定义的路径上的类库。<br>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承<code>java.lang.ClassLoader</code>实现自定义的类加载器。</li>
</ol>
<p><img src="/2018/09/23/java-class-loader/./pic2.png" alt="委托图" title="委托图"><br>类加载器的委托机制：  </p>
<ol>
<li>首先当前线程去加载线程中的第一个类  </li>
<li>如果A中引用了B，java虚拟机将使用加载类A的类加载取来加载B  </li>
<li>还可以直接使用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。   </li>
</ol>
<p>每个类加载器加载类时，又先委托给其上级类加载器。   </p>
<ol>
<li>当所有祖先类加载器没有加载到类，回到发起者类加载器，还加载不了就抛出异常<code>ClassNotFoundException</code>，不是再去找发起类加载器的儿子节点，因为没有getChild方法。  </li>
</ol>
<p>eg.比如说我们自定义一个类A，当我们去获取当前类加载器的名称时，肯定是AppClassLoader加载器，因为我们当前类只有CLASSPATH路径下有没如果我们将当前的项目打包成test.jar将jar包放入到JRE/lib/ext路径下，这时候我们在CLASSPATH中类就不会被加载，首先加载的是ext下的类A。这时候我们输出类A加载器名称的时就会输出ExtClassLoader。下面做演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.printf(ClassLoaderTest.class.getClassLoader().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ClassLoaderTest是我们新建立的类，获取当前类的加载器时输出内容为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure></p>
<p>如果打包成jar包放到，ext文件下我们来看一下内容：<br><img src="/2018/09/23/java-class-loader/./pic.png" alt="ext目录结构" title="ext目录结构"></p>
<p>这是输出一下内容查看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = com.classloadertest.ClassLoaderTest.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(classLoader.getClass().getName()); </span><br><span class="line">    classLoader=classLoader.getParent();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure>
<p>循环输出类加载器结构的时候会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<p>因为Bootstrap类加载器实现不是由Java实现所以获取不到字节码，也就是为null的时候意味着是树状结构的顶层。</p>
<h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><p>有些时候我们需要实现自定义的类加载器来加载一些类，这时候我们可以继承ClassLoader来进行实现自定义的类加载器。我们先看一下jdk中的ClassLoader的源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归先父类进行尝试加载。</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先检测当前类有没有加载，如果加载在就不需要加载直接返回字节码</li>
<li>如果没有被加载，这时候会委托加载机制，通过递归从父加载器开始找，直到父类加载器为bootstrap ClassLoader为止，如果父类加载器找到了该字节码后没直接返回如果没有就返回让子类加载器加载，当子类加载器时，</li>
<li>如果还没有找到，这时候调用findClass方法进行查找。</li>
<li>最后根据resolve的值，判断这个class是否需要解析。<br><img src="/2018/09/23/java-class-loader/./pic3.png" alt="流程图" title="流程图"></li>
</ol>
<p>首先类加载器进行加载时当前线程的上线文的<code>ClassLoader</code>也就是<code>APPClassLoader</code>，当加载类时调用<code>LoadClass</code>方法，当调用的时候会检测当前类有没有被加载如果被加载了，就不需要在加载了直接返回，反之调用父类加载器的<code>LoadClass</code>方法，当父类加载器的父加载器不是null的时候就再去调用<code>LoadClass</code>方法，这时候的类加载器是<code>ExtClassLoader</code>加载器，父类加载是<code>BootStrap ClassLoader</code>，这时候继续递归调用<code>LoadClass</code>方法，这时候类加载器为<code>BootStrap ClassLoader</code>， 这时候就不需要再往下寻找了， <code>parent ClassLoader</code>为null。这是调用<code>findBootstrapClassOrNull(name)</code>方法，如果c不为null，这时候就直接返回，但是如果为null就调用<code>findClass</code>进行查询加载，如果还为null，这时候就会调用父类加载器<code>ExtClassLoader</code>的<code>findClass</code>方法，如果还是没有找到，则调用线程本身的类加载器调用findClass方法返回相应字节码，如果还没有找到抛出异常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载器采用了设计模式是模板方法，也就是LoadClass方法是不需要进行改变的，我们需要关注的就是findClass()方法就好了。所以我们写自己的ClassLoader只需要继承ClassLoader并重写findClass方法即可。</span><br></pre></td></tr></table></figure></p>
<p>参考地址：<br><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a><br><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a>  </p>

    </div>
    <p class="post-meta">
        <span class="post-cat">分类：
            <a class="cat-link" href="/categories/个人技术/">个人技术</a>
        </span>
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Java/" title="Java">Java</a>
    

        </span>
    </p>
</article>
<!-- 分享按钮 -->

  <div class="article-share clearfix text-center">
    <div class="share-area">
      <span class="share-txt">分享到：</span>
      <a href="javascript: window.open('http://service.weibo.com/share/share.php?url=' + encodeURIComponent(location.href) + '&title=' + document.title + '&language=zh_cn');" class="share-icon weibo"></a>
      <a href="javascript: alert('请复制链接到微信并发送');" class="share-icon wechat"></a>
      <a href="javascript: window.open('http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodeURIComponent(location.href) + '&title=' + document.title);" class="share-icon qqzone"></a>
      <a href="javascript: window.open('http://connect.qq.com/widget/shareqq/index.html?url=' + encodeURIComponent(location.href) + '&desc=Jelon个人博客&title=' + document.title + '&callback=' + encodeURIComponent(location.href));" class="share-icon qq"></a>
      <a href="javascript: window.open('http://shuo.douban.com/!service/share?href=' + encodeURIComponent(location.href) + '&name=' + document.title + '&text=' + document.title);" class="share-icon douban"></a>
    </div>
  </div>


<!-- 上一篇/下一篇 -->

<div class="article-nav clearfix">
    
    <span class="prev fl">
        上一篇<br >
        <a href="/2018/09/23/maven-skeleton-generation/">
            
                一文搭建Maven骨架
            
        </a>
    </span>
    

    
    <span class="next fr">
        下一篇<br >
        <a href="/2018/09/20/how-dynamic-agents-work/">
            
                动态代理的工作原理简要分析
            
        </a>
    </span>
    
</div>

<!-- 文章评论 -->


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/生活杂谈/">生活杂谈</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/个人技术/">个人技术</a>
        <span class="badge">(3)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/Life/" title="Life">Life (1)</a>
  
    <a class="tag-item" href="/tags/Maven/" title="Maven">Maven (1)</a>
  
    <a class="tag-item" href="/tags/Java/" title="Java">Java (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://www.cnblogs.com/dwlsxj/" target="_blank" title="博客园">BattleHeart博客</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2018
    

    <a href="/">版权归BattleHeart所有</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>