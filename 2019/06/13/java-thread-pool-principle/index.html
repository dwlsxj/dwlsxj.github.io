<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="BattleHeart">



<meta name="description" content="为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用，在线程池中，总会有活跃的线程在占用，但是线程池中也会存在没有占用的线程，这些线程处于空闲状态，当有任务的时候会从池子里面拿去一个线程来进行使用，当完成工作后，并没有销毁线程，而是将将线程放回到池子中去。">
<meta name="keywords" content="并发编程,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程池原理浅析">
<meta property="og:url" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/index.html">
<meta property="og:site_name" content="BattleHeart">
<meta property="og:description" content="为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用，在线程池中，总会有活跃的线程在占用，但是线程池中也会存在没有占用的线程，这些线程处于空闲状态，当有任务的时候会从池子里面拿去一个线程来进行使用，当完成工作后，并没有销毁线程，而是将将线程放回到池子中去。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/1.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/2.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/3.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/5.png">
<meta property="og:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/4.png">
<meta property="og:updated_time" content="2019-08-25T08:18:53.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java线程池原理浅析">
<meta name="twitter:description" content="为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用，在线程池中，总会有活跃的线程在占用，但是线程池中也会存在没有占用的线程，这些线程处于空闲状态，当有任务的时候会从池子里面拿去一个线程来进行使用，当完成工作后，并没有销毁线程，而是将将线程放回到池子中去。">
<meta name="twitter:image" content="https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/1.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="BattleHeart" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
    <link href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/orange/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Java线程池原理浅析 | BattleHeart</title>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdnjs.cloudflare.com/ajax/libs/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/jquery-ui.min.js", "//cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-56ff76c972fc0cf9"></script>




</head></html>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
            <h1 class="header-author"><a href="/">BattleHeart</a></h1>
        </hgroup>

        
        <!-- <p class="header-subtitle">个人博客</p> -->
        <div id="binft"></div>
        <script>
            var binft = function (r) {
                function t() {
                    return b[Math.floor(Math.random() * b.length)]
                }
                function e() {
                    return String.fromCharCode(94 * Math.random() + 33)
                }
                function n(r) {
                    for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {
                        var l = document.createElement("span");
                        l.textContent = e(), l.style.color = t(), n.appendChild(l)
                    }
                    return n
                }
                function i() {
                    var t = o[c.skillI];
                    c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)
                }
                var l = "",
                    o = ["物来顺应,未来不迎", "当时不杂,既过不恋", "欢迎访问个人博客"].map(function (r) {
                        return r + ""
                    }),
                    a = 2,
                    g = 1,
                    s = 5,
                    d = 75,
                    b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],
                    c = {
                        text: "",
                        prefixP: -s,
                        skillI: 0,
                        skillP: 0,
                        direction: "forward",
                        delay: a,
                        step: g
                    };
                i()
            };
            binft(document.getElementById('binft'));
        </script>
        

        
        <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control"
                autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
        </form>
        <div id="local-search-result"></div>
        <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
        <div id="switch-btn" class="switch-btn">
            <div class="icon">
                <div class="icon-ctn">
                    <div class="icon-wrap icon-house" data-idx="0">
                        <div class="birdhouse"></div>
                        <div class="birdhouse_holes"></div>
                    </div>
                    <div class="icon-wrap icon-ribbon hide" data-idx="1">
                        <div class="ribbon"></div>
                    </div>
                    
                    <div class="icon-wrap icon-link hide" data-idx="2">
                        <div class="loopback_l"></div>
                        <div class="loopback_r"></div>
                    </div>
                    
                        
                    <div class="icon-wrap icon-me hide" data-idx="3">
                        <div class="user"></div>
                        <div class="shoulder"></div>
                    </div>
                    
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                    <li>标签</li>
                    
                    <li>友情链接</li>
                    
                        
                    <li>关于我</li>
                    
                    </ul>
                </div>
            </div>
        

                    <div id="switch-area" class="switch-area">
                        <div class="switch-wrap">
                            <section class="switch-part switch-part1">
                                <nav class="header-menu">
                                    <ul>
                                        
                                        <li><a href="/">主页</a>
                                        </li>
                                        
                                        <li><a href="/archives/">所有文章</a>
                                        </li>
                                        
                                        <li><a href="/tags/">标签云</a>
                                        </li>
                                        
                                        <li><a href="/about/">关于我</a>
                                        </li>
                                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                        <a class="fa Email" href="dwlsxj:@126.com"
                                            title="Email"></a>
                                        
                                        <a class="fa GitHub" href="https://github.com/dwlsxj"
                                            title="GitHub"></a>
                                        
                                        <a class="fa 博客园" href="https://www.cnblogs.com/dwlsxj/"
                                            title="博客园"></a>
                                        
                                        <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=31908845"
                                            title="网易云音乐"></a>
                                        
                        </ul>
                    </nav>
                </section>
                
                
                                        <section class="switch-part switch-part2">
                                            <div class="widget tagcloud" id="js-tagcloud">
                                                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELK/">ELK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shiro/">Shiro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li></ul>
                                            </div>
                                        </section>
                                        
                
                
                                        <section class="switch-part switch-part3">
                                            <div id="js-friends">
                                                
                                                <a class="main-nav-link switch-friends-link"
                                                    href="https://www.cnblogs.com/dwlsxj/">BalleHeart</a>
                                                
                                            </div>
                                        </section>
                                        

                
                                        
                                            <section class="switch-part switch-part4">
                                                
                    <div id="js-aboutme">专注于后端开发
                        </div>
                        </section>
                        
            </div>
        </div>
    </header>             
</div>

<!-- 背景音乐 -->
<div style="position:absolute;bottom:100px;left:0px;width:50px">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=289 height=86 src="//music.163.com/outchain/player?type=2&id=304991&auto=1&height=66"></iframe>
</div>   
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">BattleHeart</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">BattleHeart</a></h1>
            </hgroup>
            
            <p class="header-subtitle">个人博客</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="dwlsxj:@126.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/dwlsxj" title="GitHub"></a>
                            
                                <a class="fa 博客园" target="_blank" href="https://www.cnblogs.com/dwlsxj/" title="博客园"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=31908845" title="网易云音乐"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-java-thread-pool-principle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/13/java-thread-pool-principle/" class="article-date">
    <time datetime="2019-06-13T14:58:38.000Z" itemprop="datePublished">2019-06-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java线程池原理浅析
    </h1>
  

        
      </header>
      
      <div class="article-info article-info-post">
        
<div class="article-category tagcloud">
  <a class="article-category-link" href="/categories/个人技术/">个人技术</a>
</div>

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>为了避免频繁重复的创建和销毁线程，我们可以让这些线程进行复用，在线程池中，总会有活跃的线程在占用，但是线程池中也会存在没有占用的线程，这些线程处于空闲状态，当有任务的时候会从池子里面拿去一个线程来进行使用，当完成工作后，并没有销毁线程，而是将将线程放回到池子中去。</p>
<blockquote>
<p>线程池主要解决两个问题：</p>
<p>一是当执行大量异步任务时线程池能够提供很好的性能。</p>
<p>二是线程池提供了一种资源限制和管理的手段，比如可以限制现成的个数，动态新增线程等。</p>
<p>​                                                                                                                                            -《Java并发编程之美》</p>
</blockquote>
<p>上面内容出自《Java并发编程之美》这本书，第一个问题上面已经提到过，线程的频繁创建和销毁是很损耗性能的，但是线程池中的线程是可以复用的，可以较好的提升性能问题，线程池内部是采用了阻塞队列来维护Runnable对象。</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>JDK为我们封装了一套操作多线程的框架Executors，帮助我们可以更好的控制线程池，Executors下提供了一些线程池的工厂方法：</p>
<ul>
<li>newFixedThreadPool：返回固定长度的线程池，线程池中的线程数量是固定的。</li>
<li>newCacheThreadPool：该方法返回一个根据实际情况来进行调整线程数量的线程池，空余线程存活时间是60s</li>
<li>newSingleThreadExecutor：该方法返回一个只有一个线程的线程池。</li>
<li>newSingleThreadScheduledExecutor：该方法返回一个<code>SchemeExecutorService</code>对象，线程池大小为1，<code>SchemeExecutorService</code>接口在<code>ThreadPoolExecutor</code>类和 <code>ExecutorService</code>接口之上的扩展，在给定时间执行某任务。</li>
<li>newSchemeThreadPool：该方法返回一个<code>SchemeExecutorService</code>对象，可指定线程池线程数量。</li>
</ul>
<p>对于核心的线程池来说，它内部都是使用了<code>ThreadPoolExecutor</code>对象来实现的，只不过内部参数信息不一样，我们先来看两个例子：<code>nexFixedThreadPool</code>和<code>newSingleThreadExecutor</code>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的线程池的创建过程可以看到它们都是<code>ThreadPoolExecutor</code>的封装，接下来我们来看一下<code>ThreadPoolExecutor</code>的参数说明：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数描述</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>指定线程池线程的数量</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>指定线程池中线程的最大数量</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>当线程池线程的数量超过corePoolSize的时候，多余的空闲线程存活的时间，如果超过了corePoolSize，在keepAliveTime的时间之后，销毁线程</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime的单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>工作队列，将被提交但尚未执行的任务缓存起来</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂，用于创建线程，不指定为默认线程工厂DefaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<p>其中workQueue代表的是提交但未执行的队列，它是BlockingQueue接口的对象，用于存放Runable对象，主要分为以下几种类型：</p>
<ul>
<li><p>直接提交的队列：<code>SynchronousQueue</code>队列，它是一个没有容量的队列，前面我有对其进行讲解，当线程池进行入队offer操作的时候，本身是无容量的，所以直接返回false，并没有保存下来，而是直接提交给线程来进行执行，如果没有空余的线程则执行拒绝策略。</p>
</li>
<li><p>有界的任务队列：可以使用<code>ArrayBlockingQueue</code>队列，因为它内部是基于数组来进行实现的，初始化时必须指定容量参数，当使用有界任务队列时，当有任务进行提交时，线程池的线程数量小于corePoolSize则创建新的线程来执行任务，当线程池的线程数量大于corePoolSize的时候，则将提交的任务放入到队列中，当提交的任务塞满队列后，如果线程池的线程数量没有超过maximumPoolSize，则创建新的线程执行任务，如果超过了maximumPoolSize则执行拒绝策略。</p>
</li>
<li><p>无界的任务队列：可以使用<code>LinkedBlockingQueue</code>队列，它内部是基于链表的形式，默认队列的长度是<code>Integer.MAX_VALUE</code>，也可以指定队列的长度，当队列满时进行阻塞操作，当然线程池中采用的是<code>offer</code>方法并不会阻塞线程，当队列满时则返回false，入队成功则则返回true，当使用<code>LinkedBlockingQueue</code>队列时，有任务提交到线程池时，如果线程池的数量小于corePoolSize，线程池会产生新的线程来执行任务，当线程池的线程数量大于corePoolSize时，则将提交的任务放入到队列中，等待执行任务的线程执行完之后进行消费队列中的任务，若后续仍有新的任务提交，而没有空闲的线程时，它会不断往队列中入队提交的任务，直到资源耗尽。</p>
</li>
<li><p>优先任务队列：t有限任务队列是带有执行优先级的队列，他可以使用<code>PriorityBlockingQueue</code>队列，可以控制任务的执行先后顺序，它是一个无界队列，该队列可以根据任务自身的优先级顺序先后执行，在确保性能的同时，也能有很好的质量保证。</p>
</li>
</ul>
<p>上面讲解了关于线程池内部都是通过<code>ThreadPoolExecutor</code>来进行实现的，那么下面我以一个例子来进行源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>), <span class="keyword">new</span> CustomThreadFactory());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"由线程："</span> + Thread.currentThread().getName() + <span class="string">"执行任务完成"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了一个线程池，线程池初始化的corePoolSize为5，也就是线程池中线程的数量为5，最大线程maximumThreadPoolSize为10，空余的线程存活的时间是60s，使用ArrayBlockingQueue来作为阻塞队列，这里还发现我自定义了<code>ThreadFactory</code>线程池工厂，这里我真是针对线程创建的时候输出线程池的名称，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程池构造工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        String name = namePrefix + threadNumber.getAndIncrement();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                name,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程池创建，线程名称为："</span> + name);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码和<code>DefaultThreadFactory</code>一样，只是在<code>newThread</code>新建线程的动作的时候输出了线程池的名称，方便查看线程创建的时机，上面<code>main</code>方法中提交了15个任务，调用了<code>execute</code>方法来进行提交任务，在分析<code>execute</code>方法之前我们先了解一下线程的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设Integer类型是32位的二进制表示。</span></span><br><span class="line"><span class="comment">//高3位代表线程池的状态，低29位代表的是线程池的数量</span></span><br><span class="line"><span class="comment">//默认是RUNNING状态，线程池的数量为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//线程个数位数，表示的Integer中除去最高的3位之后剩下的位数表示线程池的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程池的线程的最大数量</span></span><br><span class="line"><span class="comment">//这里举例是32为机器，表示为00011111111111111111111111111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程池的状态</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">//11100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//接受新任务并且处理阻塞队列里面任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//00000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//拒绝新任务但是处理阻塞队列的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//00100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//拒接新任务并且抛弃阻塞队列里面的任务，同时会中断正在处理的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//01000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//所有任务都执行完(包括阻塞队列中的任务)后当线程池活动线程数为0，将要调用terminated方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//01100000000000000000000000000000</span></span><br><span class="line"><span class="comment">//终止状态，terminated方法调用完成以后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>通过上面内容可以看到ctl其实存放的是线程池的状态和线程数量的变量，默认是<code>RUNNING</code>，也就是<code>11100000000000000000000000000000</code>，这里我们来假设运行的机器上的Integer的是32位的，因为有些机器上可能Integer并不是32位，下面COUNT_BITS来控制位数，也就是先获取Integer在该平台上的位数，比如说是32位，然后32位-3位=29位，也就是低29位代表的是现成的数量，高3位代表线程的状态，可以清晰看到下面的线程池的状态都是通过低位来进行向左位移的操作的，除了上面的变量，还提供了操作线程池状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作ctl变量，主要是进行分解或组合线程数量和线程池状态。</span></span><br><span class="line"><span class="comment">// 获取高3位，获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取低29位，获取线程池中线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 组合ctl变量，rs=runStatue代表的是线程池的状态，wc=workCount代表的是线程池线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//指定的线程池状态c小于状态s</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定的线程池状态c至少是状态s</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程池是否运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS增加线程池线程数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS减少线程池线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将线程池的线程数量进行较少操作，如果竞争失败直到竞争成功为止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下来我们看一下<code>ThreadPoolExecutor</code>对象下的<code>execute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 判断提交的任务是不是为空，如果为空则抛出NullPointException异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  	<span class="comment">// 获取线程池的状态和线程池的数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  	<span class="comment">// 如果线程池的数量小于corePoolSize，则进行添加线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      	<span class="comment">//添加线程修改线程数量并且将command作为第一个任务进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">// 获取最新的状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果线程池的状态是RUNNING，将命令添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      	<span class="comment">//二次检查线程池状态和线程数量</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">      	<span class="comment">//线程不是RUNNING状态，从队列中移除当前任务，并且执行拒绝策略。</span></span><br><span class="line">      	<span class="comment">//这里说明一点，只有RUNNING状态的线程池才会接受新的任务，其余状态全部拒绝。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">      	<span class="comment">//如果线程池的线程数量为空时，代表线程池是空的，添加一个新的线程。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果队列是满的，或者是SynchronousQueue队列时，则直接添加新的线程执行任务，如果添加失败则进行拒绝</span></span><br><span class="line">  	<span class="comment">//可能线程池的线程数量大于maximumPoolSize则采取拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析execute方法总结以下几点：</p>
<ol>
<li>当线程池中线程的数量小于<code>corePoolSize</code>时，直接添加线程到线程池并且将当前任务做为第一个任务执行。</li>
<li>如果线程池的状态的是<code>RUNNING</code>，则可以接受任务，将任务放入到阻塞队列中，内部进行二次检查，有可能在运行下面内容时线程池状态已经发生了变化，在这个时候如果线程池状态变成不是<code>RUNNING</code>，则将当前任务从队列中移除，并且进行拒绝策略。</li>
<li>如果阻塞队列已经满了或者<code>SynchronousQueue</code>这种特殊队列无空间的时候，直接添加新的线程执行任务，当线程池的线程数量大于<code>maximumPoolSize</code>时相应拒绝策略。</li>
<li>入队操作用的是<code>offer</code>方法，该方法不会阻塞队列，如果队列已经满时或超时导致入队失败，返回false，如果入队成功返回true。</li>
</ol>
<p>针对上面例子源码我们来做一下分析，我们源码中阻塞队列采用的是<code>ArrayBlockingQueue</code>队列，并且指定队列的长度是5，我们看下面提交的线程池的任务是15个，而且corePoolSize设置的是5个核心线程，最大线程数（maximumPoolSzie）是10个（包括核心线程数），假设所有任务都同时提交到了线程池中，其中有5个任务会被提交到线程中作为第一个任务进行执行，会有5个任务被添加到阻塞队列中，还有5个任务提交到到线程池中的时候发现阻塞队列已经满了，这时候会直接提交任务，发现当前线程数是5小于最大线程数，可以进行新建线程来执行任务。</p>
<p><img src="/2019/06/13/java-thread-pool-principle/1.png" alt="1"></p>
<p>这里我们只是假设任务全部提交，因为我们在任务中添加了Thread.sleep睡眠一会，在for循环结束提交任务之后可能才会结束掉任务的睡眠执行任务后面内容，所以可以看做是全部提交任务，但是没有任务完成，如果有任务完成的话，可能就不会是触发最大的线程数，有可能就是一个任务完成后从队列取出来，然后另一个任务来的时候可以添加到队列中，上图中可以看到，有5个核心core线程在执行任务，任务队列中有5个任务在等待空余线程执行，而还有5个正在执行的线程，核心线程是指在corePoolSize范围的线程，而非核心线程指的是大于corePoolSize但是小于等于MaximumPoolSize的线程，就是这些非核心线程并不是一直存活的线程，它会跟随线程池指定的参数来进行销毁，我们这里指定了60s后如果没有任务提交，则会进行销毁操作，当然工作线程并不指定那些线程必须回收那些线程就必须保留，是根据从队列中获取任务来决定，如果线程获取任务时发现线程池中的线程数量大于corePoolSize，并且阻塞队列中为空时，则阻塞队列会阻塞60s后如果还有没有任务就返回false，这时候会释放线程，调用<code>processWorkerExit</code>来处理线程的退出，接下来我们来分析下<code>addWorker</code>都做了什么内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">//获取线程池的状态和线程池线程的数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      	<span class="comment">//单独获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查队列是否只在必要时为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;						<span class="comment">//线程池的状态是SHUTDOWN、STOP、TIDYING、TERMINATED</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;				<span class="comment">//可以看做是rs!=SHUTDOWN,线程池状态为STOP、TIDYING、TERMINATED</span></span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;			<span class="comment">//可以看做firstTask!=null，并且rs=SHUTDOWN</span></span><br><span class="line">               ! workQueue.isEmpty()))	<span class="comment">//可以看做rs=SHUTDOWN，并且workQueue.isEmpty()队列为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">//循环CAS增加线程池中线程的个数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">//获取线程池中线程个数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">          	<span class="comment">//如果线程池线程数量超过最大线程池数量，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                <span class="comment">//如果指定使用corePoolSize作为限制则使用corePoolSize，反之使用maximumPoolSize，最为工作线程最大线程线程数量，如果工作线程大于相应的线程数量则直接返回。</span></span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          	<span class="comment">//CAS增加线程池中线程的数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">              	<span class="comment">//跳出增加线程池数量。</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">          	<span class="comment">//如果修改失败，则重新获取线程池的状态和线程数量</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">          	<span class="comment">//如果最新的线程池状态和原有县城出状态不一样时，则跳转到外层retry中，否则在内层循环重新进行CAS</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//工作线程是否开始启动标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">//工作线程添加到线程池成功与否标志</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//创建一个Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">      	<span class="comment">//获取worker中的线程，这里线程是通过ThreadFactory线程工厂创建出来的，详细看下面源码信息。</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">      	<span class="comment">//判断线程是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//添加独占锁，为添加worker进行同步操作，防止其他线程同时进行execute方法。</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池的状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">								<span class="comment">//如果线程池状态为RUNNING或者是线程池状态为SHUTDOWN并且第一个任务为空时，当线程池状态为SHUTDOWN时，是不允许添加新任务的，所以他会从队列中获取任务。</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                  	<span class="comment">//添加worker到集合中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                  	<span class="comment">//跟踪最大的线程池数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  	<span class="comment">//添加worker成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//如果添加worker成功就启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">//如果没有启动，w不为空就已出worker，并且线程池数量进行减少。</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面<code>addWorker</code>方法可以分为两个部分来进行讲解，第一部分是对线程池中线程数量的通过CAS的方式进行增加，其中第一部分中上面有个if语句，这个地方着重分析下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">    ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">       firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">       ! workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>可以看成下面的样子，将<code>！</code>放到括号里面，变成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">     (rs != SHUTDOWN ||</span><br><span class="line">       firstTask != <span class="keyword">null</span> ||</span><br><span class="line">       workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程池的状态是SHUTDOWN、STOP、TIDYING、TERMINATED<ul>
<li>当线程池状态是STOP、TIDYING、TERMINATED时，这些状态的时候不需要进行线程的添加和启动操作，因为如果是上面的状态，其实线程池的线程正在进行销毁操作，意味着线程调用了shutdownNow等方法。</li>
<li>如果线程池状态为SHUTDOWN并且第一个任务不为空时，不接受新的任务，直接返回false，也就是说SHUTDOWN的状态，不会接受新任务，只会针对队列中未完成的任务进行操作。</li>
<li>当线线程池状态为SHUTDOWN并且队列为空时，直接返回不进行任务添加。</li>
</ul>
</li>
</ul>
<p>上半部分分为内外两个循环，外循环对线程池状态的判断，用于判断是否需要添加工作任务线程，通过上面讲的内容进行判断，后面内循环则是通过CAS操作增加线程数，如果指定了<code>core</code>参数为true，代表线程池中线程的数量没有超过<code>corePoolSize</code>，当指定为false时，代表线程池中线程数量达到了<code>corePoolSize</code>，并且队列已经满了，或者是<code>SynchronousQueue</code>这种无空间的队列，但是还没有达到最大的线程池<code>maximumPoolSize</code>，所以它内部会根据指定的<code>core</code>参数来判断是否已经超过了最大的限制，如果超过了就不能进行添加线程了，并且进行拒绝策略，如果没有超过就增加线程数量。</p>
<p>第二部分主要是把任务添加到worker中，并启动线程，这里我们先来看一下Worker对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里发现它是实现了AQS，是一个不可重入的独占锁模式</span></span><br><span class="line"><span class="comment">// 并且它还集成了Runable接口，实现了run方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 执行任务的线程，通过ThreadFactory创建 */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 初始化第一个任务*/</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个线程完成任务的数量 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先现将state值设置为-1，因为在AQS中state=0代表的是锁没有被占用，而且在线程池中shutdown方法会判断能否争抢到锁，如果可以获得锁则对线程进行中断操作，如果调用了shutdownNow它会判断state&gt;=0会被中断。</span></span><br><span class="line"><span class="comment">     * firstTask第一个任务，如果为空则会从队列中获取任务，后面runWorker中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 委托调用外部的runWorker方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//是否独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">		<span class="comment">//这里就是上面shutdownNow中调用的线程中断的方法，getState()&gt;=0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Worker是一个实现了AQS的锁，它是一个不可重入的独占锁，并且他也实现了<code>Runnable</code>接口，实现了<code>run</code>方法，在构造函数中将AQS的<code>state</code>设置为<code>-1</code>，为了避免线程还没有进入<code>runWorker</code>方法前，就调用了<code>shutdown</code>或<code>shutdownNow</code>方法，会被中断，设置为-1则不会被中断。后面我们看到<code>run</code>方法，它调用的是<code>ThreadPoolExecutor</code>的<code>runWorker</code>方法，我们这里回想一下，在<code>addWorker</code>方法中，添加<code>worker</code>到<code>HashSet&lt;Worker&gt;</code>中后，他会将<code>workerAdded</code>设置为true，代表添加<code>worker</code>成功，后面有调用了下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">    t.start();</span><br><span class="line">    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个t代表的就是在Worker构造函数中的使用<code>ThreadFactory</code>创建的线程，并且将自己（Worker自己）传递了当前线程，创建的线程就是任务线程，任务线程启动的时候会调用<code>Worker</code>下的<code>run</code>方法，<code>run</code>方法内部又委托给外部方法<code>runWorker</code>来进行操作，它的参数传递的是调用者自己，<code>Worker</code>中的<code>run</code>方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>); 			<span class="comment">//this指Worker对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单画一张图来表示下调用的逻辑。</p>
<p><img src="/2019/06/13/java-thread-pool-principle/2.png" alt="2"></p>
<p>整体的逻辑是先进行创建线程，线程将<code>Worker</code>设置为执行程序，并将线程塞到<code>Worker</code>中，然后再addWorker中将Worker中的线程取出来，进行启动操作，启动后他会调用Worker中的run方法，然后run方法中将调用ThreadPoolExecutor的runWorker，然后runWorker又会调用Worker中的任务firstTask，这个fistTask是要真正执行的任务，也是用户自己实现的代码逻辑。</p>
<p>接下来我们就要看一下runWorker方法里面具体内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//调用者也就是Worker中的线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">  	<span class="comment">//获取Worker中的第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">  	<span class="comment">//将Worker中的任务清除代表执行了第一个任务了，后面如果再有任务就从队列中获取。</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  	<span class="comment">//这里还记的我们在new Worker的时候将AQS的state状态设置为-1，这里先进行解锁操作，将state设置为0</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//循环进行获取任务，如果第一个任务不为空，或者是如果第一个任务为空，从任务队列中获取任务，如果有任务则返回获取的任务信息，如果没有任务可以获取则进行阻塞，阻塞也分两种第一种是阻塞直到任务队列中有内容，第二种是阻塞队列一定时间之后还是没有任务就直接返回null。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//先获取worker的独占锁，防止其他线程调用了shutdown方法。</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池正在停止，确保线程是被中断的，如果没有则确保线程不被中断操作。</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || <span class="comment">//如果线程池状态为STOP、TIDYING、TERMINATED直接拒绝任务中断当前线程</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">//执行任务之前做一些操作，可进行自定义</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//运行任务在这里喽。</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	                  <span class="comment">//执行任务之后做一些操作，可进行自定义</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              	<span class="comment">//将任务清空为了下次任务获取</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">              	<span class="comment">//统计当前Worker完成了多少任务</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">              	<span class="comment">//独占锁释放</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">//处理Worker的退出操作，执行清理工作。</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到如果Worker是第一次被启动，它会从Worker中获取firstTask任务来执行，然后执行成功后，它会getTask()来从队列中获取任务，这个地方比较有意思，它是分情况进行获取任务的，我们都直到BlockingQueue中提供了几种从队列中获取的方法，这个getTask中使用了两种方式，第一种是使用poll进行获取队列中的信息，它采用的是过一点时间如果队列中仍没有任务时直接返回null，然后还有一个就是take方法，take方法是如果队列中没有任务则将当前线程进行阻塞，等待队列中有任务后，会通知等待的队列线程进行消费任务，让我们看一下getTask方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">//poll获取超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">//获取线程池的状态和线程数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      	<span class="comment">//获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池状态大于等于SHUTDOWN</span></span><br><span class="line">      	<span class="comment">//1.线程池如果是大于STOP的话减少工作线程池数量</span></span><br><span class="line">      	<span class="comment">//2.如果线程池状态为SHUTDOW并且队列为空时，代表队列任务已经执行完，返回null，线程数量减少1</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//获取线程池数量。</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果allowCoreThreadTimeOut为true，则空闲线程在一定时间未获得任务会清除</span></span><br><span class="line">      	<span class="comment">//或者如果线程数量大于corePoolSize的时候会进行清除空闲线程</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">				<span class="comment">//1.如果线程池数量大于最大的线程池数量或者对（空余线程进行清除操作并且poll超时了，意思是队列中没有内容了，导致poll间隔一段时间后没有获取内容超时了。</span></span><br><span class="line">      	<span class="comment">//2.如果线程池的数量大于1或者是队列已经是空的</span></span><br><span class="line">      	<span class="comment">//总之意思就是当线程池的线程池数量大于corePoolSize，或指定了allowCoreThreadTimeOut为true，当队列中没有数据或者线程池数量大于1的情况下，尝试对线程池的数量进行减少操作，然后返回null，用于上一个方法进行清除操作。</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//如果timed代表的是清除空闲线程的意思</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :	<span class="comment">//等待一段时间如果没有获取到返回null。</span></span><br><span class="line">                workQueue.take();					<span class="comment">//阻塞当前线程</span></span><br><span class="line">          	<span class="comment">//如果队列中获取到内容则返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">						<span class="comment">//如果没有获取到超时了则设置timeOut状态</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>工作线程调用getTask从队列中进行获取任务。</li>
<li>如果指定了allowCoreThreadTimeOut或线程池线程数量大于corePoolSize则进行清除空闲多余的线程，调用阻塞队列的poll方法，在指定时间内如果没有获取到任务直接返回false。</li>
<li>如果线程池中线程池数量小于corePoolSize或者allowCoreThreadTimeOut为false默认值，则进行阻塞线程从队列中获取任务，直到队列有任务唤醒线程。</li>
</ol>
<p>我们还记得第一张图中有标记出来是core线程和普通线程，其实这样标记不是很准确，准确的意思是如果线程池的数量超过了corePoolSize并且没有特别指定allowCoreThreadTimeOut的情况下，它会清除掉大于corePoolSize并且小于等于maximumPoolSize的一些线程，标记出core线程的意思是有corePoolSize不会被清除，但是会清除大于corePoolSize的线程，也就是线程池中的线程对获取任务的时候进行判断，也就是getTask中进行判断，如果当前线程池的线程数量大于corePoolSize就使用poll方式获取队列中的任务，当过一段时间还没有任务就会返回null，返回null之后设置timeOut=true，并且获取getTask也会返回null，到此会跳到调用者runWorker方法中，一直在<code>while (task != null || (task = getTask()) != null)</code>此时的getTask返回null跳出while循环语句，设置completedAbruptly = false，表示不是突然完成的而是正常完成，退出后它会执行finally的<code>processWorkerExit(w, completedAbruptly)</code>，执行清理工作。我们来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) 				<span class="comment">// 如果突然完成则调整线程数量</span></span><br><span class="line">        decrementWorkerCount();		<span class="comment">// 减少线程数量1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();														<span class="comment">//获取锁,同时只有一个线程获得锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;	<span class="comment">//统计整个线程池完成的数量</span></span><br><span class="line">        workers.remove(w);											<span class="comment">//将完成任务的worker从HashSet中移除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();											<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//尝试设置线程池状态为TERMINATED</span></span><br><span class="line">  	<span class="comment">//1.如果线程池状态为SHUTDOWN并且线程池线程数量与工作队列为空时，修改状态。</span></span><br><span class="line">  	<span class="comment">//2.如果线程池状态为STOP并且线程池线程数量为空时，修改状态。</span></span><br><span class="line">    tryTerminate();								</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 获取线程池的状态和线程池的数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  	<span class="comment">// 如果线程池的状态小于STOP，也就是SHUTDOWN或RUNNING状态</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">      	<span class="comment">//如果不是突然完成，也就是正常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">          	<span class="comment">//如果指定allowCoreThreadTimeOut=true(默认false)则代表线程池中有空余线程时需要进行清理操作，否则线程池中的线程应该保持corePoolSize</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">          	<span class="comment">//这里判断如果线程池中队列为空并且线程数量最小为0时，将最小值调整为1，因为队列中还有任务没有完成需要增加队列，所以这里增加了一个线程。</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//如果当前线程数效益核心个数，就增加一个Worker</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码可以得出，如果线程数超过核心线程数后，在<code>runWorker</code>中就不会等待队列中的消息，而是会进行清除操作，上面的清除代码首先是先对线程池的数量进行较少操作，其次是统计整个线程池中完成任务的数量，然后就是尝试修改线程池的状态由<code>SHUTDOWN-&gt;TIDYING-&gt;TERMINATED</code>或者是由<code>STOP-&gt;TIDYING-&gt;TERMINATED</code>，修改线程池状态为<code>TERMINATED</code>，需要有两个条件：</p>
<ol>
<li><p>当线程池线程数量和工作队列为空，并且线程池的状态为<code>SHUTDOWN</code>时，才会将状态进行修改，修改的过程是<code>SHUTDOWN-&gt;TIDYING-&gt;TERMINATED</code></p>
</li>
<li><p>当线程池的状态为<code>STOP</code>并且线程池数量为空时，才会尝试修改状态，修改过程是<code>STOP-&gt;TIDYING-&gt;TERMINATED</code></p>
</li>
</ol>
<p>如果设置为<code>TERMINATED</code>状态，还需要调用条件变量<code>termination</code>的<code>signalAll()</code>方法来唤醒所有因为调用<code>awaitTermination</code>方法而被阻塞的线程，换句话说当调用<code>awaitTermination</code>后，只有线程池状态变成TERMINATED才会被唤醒。</p>
<p>接下来我们就来分析一下这个<code>tryTerminate</code>方法，看一下他到底符不符合我们上述说的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">// 获取线程池的状态和线程池的数量组合状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      	<span class="comment">//这里单独下面进行分析，这里说明两个问题，需要反向来想这个问题。</span></span><br><span class="line">      	<span class="comment">//1.如果线程池状态STOP则不进入if语句</span></span><br><span class="line">      	<span class="comment">//2.如果线程池状态为SHUTDOWN并且工作队列为空时，不进入if语句</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">//如果线程池数量不为空时，进行中断操作。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//修改状态为TIDYING，并且将线程池的数量进行清空</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//执行一些逻辑，默认是空的</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  	<span class="comment">//修改状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                  	<span class="comment">//唤醒调用awaitTermination方法的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们单独将上面的if语句摘出来进行分析，将上面的第一个if判断进行修改如下，可以看到return在else里面，这时候内部if判断进行转换，转换成如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isRunning(c) &amp;&amp;			</span><br><span class="line">    !runStateAtLeast(c, TIDYING) &amp;&amp; <span class="comment">//只能是SHUTDOWN和STOP</span></span><br><span class="line">    (runStateOf(c) != SHUTDOWN ||  workQueue.isEmpty()))&#123;</span><br><span class="line">    <span class="comment">//这里执行逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐一分析分析内容如下：</p>
<ol>
<li><p><code>!isRunning(c)</code>代表不是RUNNING，则可能的是<code>SHUTDOWN</code>，<code>STOP</code>，<code>TIDYING</code>，<code>TERMINATED</code>这四种状态</p>
</li>
<li><p>中间的连接符是并且的意思，跟着<code>runStateAtLeast(c, TIDYING)</code>这句话的意思是至少是<code>TIDYING</code>，<code>TERMINATED</code>这两个，反过来就是可能是<code>RUNNING</code>，<code>SHUTDOWN</code>，<code>STOP</code>，但是前面已经判断了不能是<code>RUNINNG</code>状态，所以前面两个连在一起就是只能是状态为<code>SHUTDOWN</code>，<code>STOP</code></p>
</li>
<li><p><code>runStateOf(c) != SHUTDOWN ||  workQueue.isEmpty()</code>当前面的状态是<code>SHUTDOWN</code>时，则会出发<code>workQueue.isEmpty()</code>,连在一起就是状态是<code>SHUTDOWN</code>并工作队列为空，当线程池状态为<code>STOP</code>时，则会进入到<code>runStateOf(c) != SHUTDOWN</code>，直接返回true，就代表线程池状态为<code>STOP</code></p>
</li>
</ol>
<p>后面还有一个语句一个if语句将其转换一下逻辑就是下面的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (workerCountOf(c) == <span class="number">0</span>) &#123; </span><br><span class="line"> 		<span class="comment">//执行下面的逻辑   </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们也进行转换下，就可以看出来当线程池的数量为空时，才会进行下面的逻辑，下面的逻辑就是修改线程池状态为<code>TERMINATED</code>，两个连在一起就是上面分析的修改状态为<code>TERMINATED</code>的条件，这里画一张图来表示线程池状态的信息：</p>
<p><img src="/2019/06/13/java-thread-pool-principle/3.png" alt="3"></p>
<p>其实上面图中我们介绍了关于从<code>SHUTDOWN</code>或<code>STOP</code>到<code>TERMINATED</code>的变化，没有讲解关于如何从<code>RUNNING</code>状态转变成<code>SHUTDOWN</code>或<code>STOP</code>状态，其实是调用了<code>shutdown()</code>或<code>shutdownNow</code>方法对其进行状态的变换，下面来看一下<code>shutdown</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//获取全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      	<span class="comment">//设置线程池状态为SHUTDOWN，如果状态已经是大于等于SHUTDOWN则直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">      	<span class="comment">//如果线程没有设置中断标识并且线程没有运行则设置中断标识</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">      	<span class="comment">//空的可以实现的内容</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//尝试修改线程池状态为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先对当前线程进行权限检测，查看是否设置了安全管理器，如果设置了则要看当前调用shutdown的线程有没有权限都关闭线程的权限，如果有权限还要看是否有中断工作现成的权限，如果没有权限则抛出<code>SecurityException</code>或<code>NullPointException</code>异常。</li>
<li>设置线程池状态为SHUTDOWN，如果状态已经是大于等于SHUTDOWN则直接返回</li>
<li>如果线程没有设置中断标识并且线程没有运行则设置中断标识</li>
<li>尝试修改线程池状态为TERMINATED</li>
</ol>
<p>接下来我们来看一下<code>advanceRunState</code>内容如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      	<span class="comment">//获取线程池状态和线程池的线程数量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||		<span class="comment">//如果线程池的状态&gt;=SHUTDOWN</span></span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))	<span class="comment">//设置线程池状态为SHUTDOWN</span></span><br><span class="line">          	<span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">break</span>;										</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当线程池的状态&gt;=SHUTDOWN，直接返回</li>
<li>如果线程池状态为RUNNING，设置线程池状态为SHUTDOWN，设置成功则返回</li>
</ol>
<p><code>interruptIdleWorkers</code>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//获取全局锁，同时只能有一个线程能够调用shutdown方法</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//遍历工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">          	<span class="comment">//如果当前线程没有设置中断标志并且可以获取Worker自己的锁</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//设置中断标志</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//执行一次，清理空闲线程。</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到当我们调用shutdown方法的时候，只是将空闲的线程给设置了中断标识，也就是活跃正在执行任务的线程并没有设置中断标识，直到将任务全部执行完后才会逐步清理线程操作，我们还记的在getTask中的方法里面有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">    decrementWorkerCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否是状态&gt;=SHUTDOWN，并且队列为空时，将线程池数量进行减少操作，内部进行CAS操作，直到CAS操作成功为止，并且返回null，返回null后，会调用<code>processWorkerExit(w, false);</code>清理Workers线程信息，并且尝试将线程设置为<code>TERMINATED</code>状态，上面是对所有<code>shutdown</code>方法的分析，下面来看一下<code>shutdownNow</code>方法并且比较两个之间的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//权限检查</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      	<span class="comment">//设置线程池状态为STOP，如果状态已经是大于等于STOP则直接返回</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">      	<span class="comment">//这里是和SHUTDOWN区别的地方，这里是强制进行中断操作</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">      	<span class="comment">//将为完成任务复制到list集合中</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//尝试修改线程池状态为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shutdownNow</code>方法返回了未完成的任务信息列表<code>tasks = drainQueue();</code>，其实该方法和<code>shutdown</code>方法主要的区别在于一下几点内容：</p>
<ol>
<li><code>shutdownNow</code>方法将线程池状态设置为<code>STOP</code>，而<code>shutdown</code>则将状态修改为<code>SHUTDOWN</code></li>
<li><code>shutdownNow</code>方法将工作任务进行中断操作，也就是说如果工作线程在工作也会被中断，而<code>shutdown</code>则是先尝试获取锁如果获得锁成功则进行中断标志设置，也就是中断操作，如果没有获取到锁则等待进行完成后自动退出。</li>
<li><code>shutdownNow</code>方法返回未完成的任务列表。</li>
</ol>
<p>下面代码是<code>shutDownNow</code>的<code>interruptWorkers</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">          	<span class="comment">//直接进行中断操作。</span></span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用了<code>Worker</code>的<code>interruptIfStarted</code>方法，方法内部是针对线程进行中断操作，但是中断的前提条件是AQS的state状态必须大于等于0，如果状态为-1的则不会被中断，但是如果任务运行起来的时候在<code>runWorker</code>中则不会执行任务，因为线程池状态为<code>STOP</code>，如果线程池状态为STOP则会中断线程，下面代码是Worker中的<code>interruptIfStarted</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">  	<span class="comment">//当前Worker锁状态大于等于0并且线程没有被中断</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略如下：</p>
<ol>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作</li>
<li>CallerRunsPolicy策略：只要线程池没有关闭线程池状态是RUNNING状态，该略略直接调用线程中运行当前被丢弃的任务</li>
<li>DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的第一个任务，并尝试再次提交任务</li>
<li>DiscardPolicy策略：该策略默默丢弃无法处理的任务，不予任何处理。</li>
</ol>
<p>​    <img src="/2019/06/13/java-thread-pool-principle/5.png" alt="5"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先先上一张图，针对这张图来进行总结：</p>
<p><img src="/2019/06/13/java-thread-pool-principle/4.png" alt="4"></p>
<ol>
<li>主线程进行线程池的调用，线程池执行execute方法</li>
<li>线程池通过<code>addWorker</code>进行创建线程，并将线程放入到线程池中，这里我们看到第二步是将线程添加到核心线程中，其实线程池内部不分核心线程和非核心线程，只是根据corePoolSize和maximumPoolSize设置的大小来进行区分，因为超过corePoolSize的线程会被回收，至于回收那些线程，是根据线程获取任务的时候进行判断，当前线程池数量大于corePoolSize，或者指定了<code>allowCoreThreadTimeOut</code>为true，则他等待一定时间后会返回，不会一直等待</li>
<li>当线程池的数量达到corePoolSize时，线程池首先会将任务添加到队列中</li>
<li>当队列中任务也达到了队列设置的最大值时，它会创建新的线程，注意的是此时的线程数量已经超过了corePoolSize，但是没有达到maximumPoolSize最大值。</li>
<li>当线程池的线程数量达到了maximumPoolSize，则会相应拒绝策略。</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/06/13/java-thread-pool-principle/">Java线程池原理浅析</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">BattleHeart</a></p>
        <p><span>发布时间:</span>2019-06-13, 22:58:38</p>
        
            <p><span class="post-meta-item-text">字数统计:</span> <span class="post-count">10.5k字</span></p>
            <p><span class="post-meta-item-text">  阅读时长:</span><span class="post-count">40分</span></p>
        
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/06/13/java-thread-pool-principle/" title="Java线程池原理浅析">https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/</a>
            <span class="copy-path" data-clipboard-text="原文: https://www.battleheart.cn/2019/06/13/java-thread-pool-principle/　　作者: BattleHeart" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/08/24/Semaphore/">
                    Semaphore信号量之AQS共享锁-非公平模式
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/06/02/reentrantlock-principle-fair/">
                    图解AQS原理之ReentrantLock详解-公平锁
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是线程池？"><span class="toc-number">1.</span> <span class="toc-text">什么是线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理分析"><span class="toc-number">2.</span> <span class="toc-text">原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝策略"><span class="toc-number">2.1.</span> <span class="toc-text">拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>







    
        <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80OTM1NC8yNTg0Ng==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/08/24/Semaphore/" title="上一篇: Semaphore信号量之AQS共享锁-非公平模式">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/06/02/reentrantlock-principle-fair/" title="下一篇: 图解AQS原理之ReentrantLock详解-公平锁">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/Semaphore/">Semaphore信号量之AQS共享锁-非公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/java-thread-pool-principle/">Java线程池原理浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/reentrantlock-principle-fair/">图解AQS原理之ReentrantLock详解-公平锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/reentrantlock-principle-nonfairsync/">图解AQS原理之ReentrantLock详解-非公平锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/18/synchronousqueue-principle-unfair-pattern/">SynchronousQueue原理详解-非公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/04/synchronousqueue-principle-fair-pattern/">SynchronousQueue原理详解-公平模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/stack-working-principle/">系统栈的工作原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/git-server-transfer/">git仓库迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/LinkedBlockingQueue-Principle/">LinkedBlockingQueue原理解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/arrayblockingqueue-principle/">ArrayBlockingQueue原理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/block-and-lock-free/">阻塞算法和非阻塞算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/you-have-to-know-the-concept-of-multithreading/">你必须知道的多线程几个概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/spring-boot-and-dubbo-starter/">SpringBoot快速整合dubbo</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/22/how-use-synchronized/">深入理解synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-autoconfiguration-fashion/">SpringBoot自动装配详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/24/spring-boot-thymeleaf-and-shiro/">spring-boot与thymeleaf模板整合shiro标签内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/26/use-hexo-to-build-a-blog/">使用Hexo搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/spring-boot-admin-monitor/">Spring Boot Admin监控系统搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/logback-with-elk/">使用Logback输出日志到ELK</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/elk-environment-construction-in-windows/">Windows环境下搭建ELK环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-sleuth/">分布式服务跟踪之Spring Cloud Sleuth快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/">集群监控Spring Cloud Turbine消息队列篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/quick-start-spring-cloud-turbine/">集群监控之Spring Cloud Turbine快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-zuul/">API网关服务-Spring Cloud Zuul快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-config/">配置管理中心Spring Cloud Config快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-hystrix/">服务容错保护Spring Cloud Hystrix之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/quick-start-spring-cloud-ribbon/">客户端负载均衡Spring Cloud Ribbon之快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/spring-cloud-tutorial-eureka/">服务治理-Spring Cloud Eureka</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/java-class-loader/">Java类加载器详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/23/maven-skeleton-generation/">一文搭建Maven骨架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/20/how-dynamic-agents-work/">动态代理的工作原理简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/hello-world/">我的blog之旅又要开始了</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-5-remote/">带你走进git-远程仓库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-4-rewriting-history/">带你走进git-重写历史记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/git-learning-3-revert-operation/">带你走进git-撤销修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-study-2/">带你走进git-工作区、暂存区、分支</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/13/git-config/">带你走进git-基础配置</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2020 BattleHeart
            </div>
            <div class="footer-right">
                <a href="http://battleHeart.cn/" target="_blank" title="快速、简洁且高效的博客框架">BattleHeart</a>  Blog 
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
        <div>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
        </div>
    </div>
</footer>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("08/10/2018 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
    </div>
    
<script data-main="/js/main.js" src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>



</html>
<!-- 雪花特效 -->
<script type="text/javascript" src="\js\snow.js"></script>
<!-- 代码雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript" src="/js/DigitalRain.js"></script>
<!--动态线条背景-->
<script type="text/javascript" color="220,220,220" opacity='0.7' zIndex="-2" count="200"
  src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
  </script>
<script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"></script>