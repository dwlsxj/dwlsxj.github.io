<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring Boot Admin监控系统搭建</title>
      <link href="/2018/10/01/spring-boot-admin-monitor/"/>
      <url>/2018/10/01/spring-boot-admin-monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-Admin监控系统搭建"><a href="#Spring-Boot-Admin监控系统搭建" class="headerlink" title="Spring Boot Admin监控系统搭建"></a>Spring Boot Admin监控系统搭建</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring Boot Admin是对Spring Boot的管理和监控的一个开源框架，支持Eureka服务注册列表状态监控，JMX监控，日志监控，JVM信息，垃圾信息，内存情况的监控，还可以设置日志的level级别。Spring Boot Admin UI 采用AngularJs将数据展示在前端。Spring Boot Admin分为服务端和客户端。</p><h2 id="Spring-Boot-Admin-Server端搭建"><a href="#Spring-Boot-Admin-Server端搭建" class="headerlink" title="Spring Boot Admin Server端搭建"></a>Spring Boot Admin Server端搭建</h2><ol><li><p>添加依赖项，依赖项内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot主类上添加对Spring Boot Admin Server启动的注解@EnableAdminServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableDiscoveryClient # 开启服务注册。</span><br><span class="line">@EnableTurbineStream # 开启Turbine服务监控。</span><br><span class="line">@EnableAdminServer # 开启Spring Boot Admin Server功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudMonitorApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudMonitorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">            http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 设置登出页面地址。</span> http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line">            <span class="comment">// 设置目前不支持csrf。</span> http.csrf().disable();</span><br><span class="line">            <span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line">            <span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">            http.httpBasic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们看到上面其实还添加对Eureka的注解以及对Turbine Stream的注解功能，需要添加Turbine Stream注解相关与Spring boot Admin Server ui相关依赖项，为了安全起见导入了安全相关依赖项。依赖项内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—spring boot admin server ui支持登录页面依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-login&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成Hystrix监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成turbine--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--对Turbine Stream支持，使用RabbitMQ的方式对Hystrix数据进行收集分析。--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-codec-http&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Eureka支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!—安全支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>其实Spring Boot Admin Server依赖中包含对Zuul和Hystrix以及Eureka核心包的依赖整合，所以我们看到上面只是整合了UI相关的依赖项。而针对Eureka和Turbine Stream以及安全方面的依赖需要额外导入进去，依赖项也导入进去后需要对端点进行权限安全控制，我们可以看到上面内部类中对安全进行控制，通过继承WebSecurityConfigurerAdapter对安全进行配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line"><span class="comment">// 设置登出页面地址。</span></span><br><span class="line">http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line"><span class="comment">// 设置目前不支持csrf。</span></span><br><span class="line">http.csrf().disable();</span><br><span class="line"><span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>)</span><br><span class="line">    .permitAll();</span><br><span class="line"><span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line"><span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">http.httpBasic();</span><br></pre></td></tr></table></figure></p><p>也就是说对那些内容页面进行授权访问，那些页面是可以直接访问，对安全的开启等等一系列操作。</p><ol start="3"><li>修改配置文件信息，配置文件信息如下所示：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">    level:</span><br><span class="line">        org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter: error</span><br><span class="line">server: </span><br><span class="line">    port: <span class="number">8040</span></span><br><span class="line">turbine:</span><br><span class="line">    stream:</span><br><span class="line">        port: 8041    # 收集地址。</span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">boot:</span><br><span class="line">    admin:</span><br><span class="line">        routes:</span><br><span class="line">            endpoints: env,metrics,trace,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream</span><br><span class="line">        turbine:</span><br><span class="line">            clusters: <span class="keyword">default</span></span><br><span class="line">            location: http:<span class="comment">//localhost:$&#123;turbine.stream.port&#125;</span></span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;MONITOR_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：</p><ul><li>turbine.stream.port: 对Turbine支持，turbine服务端口号。</li><li>boot.admin.routes.endpoints: Spring Boot Admin暴露的EndPoint端点</li><li>spring.boot.admin.routes.turbine.clusters: 集群的名称</li><li>spring.boot.admin.routes.turbine.location: 集成Turbine服务数据收集的地址。  </li></ul><p>这里的地址就是为了收集是需要访问地址，我们之前在Turbine章节中说过这里不在多阐述。<br>Eureka中的metadataMap是专门用来存放一些自定义的数据，当注册中心或者其他服务需要此服务的某些配置时可以在metadataMap里取。实际上，每个instance都有各自的metadataMap，map中存放着需要用到的属性。例如，上面配置中的eureka.instance.metadata-map.user.name，当这个服务成功注册到Eureka上，SpringBootAdmin就会取拿到这个instance，进而拿到metadataMap里的属性，然后放入请求头，向此服务发送请求，访问此服务的actuator开放的端点。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>需要添加对安全保护的依赖项，以及对Turbine Stream注解。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>以上对Turbine Stream的支持请参考Spring Cloud Turbine相关文章内容。  </p><ol start="2"><li>修改配置文件信息，添加对Turbine Stream 消息队列的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span> </span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        hostname: localhost</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">        healthcheck:</span><br><span class="line">            enabled: <span class="keyword">true</span></span><br><span class="line"># Hystrix超时时间。</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                        timeoutInMilliseconds: <span class="number">5000</span></span><br><span class="line">spring:</span><br><span class="line">    abbitmq:</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        host: localhost</span><br><span class="line"></span><br><span class="line"># Spring Boot Admin配置相关 # SpringBoot 1.5以后的版本都默认开启端点保护</span><br><span class="line">management:</span><br><span class="line">    security:</span><br><span class="line">        enabled: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></li></ol><p>最主要的是management.security.enabled：关闭管理安全。<br>下面是Spring Boot Admin相关监控信息。</p><p><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片1" title="图片1"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片2" title="图片2"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片3" title="图片3"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片4" title="图片4">  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Logback输出日志到ELK</title>
      <link href="/2018/10/01/logback-with-elk/"/>
      <url>/2018/10/01/logback-with-elk/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Logback输出日志到ELK"><a href="#使用Logback输出日志到ELK" class="headerlink" title="使用Logback输出日志到ELK"></a>使用Logback输出日志到ELK</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>前两篇文章中我们介绍了windows上如何搭建ELK日志收集系统，那么问题来了，日志系统搭建完成后如何使用java代码直接输出日志到ELK系统中？</p><h2 id="logback支持ELK"><a href="#logback支持ELK" class="headerlink" title="logback支持ELK"></a>logback支持ELK</h2><p>我们带着背景中的问题进行下面的开始思路整理，其实在ELK文章中我们已经说了两种方案，其实ELK中logstash支持的日志收集的方式有很多种，下面说一下logstash收集其中方法：  </p><ol><li>使用logstash对文件进行检测  </li><li>使用TCP协议，logstash开放对TCP协议端口的监听。  </li><li>使用UDP协议，logstash开放对UDP协议端口的监听。  </li></ol><p>我们本章节中使用的是TCP协议的方式进行日志输出，下面看一下logback的配置文件。  </p><ol><li><p>引入依赖项logstash-logback-encoder</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- logback和logstash结合 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改logback的配置文件信息。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=<span class="string">"LOGSTASH"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span><br><span class="line">    &lt;destination&gt;192.168.1.107:9250&lt;/destination&gt;</span><br><span class="line">    &lt;!-- encoder必须配置,有多种可选 --&gt;</span><br><span class="line">    &lt;encoder charset=<span class="string">"UTF-8"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">&lt;root level=<span class="string">"ERROR"</span>&gt;</span><br><span class="line">    &lt;appender-ref ref=<span class="string">"LOGSTASH"</span>/&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>appender</code>的name属性使用的是net.logstash.logback.appender.LogstashTcpSocketAppender<br><code>destination</code>属性：tcp的IP地址和端口号<br><code>encoder</code>：编码格式  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows环境下搭建ELK环境</title>
      <link href="/2018/10/01/elk-environment-construction-in-windows/"/>
      <url>/2018/10/01/elk-environment-construction-in-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows环境下搭建ELK环境"><a href="#Windows环境下搭建ELK环境" class="headerlink" title="Windows环境下搭建ELK环境"></a>Windows环境下搭建ELK环境</h1><h2 id="搭建Elastic-Stack环境"><a href="#搭建Elastic-Stack环境" class="headerlink" title="搭建Elastic Stack环境"></a>搭建Elastic Stack环境</h2><ol><li>通过官网下载相关包，网址：<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic1.png" alt="Elastic Stack" title="Elastic Stack">  </p><ol start="2"><li><p>运行<code>bin/elasticsearch</code> (or <code>bin\elasticsearch.bat on Windows</code>)  </p></li><li><p>在浏览器上访问<a href="http://localhost:9200，出现如下截图内容代表ES部署成功。">http://localhost:9200，出现如下截图内容代表ES部署成功。</a>  </p></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic2.png" alt="运行情况" title="运行情况">  </p><h2 id="搭建Logstash环境"><a href="#搭建Logstash环境" class="headerlink" title="搭建Logstash环境"></a>搭建Logstash环境</h2><ol><li>下载logstash文件，网址：<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic3.png" alt="logstash" title="logstash"><br>下载Zip将Zip解压到本地。  </li><li>新建Logstash.conf文件，将logstash.conf文件复制到bin文件夹下。  </li></ol><ul><li><p>通过检测文件的方式输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     file &#123;</span><br><span class="line">        path =&gt; [&quot;D:/Log/*.log&quot;]   检测文件，通过检测文件变化输出到ES中。</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]  ES地址</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过TCP方式进行监听日志信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     tcp &#123;</span><br><span class="line"></span><br><span class="line">port =&gt; 9250   TCP端口号</span><br><span class="line">codec =&gt; json_lines</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>运行<code>bin/logstash -f logstash.conf –t</code>  -t代表检测文件语法格式是否有误。<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic4.png" alt="运行结果" title="运行结果"><br>通过访问9600可以得到如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"host"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"6.4.1"</span>,  </span><br><span class="line">    <span class="string">"http_address"</span>: <span class="string">"127.0.0.1:9600"</span>,  </span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"bbb75ede-2654-4312-a80b-77d2c431ee73"</span>,  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"build_date"</span>: <span class="string">"2018-09-13T23:17:51Z"</span>,  </span><br><span class="line">    <span class="string">"build_sha"</span>: <span class="string">"cee0d74663380e80c2a38cf5a9ccffb9a0cfa215"</span>,  </span><br><span class="line">    <span class="string">"build_snapshot"</span>: <span class="keyword">false</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="搭建Kibana环境"><a href="#搭建Kibana环境" class="headerlink" title="搭建Kibana环境"></a>搭建Kibana环境</h2><ol><li>下载Kibana，选择Windows版本。地址：<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic5.png" alt="下载地址" title="下载地址">  </li><li>打开config/kibana.yml文件，设置elasticsearch.url  为<a href="http://localhost:9200">http://localhost:9200</a>  </li><li>运行bin/kibana或者bin/kiana.bat（在windows下运行）。  </li><li>访问地址localhost://5601<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic6.png" alt="访问的地址" title="访问的地址">  </li><li>配置日志打开Discover菜单，创建索引<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic7.png" alt="创建索引" title="创建索引">  </li><li>创建筛选器–根据时间筛选<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic8.png" alt="创建筛选器–根据时间筛选" title="创建筛选器–根据时间筛选">  </li><li>再次返回到 Discover<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic9.png" alt="Discover" title="下载地Discover址">  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式服务跟踪之Spring Cloud Sleuth快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-sleuth/"/>
      <url>/2018/10/01/quick-start-spring-cloud-sleuth/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着业务的发展，系统规模也会变得越来越大，微服务之前的关系也会变得越来越复杂，客户端发起请求后通过一些列的微服务返回的结果，则会形成一个复杂的链路，在每个链路中如果有一个以来服务出现延迟或错误都会引发请求最后的失败，这时候对于整个链路的跟踪极为重要，通过实现队请求调用的跟踪可以帮助我们快速发现错误根源以及监控分析每条请求链路上的性能瓶颈等。<br>接下来我们要使用Spring Cloud Sleuth与Zipkin进行整合。</p><h1 id="Spring-Cloud-Sleuth使用。"><a href="#Spring-Cloud-Sleuth使用。" class="headerlink" title="Spring Cloud Sleuth使用。"></a>Spring Cloud Sleuth使用。</h1><ol><li>需要准备两个服务，service1与service2，service1调用service2的方法。</li><li>添加依赖项spring-cloud-starter-sleuth。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-sleuth它会自动为当前应用构建起各通信通道跟踪机制。比如：</p><ul><li>通过诸如RabbitMQ、Kafaka（或者其他任何Spring Cloud Stream绑定器实现的消息中间件）传递的请求。</li><li>通过Zuul代理传递的请求。</li><li>通过RestTemplate发起的请求。</li></ul><p>通过上面的配置即可对链路数据的监控，当我们访问service1和service2接口时会在控制台中输出相应的信息，例如：  </p><blockquote><p>INFO [servce1,f410a57afd5c145,a9f2118fa201984,false]25028—call servce1<br>INFO [servce1,f410a57afd5c145,e9a377dc2268bc29,false]25028—call servce2</p></blockquote><p><code>中括号</code>中的元素是实现分布式服务跟踪的重要组成部分，主要是：<br>第一个值：service1代表的是应用的名称，也就是spring.application.name参数属性值。<br>第二个值：Spring Cloud Sleuth生成的一个ID，称之为Trace ID，它用来标识是一条链路。一个请求链路中包含一个Trace ID，多个Span ID。<br>第三个值：也是Spring Cloud Sleuth生成的一个ID，代表的是Span ID,他表示一个基本的工作单位，比如发送一个Http请求。<br>也就是说同一个TranceID代表是一条链路，而不同的SpanID代表不同的Http请求和业务访问操作。  </p><h1 id="整合Zipkin"><a href="#整合Zipkin" class="headerlink" title="整合Zipkin"></a>整合Zipkin</h1><ol><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;    </span><br><span class="line">    &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>其中包括：spring-cloud-sleuth-zipkin-stream、spring-cloud-stream-binder-rabbit表示使用RabbitMQ的方式对链路进行传递请求。<br>zipkin-autoconfigure-ui依赖是通过页面的展示链路的情况。<br>客户端中需要添加对RabbitMQ注解的支持，主要是spring-cloud-stream-binder-rabbit或者spring-cloud-starter-stream-rabbit，我可以清晰的发现前后两者内容其实是一样后者内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;parent&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-stream-binder-rabbit-parent&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/parent&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">   &lt;description&gt;Spring Cloud Starter Stream Rabbit&lt;/description&gt;</span><br><span class="line">   &lt;url&gt;http:<span class="comment">//projects.spring.io/spring-cloud&lt;/url&gt;</span></span><br><span class="line">   &lt;organization&gt;</span><br><span class="line">      &lt;name&gt;Pivotal Software, Inc.&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http:<span class="comment">//www.spring.io&lt;/url&gt;</span></span><br><span class="line">   &lt;/organization&gt;</span><br><span class="line">   &lt;properties&gt;</span><br><span class="line">      &lt;main.basedir&gt;$&#123;basedir&#125;/../..&lt;/main.basedir&gt;</span><br><span class="line">   &lt;/properties&gt;    &lt;dependencies&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在Spring Boot主类上添加@EnableZipkinStreamServer注解开启Zipkin功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZipkinStreamServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudSluethZipkinApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringCloudSluethZipkinApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudsluethzipkin</span><br><span class="line">rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">9411</span></span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: admin</span><br><span class="line">    password: $&#123;ZIPKIN_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过RabbitMQ对消息进行传递，将链路信息传递给RabbitMQ，Zipkin对消息队列消息进行收集分析得出实际的访问链路。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控Spring Cloud Turbine消息队列篇</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>上一篇文章中我们介绍了Turbine简单的通过服务名称的方式构建监控聚合服务，这一章中我们将要讲一下使用消息队列的方式对集群信息进行收集，监控，我们可以将所有需要收集的监控信息都输出到消息代理中，然后turbine订阅消息代理中的消息，通过异步的方式读取消息，最后将读取出来的监控指标输出到Hystrix Dashboard中。</p><h1 id="Turbine与消息代理结合"><a href="#Turbine与消息代理结合" class="headerlink" title="Turbine与消息代理结合"></a>Turbine与消息代理结合</h1><ol><li>首先需要一个重要的东西就是消息代理，这里我们使用的是RabbitMQ来进行消息的传递与收集。（环境搭建省略）</li><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者是<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-stream-rabbit &lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为我们可以看到spring-cloud-starter-turbine-amqp实际上是包装了spring-cloud-starter-turbine-stream和spring-cloud-starter-turbine-stream依赖。  </p><ol start="3"><li><p>在Spring Boot主类上添加@EnableTurbineStream注解来启用Turbine Stream的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTurbineStream</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">TurbineApplication</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(TurbineApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件信息中添加RabbitMq的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">   application: </span><br><span class="line">       name: springCloudMonitor</span><br><span class="line">server: </span><br><span class="line">  port: <span class="number">8040</span> </span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">  instance:</span><br><span class="line">    hostname: registry</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">        user.name: $&#123;security.user.name&#125;</span><br><span class="line">        user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br></pre></td></tr></table></figure></li></ol><p>对于Turbine的配置已经完成，还需要对服务消费者做一些修改，修改如下：  </p><ol><li>添加对RabbitMQ支持依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为第一个依赖项是对下面两个依赖项的整合，所以下面的和上面的效果是以昂的。</p><ol start="2"><li>添加对RabbitMQ配置信息的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    host: localhost</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以通过消息队列的方式进行系统监控。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控之Spring Cloud Turbine快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Spring Cloud Turbine是对集群中微服务信息的统一监控收集监控信息，我们在每个微服务中添加了对Hystrix熔断器功能的支持，可以通过/hystrix.stream对每个微服务的运行状况进行监控，如果在集群中去对每一个微服务去进行单个访问是行不通的，这时候turbine就发挥了它的优势，他可以将多个微服务的hystrix.stream聚合到一起使用turbine.stream进行聚合监控。  </p><h1 id="Spring-Cloud-Turbine快速入门"><a href="#Spring-Cloud-Turbine快速入门" class="headerlink" title="Spring Cloud Turbine快速入门"></a>Spring Cloud Turbine快速入门</h1><ol><li><p>添加依赖项，spring-cloud-starter-turbine，使用HystrixDashboard对Hystrix熔断进行图形化监控。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot的主类上添加@EnableTurbine注解开启Turbine功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudHystrixTurbineApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudHystrixTurbineApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，修改如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8031</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springhystrixturbine</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:password@localhost:8761/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: <span class="keyword">default</span></span><br><span class="line">  #turbine.app-config指定了要收集监控信息的服务名</span><br><span class="line">  appConfig: spring-cloud-user,spring-cloud-service</span><br><span class="line">    #turbine.cluster-name-expression 指定集群名称</span><br><span class="line">  clusterNameExpression: <span class="string">"'default'"</span></span><br><span class="line">  combine-host-port: true #使同一主机上的多个服务实例可以通过主机名和端口号的组合来进行区分</span><br></pre></td></tr></table></figure></li></ol><p>配置信息参数描述：  </p><ul><li>turbine.appConfig：制定要收集监控信息的服务名，意思就是代表这些服务的hystrix.stream由turbine来进行收集监控。</li><li>turbine.cluster-name-expression：指定集群的名称。</li><li>combine-host-port：默认是true，代表同一台主机上多个服务实例可通过主机名和端口号组合来进行区分，因为同一个服务器可能部署多台微服务实例。</li></ul><ol start="4"><li>集群监控，可以通过访问<a href="http://localhost:8031/hystrix">http://localhost:8031/hystrix</a> 对单个服务进行监控<br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic1.png" alt="turbine页面" title="turbine主页面"><br>可以清晰的看到下面的需要进行turbine监控的url的写法<a href="http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：">http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：</a><br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic2.png" alt="turbine页面" title="turbine主页面"><br>这说明我们集群监控配置成功。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API网关服务-Spring Cloud Zuul快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-zuul/"/>
      <url>/2018/09/27/quick-start-spring-cloud-zuul/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#简介">简介</a></li><li><a href="#Spring-Cloud-Zuul使用">Spring Cloud Zuul使用</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。</p><h2 id="Spring-Cloud-Zuul使用"><a href="#Spring-Cloud-Zuul使用" class="headerlink" title="Spring Cloud Zuul使用"></a>Spring Cloud Zuul使用</h2><ol><li>添加依赖项<code>spring-cloud-starter-zuul</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-zuul包下不仅仅包含zuul-core包，还包含了spring-cloud-starter-hystrix、spring-cloud-starter-ribbon、spring-boot-starter-autuator，提供了负载均衡以及熔断器的支持。  </p><ol start="2"><li>Spring Boot主类添加@EnableZuulProxy注解开启Zuul的API网关功能。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 网关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们可以看到@EnableZuulProxy注解其实是一个组合注解，它包含了开启Hystrix熔断技术的功能以及对Eureka注册中心的功能的开启。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker    # 开启Hystrix熔断器功能。</span><br><span class="line">@EnableDiscoveryClient   # 开启Eureka客户端功能。</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(&#123;ZuulProxyMarkerConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>修改配置文件信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudzuul</span><br><span class="line">server:</span><br><span class="line">  port: 8050</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://admin:password@localhost:8761/eureka</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">zuul:</span><br><span class="line">  ignoredServices: springcloudservice    # 取消对服务路由机制列表</span><br><span class="line">  routes:</span><br><span class="line">    springclouduser: /user/**     # 指定服务路径。</span><br><span class="line"># Hystrix超时等到时间。</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 20000</span><br><span class="line"># ribbon超时等待时间。</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: 10000</span><br><span class="line">  ConnectTimeout: 10000</span><br></pre></td></tr></table></figure></li></ol><p>理由规则配置讲解：</p><ul><li><code>zuul.ignoredServices</code>：取消路由机制的服务名称列表。</li><li><code>zuul.routes.name</code>: 我们可以看到name被标记为红色字体，代表的是注册到erueka服务中的服务名称，例如上面是springclouduser服务的路由规则是通过/user进行访问该服务的所有接口信息。</li><li><code>zuul.routes.xxx.path=/xxx/**</code><br><code>zuul.routes.xxx.url=http://localhost:8080/</code><br>该配置的表示所有符合/xxx/**规则的访问都将转发到<a href="http://localhost:8080">http://localhost:8080</a> 地址上，例如：访问服务中的<a href="http://localhost:8081/xxx/getUserList">http://localhost:8081/xxx/getUserList</a> 接口时，API网关服务会将该请求路由到<a href="http://localhost:8080/getUserList">http://localhost:8080/getUserList</a> 提供的服务接口上。其中红色部分为路由的名称，可以任意定义，但是一组path和url映射关系的路由名称要相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置管理中心Spring Cloud Config快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-config/"/>
      <url>/2018/09/27/quick-start-spring-cloud-config/</url>
      
        <content type="html"><![CDATA[<h1 id="配置管理中心-Spring-Cloud-Config"><a href="#配置管理中心-Spring-Cloud-Config" class="headerlink" title="配置管理中心-Spring Cloud Config"></a>配置管理中心-Spring Cloud Config</h1><h2 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h2><p>Spring Cloud Config是用为分布式系统中的基础设施和服务应用提供集中化的外部配置支持，它分为服务端和客户端两个部分。服务端是一个独立的服务，用来连接配置仓库并为客户端提供获取配置信息、加密、解密信息等访问接口，客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关配置内容，并在启动时候从配置中心获取和加载配置信息。Spring Cloud Config默认是git仓库进行存储配置信息，同时也支持其他方式进行存储，例如数据库，文件系统等。  </p><h2 id="Spring-Cloud-Config使用"><a href="#Spring-Cloud-Config使用" class="headerlink" title="Spring Cloud Config使用"></a>Spring Cloud Config使用</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>添加依赖项<code>spring-cloud-stater-config-server</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置相关信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableConfigServer    # 开启Spring Cloud Config功能。</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，添加配置服务的基本信息以及git仓库相关信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/dwlsxj/spring-cloud-test.git  # 配置仓库地址。</span></span><br><span class="line">          search-paths: git-repo # 仓库文件夹地址。</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: $&#123;security.user.name&#125;</span><br><span class="line">      user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">    defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password@localhost:8761/eureka/# Eureka地址。</span></span><br><span class="line"># 安全验证。</span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: user</span><br><span class="line">    password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中配置信息分别如下所示：<br><code>spring.cloud.config.server.git.uri</code>：git仓库的地址。<br><code>spring.cloud.config.server.search-paths</code>：对应仓库下相对所搜的位置，可以配置多个，其实就是存储配置信息的具体位置，例如如果仓库中存放了其他的内容并不是单纯存储配置信息，可通过该参数对配置信息进行搜索，定位。<br><code>spring.cloud.config.server.git.username</code>：访问git仓库的用户名。<br><code>spring.cloud.config.server.git.password</code>：访问git仓库的密码。</p><ol start="4"><li>配置规则详解,我们可以通过浏览器、postman、curl等工具直接访问配置相关信息，访问配置信息的URL与配置文件的映射关系如下所示：</li></ol><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties  </li></ul><p>访问地址：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic2.png" alt="配置信息" title="配置信息"><br>当我们通过URL访问配置信息时，我们发现控制台出现如下内容：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic3.png" alt="本地存储信息" title="本地存储信息"></p><p>配置服务实际是从Git仓库获取配置信息后，会存储一份在config-server的文件系统中，实质上config-server是通过git clone命令将配置内容复制一份在本地存储，然后读取本地内容返回给客户端，通过本地仓库暂存，可以有效的放置当git仓库出现故障而引起的无法加载的问题。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p>添加依赖项<code>spring-cloud-starter-config</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>对配置文件进行添加配置中心服务地址，以及安全访问的用户名密码等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springclouduser</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">        uri: http:<span class="comment">//localhost:8080</span></span><br><span class="line">        fail-fast: <span class="keyword">true</span></span><br><span class="line">        username: user</span><br><span class="line">        password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br><span class="line">        profile: dev</span><br><span class="line">        label: master</span><br><span class="line">        retry:  # 重试机制。</span><br><span class="line">            initial-interval: <span class="number">2000</span></span><br><span class="line">            max-interval: <span class="number">10000</span></span><br><span class="line">            multiplier: <span class="number">2</span></span><br><span class="line">            max-attempts: <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：<br><code>spring.application.name</code>：服务名称，对应配置文件规则中的{application}部分。<br><code>spring.cloud.config.uri</code>:配置中心服务地址。<br><code>spring.cloud.config.username</code>:访问服务注册中心用户名。<br><code>spring.cloud.config.password</code>:访问注册中心密码。<br><code>spring.cloud.config.profile</code>:应用的环境信息，对应配置规则中的{profile}部分。<br><code>spring.cloud.config.label</code>:主要是分支，对应配置文件规则中的{label}部分。<br>需要注意的是这些配置信息必须配置到<code>bootstrap.yml</code>或<code>bootstrap.properties</code>文件中，因为配置信息<code>application.yml</code>和<code>bootstrap.yml</code>是有加载顺序的，首先程序启动时先加载的是<code>bootstrap.yml</code>文件，其次是<code>application.yml</code>配置信息，因为jar包之外的配置信息优先于jar包之内的配置信息，所以需要首先加载外部的配置信息。  </p><ol start="3"><li>对配置信息的读取和使用，首先需要添加配置类，对配置信息通过EL表达式的方式进行注入。<br>读取方式有两种方式：  </li></ol><ul><li><p>通过@Value(“${profile}”)方式绑定参数到属性中。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;profile&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Environment对象来获取配置属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="meta">@GetMapping</span>(“/getProfile”)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(“profile”,“<span class="keyword">null</span>”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务容错保护Spring Cloud Hystrix之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-hystrix/"/>
      <url>/2018/09/27/quick-start-spring-cloud-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Spring-Cloud-Hystrix介绍">Spring Cloud Hystrix介绍</a></li><li><a href="#Spring-Cloud-Hystrix整合">Spring Cloud Hystrix整合</a><ul><li><a href="#常用配置">常用配置</a>  </li></ul></li></ul><h2 id="Spring-Cloud-Hystrix介绍"><a href="#Spring-Cloud-Hystrix介绍" class="headerlink" title="Spring Cloud Hystrix介绍"></a>Spring Cloud Hystrix介绍</h2><p>Spring Cloud Hystrix实现了断路器、线程隔离等一系列服务保护功能。它是基于Netflix的开源框架Hystrix实现，该框架的目标在于通过控制那些访问远程系统，服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级，服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等功能。<br>场景描述：如果我们在微服务中进行通信时，发现其中微服务宕机了，这时候另外一个服务调用了宕机的服务，如果在没有断路器机制的前提下访问，这时候会一直等待，一直等待到服务达到超时的点，会使得线程因调用故障服务被长时间占用不能释放，通过断路器的故障监控，如果发现故障时，会向调用者返回一个错误相应，这样就不用长时间等待。</p><h2 id="Spring-Cloud-Hystrix整合"><a href="#Spring-Cloud-Hystrix整合" class="headerlink" title="Spring Cloud Hystrix整合"></a>Spring Cloud Hystrix整合</h2><ol><li>添加依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId &gt;</span><br><span class="line">&lt;/denpendecy&gt;</span><br></pre></td></tr></table></figure></li></ol><p>同时需要添加<code>spring-boot-starter-actuator</code>，这是Spring Boot对监控的依赖项，只有添加了这些东西后监控相关的endpoint才会被注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解<code>@EnableCircuitBreaker</code>，对Hystrix进行开启功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableEurekaClient#开启Eureka客户端注册</span><br><span class="line">@EnableCircuitBreaker #开启Hystrix功能</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudUserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造服务消费方式，通过添加@HystrixCommod注解对服务接口的熔断技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TestController.class);    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getHelloWorld的熔断机制。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 熔断信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>代码分析：</p><ol><li>通过依赖注入RestTemplate，该Bean主要是对Rest Api进行访问，可以裂解调用服务接口的封装。</li><li>定义了getHelloWorld去访问另外一个服务springcloudservice的getHelloWorld方法</li><li>对该接口上添加了@HystrixCommod注解，通过制定fallbackMethod对出现问题接口进行错误转向</li><li>定义错误转向方法：fallback()</li><li>当springcloudservice服务宕机后，可以快速返回“error“字样。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommod</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HystrixCommand &#123;</span><br><span class="line"><span class="comment">// HystrixCommand 命令所属的组的名称：默认注解方法类的名称</span></span><br><span class="line"><span class="function">String <span class="title">groupKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// HystrixCommand 命令的key值，默认值为注解方法的名称</span></span><br><span class="line"><span class="function">String <span class="title">commandKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 线程池名称，默认定义为groupKey</span></span><br><span class="line"><span class="function">String <span class="title">threadPoolKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 定义回退方法的名称, 此方法必须和hystrix的执行方法在相同类中</span></span><br><span class="line"><span class="function">String <span class="title">fallbackMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 配置hystrix命令的参数</span></span><br><span class="line">HystrixProperty[] commandProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 配置hystrix依赖的线程池的参数</span></span><br><span class="line">HystrixProperty[] threadPoolProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。我们也可以通过此方法定义哪些需要忽略的异常</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] ignoreExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义执行hystrix observable的命令的模式，类型详细见ObservableExecutionMode</span></span><br><span class="line"> <span class="function">ObservableExecutionMode <span class="title">observableExecutionMode</span><span class="params">()</span> <span class="keyword">default</span> ObservableExecutionMode.EAGER</span>;</span><br><span class="line"> <span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。此方法定义需要抛出的异常</span></span><br><span class="line">HystrixException[] raiseHystrixExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义回调方法：但是defaultFallback不能传入参数，返回参数和hystrix的命令兼容</span></span><br><span class="line"><span class="function">String <span class="title">defaultFallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Hystrix超时时间</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                       timeoutInMilliseconds: <span class="number">5000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端负载均衡Spring Cloud Ribbon之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-ribbon/"/>
      <url>/2018/09/27/quick-start-spring-cloud-ribbon/</url>
      
        <content type="html"><![CDATA[<h1 id="客户端负载均衡-Spring-Cloud-Ribbon"><a href="#客户端负载均衡-Spring-Cloud-Ribbon" class="headerlink" title="客户端负载均衡-Spring Cloud Ribbon"></a>客户端负载均衡-Spring Cloud Ribbon</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#客户端负载均衡-Spring-Cloud-Ribbon">客户端负载均衡-Spring Cloud Ribbon</a><ul><li><a href="#Spring-Cloud-Ribbon介绍">Spring Cloud Ribbon介绍</a></li><li><a href="#Spring-Cloud-Ribbon使用">Spring Cloud Ribbon使用</a></li></ul></li></ul><h2 id="Spring-Cloud-Ribbon介绍"><a href="#Spring-Cloud-Ribbon介绍" class="headerlink" title="Spring Cloud Ribbon介绍"></a>Spring Cloud Ribbon介绍</h2><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它是基于Netflix的Ribbon的实现。通过Spring Cloud的封装可以轻松的将面向服务的Rest模板请求自动转化成客户端负载均衡的服务调用。它是一个工具类框架，不能像服务注册中心、配置中心、API网关单独部署，但是可以存在每一个Spring Cloud构建的微服务和基础设施中。<br>负载均衡模块都会维护一个可用的服务列表，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。客户端负载均衡和服务端负载均衡唯一的区别是客户端负载均衡中，所有客户端负载均衡都会自己维护服务清单，而这些服务清单是由服务注册中心获取得到。  </p><h2 id="Spring-Cloud-Ribbon使用"><a href="#Spring-Cloud-Ribbon使用" class="headerlink" title="Spring Cloud Ribbon使用"></a>Spring Cloud Ribbon使用</h2><p>1．    添加依赖项<code>spring-cloud-starter-ribbon</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解对负载均衡支持<code>@LoadBalanced</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务之间调用通过服务名称的方式进行调用而不是通过ip地址的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的springcloudservice是注册到Eureka的服务，服务名称为springcloudservice，可以通过加了@LoadBalanced修饰过的RestTemplate来实现面向服务的接口调用。之前调用方式如下代码所示：restTemplate.getForObject(“<a href="http://localhost:8888/getHelloWorld&quot;">http://localhost:8888/getHelloWorld&quot;</a>, String.class);</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务治理-Spring Cloud Eureka</title>
      <link href="/2018/09/26/spring-cloud-tutorial-eureka/"/>
      <url>/2018/09/26/spring-cloud-tutorial-eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka介绍"><a href="#Eureka介绍" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h1><p>Eureka是Spring Cloud Netflix的微服务套件的一部分，它是基于Netflix Eureka的二次开发，主要负责完成微服务架构中的服务治理功能。而且可以与Spring boot很容易的整合进行开发，使得开发变得简单，Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端，也被称为服务消费者与服务的生产者，服务启动时向服务注册中心（服务端）进行注册自己，并通过定时心跳检测的方式告诉服务端存活状态，更新服务续约，同时也可以将服务端的服务列表缓存到本地并周期性刷新服务列表的状态。</p><h1 id="Eureka的使用"><a href="#Eureka的使用" class="headerlink" title="Eureka的使用"></a>Eureka的使用</h1><p>服务端</p><ol><li>在pom文件中添加依赖项。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加配置信息，在application.yml或application.properties中添加如下内容  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springcloudeurekaserver   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: 8761  # 端口号</span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        registerWithEureka: false # 是否注册自己，不注册</span><br><span class="line">        fetchRegistry: false   # 禁止检测服务</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//$&#123;security.user.name&#125;:$&#123;security.user.password&#125;@localhost:$&#123;server.port&#125;/eureka/   #Eureka服务地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 处于安全考虑需要对用户进行登录。</span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;REGISTRY_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaServer注解，开启对Eureka服务的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行Eureka服务，通过访问<a href="http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：">http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：</a><br><img src="/2018/09/26/spring-cloud-tutorial-eureka/pic1.png" alt="Eureka服务" title="Eureka服务"></p><h2 id="页面描述"><a href="#页面描述" class="headerlink" title="页面描述"></a>页面描述</h2></li><li>nstances currently registered with Eureka：服务注册列表信息。</li><li>DS Replicas代表的集群部署时，server地址。<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1></li><li><p>在pom文件中添加依赖项。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"># 需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息，在application.yml或application.properties中添加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springclouduser   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span></span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/#Eureka服务地址。</span></span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaClient注解或@ EnableDiscoveryClient，开启对Eureka客户端的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样三步骤就讲微服务注册到服务中心中，可以看到服务中心已经获取到当前服务信息。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一文搭建Maven骨架</title>
      <link href="/2018/09/23/maven-skeleton-generation/"/>
      <url>/2018/09/23/maven-skeleton-generation/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#Maven骨架介绍">Maven骨架介绍</a><ul><li><a href="#Maven-archetype">Maven archetype</a></li></ul></li><li><a href="#maven骨架创建过程">Maven骨架创建过程</a><ul><li><a href="#使用archetype创建项目">使用archetype创建项目</a></li></ul></li><li><a href="#使用本地Maven骨架">使用本地Maven骨架</a></li></ul><h1 id="Maven骨架介绍"><a href="#Maven骨架介绍" class="headerlink" title="Maven骨架介绍"></a>Maven骨架介绍</h1><h2 id="Maven-archetype"><a href="#Maven-archetype" class="headerlink" title="Maven archetype"></a>Maven archetype</h2><p>Archetype是一个Maven项目模板工具包，通过Archetype我们可以快速搭建Maven项目，通俗理解就是项目的基础架构，项目初始化的过程。我们在使用Idea开发工具的时候会有如下图操作：<br><img src="/2018/09/23/maven-skeleton-generation/./pic.png" alt="IDEA" title="IDEA"><br>在这里选择的Maven进行生成的项目都是利用Maven骨架来进行生成的，通过选择骨架生成项目结构的方式方便了我们手动去搭建相关项目内容。可以直接通过自带骨架或自己构建的骨架进行项目的快速搭建，节约成本。<br>我们构建一个完整的骨架整体的操作逻辑如下图所示：<br><img src="/2018/09/23/maven-skeleton-generation/./pic1.png" alt="Maven archetype" title="Maven archetype"><br>接下来将详细剖析每一步内容。  </p><h1 id="Maven骨架创建过程"><a href="#Maven骨架创建过程" class="headerlink" title="Maven骨架创建过程"></a>Maven骨架创建过程</h1><h2 id="使用archetype创建项目"><a href="#使用archetype创建项目" class="headerlink" title="使用archetype创建项目"></a>使用archetype创建项目</h2><ol><li>第一步建立Maven的项目，其实就是我们想要生成骨架的项目结构。  </li><li><p>在pom.xml中添加插件maven-archetype-plugin。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开命令行进入到项目主目录中，运行如下命令：<font style="color:red"><code>mvn archetype:create-from-project</code></font><br>此时会在该项目的target目录下发现如下文件：<br><img src="/2018/09/23/maven-skeleton-generation/./pic2.png" alt="maven骨架目录" title="maven骨架目录"><br>我们可以清晰的发现archetype目录下是我们的项目结构，项目结构下面src/main/resources/META-INF/包含archetype-metadata.xml，这个文件是用来自定义骨架内容的，接下内容中会对信息进行详细的说明。</p></li><li>进入到target/generated-sources/archetype目录下，使用mvn clean install进行打包到本地文件中。<br>这时候你会在maven的本地仓库中多出一个文件archetype-catalog.xml<br><img src="/2018/09/23/maven-skeleton-generation/./pic3.png" alt="archetype-catalog.xml" title="archetype-catalog.xml"><br>打开文件发现这里面有我们添加的Maven骨架信息。<br><img src="/2018/09/23/maven-skeleton-generation/./pic4.png" alt="maven骨架目录" title="maven骨架目录"><br><em><code>注意：如果想要删除本地的内容就直接删除archetype节点即可。</code></em><h1 id="使用本地Maven骨架"><a href="#使用本地Maven骨架" class="headerlink" title="使用本地Maven骨架"></a>使用本地Maven骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>          禁止询问，如果不加命令行会询问你填写版本号等信息是否正确。  </span><br><span class="line">-DarchetypeCatalog=local         生成项目解析方式，local=本地骨架 internal=内部的  remote=这是Maven中央存储库或其镜像的捷径  </span><br><span class="line">-DgroupId=com.jtech.wpark.test   生成项目的groupId  </span><br><span class="line">-DartifactId=tetetetetet         生成项目的artifactId  </span><br><span class="line">-DarchetypeGroupId=com.jtech     骨架的groupId  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT 骨架版本号  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype   骨架的artifactId</span><br></pre></td></tr></table></figure></li></ol><p><code>archetypeCatalog</code>如果想要来自不同仓库的骨架信息，可以在maven的Setting.xml中设置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;</span><br><span class="line">  &lt;url&gt;https://repository.domain.com/path/to/repo/&lt;/url&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- in case of a repository with authentication --&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;          // 私服的Id</span><br><span class="line">  &lt;username&gt;xxxx&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;xxxx&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></p><p>如果Maven中央存储库目录文件是空的，则使用内部目录。  </p><h1 id="Maven私服上传"><a href="#Maven私服上传" class="headerlink" title="Maven私服上传"></a>Maven私服上传</h1><p>使用mvn clean deploy对骨架上传到私服中，这里会存在一个问题，也就是上传的地址需要在pom.xml配置下，pom.xml文件路径为<code>target/generated-sources/archetype/pom.xml</code>文件。<br><img src="/2018/09/23/maven-skeleton-generation/./pic5.png" alt="配置上传路径" title="配置上传路径"><br>需要对该pomw文件添加distributionManagement节点，节点内容主要是私服地址信息，配置之后使用mvn clean deplod会将骨架上传到私服中去。</p><h1 id="使用私服服务器骨架"><a href="#使用私服服务器骨架" class="headerlink" title="使用私服服务器骨架"></a>使用私服服务器骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>  </span><br><span class="line">-DarchetypeCatalog=internal,remote            类型改变  </span><br><span class="line">-DarchetypeRepository=http:<span class="comment">//xxxxxx:8181/nexus/content/groups/public 私服地址  </span></span><br><span class="line">-DarchetypeGroupId=com.jtech  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT  </span><br><span class="line">-DgroupId=com.jtech.wpark.test  </span><br><span class="line">-DartifactId=tetetetetet  </span><br><span class="line">-Dversion=<span class="number">0.1</span>-SNAPSHOT</span><br></pre></td></tr></table></figure><p>这里需要注意一下,我们发现修改了远程私服进行构建项目时，指定了Repository为什么没有下载下来反而会出现如下错误信息：<br><img src="/2018/09/23/maven-skeleton-generation/./pic6.png" alt="错误信息" title="错误信息"><br>解决方案是：<br>修改maven的setting.xml文件，将文件修改为如下：  </p><ol><li><p>添加repository</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;snapshot&lt;/id&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">      &lt;repository&gt;</span><br><span class="line">        &lt;snapshots /&gt;</span><br><span class="line">          &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">          &lt;name&gt;my-snapshot&lt;/name&gt;</span><br><span class="line">          &lt;url&gt;http:<span class="comment">//127.0.0.1:8181/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">      &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">  &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;snapshot&lt;/activeProfile&gt;</span><br><span class="line">  &lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加server</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;   </span><br><span class="line">    &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对私服的repository，以及Server，这里的Server ID和对应的archetype repository的Id是一致的。这样才会在私服中下载下来相应的archetype文件。 </p><h1 id="自定义骨架内容"><a href="#自定义骨架内容" class="headerlink" title="自定义骨架内容"></a>自定义骨架内容</h1><p>当我们按照上面步骤走完之后发现项目中多出了不需要的文件，这时候我们就需要对骨架的内容进行自定义。<br><img src="/2018/09/23/maven-skeleton-generation/./pic7.png" alt="多余内容" title="多余内容"><br>这里面.idea和yaoyuan.iml文件都不是我们想要的，这时候我们想到之前说过的一个文件archetype-metadata.xml，我们打开这个文件看一下。  （这里的xml指的是target生成的文件目录下的）<br><img src="/2018/09/23/maven-skeleton-generation/./pic8.png" alt="xml内容" title="xml内容"><br>包含了一堆没用的文件进来了，这时候我们将这些东西删除掉，在mvn install一下。<br><img src="/2018/09/23/maven-skeleton-generation/./pic9.png" alt="生成内容" title="生成内容">  </p><p><code>注意：这个文件很重要，主要是如果文件夹为空的时候当我们生成骨架的时候是不会包含当前文件的，你需要对上面xml进行配置包含当前文件即可。</code></p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载器详解</title>
      <link href="/2018/09/23/java-class-loader/"/>
      <url>/2018/09/23/java-class-loader/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#类加载器详解">类加载器详解</a><ul><li><a href="#一、类加载器5大部分">一、类加载器5大部分</a><ul><li><a href="#加载">加载</a></li><li><a href="#验证">验证</a></li><li><a href="#准备">准备</a></li><li><a href="#解析">解析</a></li><li><a href="#初始化">初始化</a></li></ul></li><li><a href="#二、类加载器">二、类加载器</a></li><li><a href="#三、自定义类加载器">三、自定义类加载器</a><h1 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h1><h2 id="一、类加载器5大部分"><a href="#一、类加载器5大部分" class="headerlink" title="一、类加载器5大部分"></a>一、类加载器5大部分</h2>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。<br><img src="/2018/09/23/java-class-loader/./pic1.png" alt="加载机制" title="JVM类加载机制">  <h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</li></ul></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;</code>方法之中，这里我们后面会解释。<br>但是注意如果声明为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info</span><br><span class="line">CONSTANT_Field_info</span><br><span class="line">CONSTANT_Method_info</span><br></pre></td></tr></table></figure></p><p>等类型的常量。<br>下面我们解释一下符号引用和直接引用的概念：<br>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。<br>初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。<code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;clinit&gt;</code>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。（clinit初始化是对类成员信息进行初始化，init是对对象实例进行初始化操作）<br>注意以下几种情况不会执行类初始化：<br>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>定义对象数组，不会触发该类的初始化。<br>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。<br>通过类名获取Class对象，不会触发类的初始化。<br>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。  </p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：  </p><ol><li>启动类加载器(<code>Bootstrap ClassLoader</code>)：负责加载 JAVA_HOME\lib（JRE/lib/rt.jar） 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。  </li><li>扩展类加载器(<code>Extension ClassLoader</code>)：负责加载 JAVA_HOME\lib\ext（JRE/lib/ext/*.jar） 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。  </li><li>应用程序类加载器(<code>Application ClassLoader</code>)：负责加载用户路径（classpath）上的类库。</li><li>自定义的类加载器（<code>User ClassLoader</code>）：负责加载用户自定义的路径上的类库。<br>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承<code>java.lang.ClassLoader</code>实现自定义的类加载器。</li></ol><p><img src="/2018/09/23/java-class-loader/./pic2.png" alt="委托图" title="委托图"><br>类加载器的委托机制：  </p><ol><li>首先当前线程去加载线程中的第一个类  </li><li>如果A中引用了B，java虚拟机将使用加载类A的类加载取来加载B  </li><li>还可以直接使用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。   </li></ol><p>每个类加载器加载类时，又先委托给其上级类加载器。   </p><ol><li>当所有祖先类加载器没有加载到类，回到发起者类加载器，还加载不了就抛出异常<code>ClassNotFoundException</code>，不是再去找发起类加载器的儿子节点，因为没有getChild方法。  </li></ol><p>eg.比如说我们自定义一个类A，当我们去获取当前类加载器的名称时，肯定是AppClassLoader加载器，因为我们当前类只有CLASSPATH路径下有没如果我们将当前的项目打包成test.jar将jar包放入到JRE/lib/ext路径下，这时候我们在CLASSPATH中类就不会被加载，首先加载的是ext下的类A。这时候我们输出类A加载器名称的时就会输出ExtClassLoader。下面做演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.printf(ClassLoaderTest.class.getClassLoader().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClassLoaderTest是我们新建立的类，获取当前类的加载器时输出内容为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure></p><p>如果打包成jar包放到，ext文件下我们来看一下内容：<br><img src="/2018/09/23/java-class-loader/./pic.png" alt="ext目录结构" title="ext目录结构"></p><p>这是输出一下内容查看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = com.classloadertest.ClassLoaderTest.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(classLoader.getClass().getName()); </span><br><span class="line">    classLoader=classLoader.getParent();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure><p>循环输出类加载器结构的时候会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>因为Bootstrap类加载器实现不是由Java实现所以获取不到字节码，也就是为null的时候意味着是树状结构的顶层。</p><h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><p>有些时候我们需要实现自定义的类加载器来加载一些类，这时候我们可以继承ClassLoader来进行实现自定义的类加载器。我们先看一下jdk中的ClassLoader的源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归先父类进行尝试加载。</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>首先检测当前类有没有加载，如果加载在就不需要加载直接返回字节码</li><li>如果没有被加载，这时候会委托加载机制，通过递归从父加载器开始找，直到父类加载器为bootstrap ClassLoader为止，如果父类加载器找到了该字节码后没直接返回如果没有就返回让子类加载器加载，当子类加载器时，</li><li>如果还没有找到，这时候调用findClass方法进行查找。</li><li>最后根据resolve的值，判断这个class是否需要解析。<br><img src="/2018/09/23/java-class-loader/./pic3.png" alt="流程图" title="流程图"></li></ol><p>首先类加载器进行加载时当前线程的上线文的<code>ClassLoader</code>也就是<code>APPClassLoader</code>，当加载类时调用<code>LoadClass</code>方法，当调用的时候会检测当前类有没有被加载如果被加载了，就不需要在加载了直接返回，反之调用父类加载器的<code>LoadClass</code>方法，当父类加载器的父加载器不是null的时候就再去调用<code>LoadClass</code>方法，这时候的类加载器是<code>ExtClassLoader</code>加载器，父类加载是<code>BootStrap ClassLoader</code>，这时候继续递归调用<code>LoadClass</code>方法，这时候类加载器为<code>BootStrap ClassLoader</code>， 这时候就不需要再往下寻找了， <code>parent ClassLoader</code>为null。这是调用<code>findBootstrapClassOrNull(name)</code>方法，如果c不为null，这时候就直接返回，但是如果为null就调用<code>findClass</code>进行查询加载，如果还为null，这时候就会调用父类加载器<code>ExtClassLoader</code>的<code>findClass</code>方法，如果还是没有找到，则调用线程本身的类加载器调用findClass方法返回相应字节码，如果还没有找到抛出异常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载器采用了设计模式是模板方法，也就是LoadClass方法是不需要进行改变的，我们需要关注的就是findClass()方法就好了。所以我们写自己的ClassLoader只需要继承ClassLoader并重写findClass方法即可。</span><br></pre></td></tr></table></figure></p><p>参考地址：<br><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a><br><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态代理的工作原理简要分析</title>
      <link href="/2018/09/20/how-dynamic-agents-work/"/>
      <url>/2018/09/20/how-dynamic-agents-work/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#动态代理的工作原理">1. 动态代理的工作原理</a><ul><li><a href="#什么是代理">1.1. 什么是代理</a></li><li><a href="#什么是动态代理">1.2. 什么是动态代理</a></li><li><a href="#动态代理的原理">1.3. 动态代理的原理</a></li><li><a href="#实现AOP功能的封装和配置">1.4. 实现AOP功能的封装和配置</a></li></ul></li></ul><h1 id="动态代理的工作原理"><a href="#动态代理的工作原理" class="headerlink" title="动态代理的工作原理"></a>动态代理的工作原理</h1><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>比如说我们去租房子，需要通过中介代理来进行看房子，由于代理的手中有大量资源，有大部分房源都在代理手中掌握，所以不需要我们自己去一个一个去找寻，通过这样我们无需知道房东是谁就可以租到合适的房子，这就是代理，代理模式两个优点一是可以隐藏委托类的实现，二是可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><h2 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h2><p>代理类在运行时创建的过程叫做动态代理。也就是说这个代理类不是我们是事先写好的，而是由程序运行时自动生成的代理类，比如我们举一个静态代理例子：<br>我们首先定义一个接口<code>ISayHello</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个被代理对象：<code>SayHello</code>，并且继承自上面的接口，并实现接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> <span class="keyword">implements</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"hello world proxy！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是重点我们接下来要写代理类，代理类和被代理类之间是依赖组合关系，也就是说被代理类和代理类是同时存在的，也就是生命周期是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayProxy</span> <span class="keyword">implements</span> <span class="title">ISayHello</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> SayHello sayHello;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SayProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sayHello=<span class="keyword">new</span> SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">before();</span><br><span class="line">sayHello.sayHello();</span><br><span class="line">after();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello Before"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello After"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以达到动态扩充被代理类的内容，上面的内容是静态的动态代理，也就是代理类是我们已经写好的，接下来我们就要演示如何实现动态代理类。</p><h2 id="动态代理的原理"><a href="#动态代理的原理" class="headerlink" title="动态代理的原理"></a>动态代理的原理</h2><ol><li>JVM可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理。</li><li>JVM生成的代理类必须实现一个或多个接口，所以JVM生成的动态代理类只能用作具有相同接口的目标类代理。</li><li>CGLIB库可以生成一个类的子类，一个类的子类也可以用作该类的代理，所以如果要为一个没有实现接口的类生成动态代理类那么可使用CGLIB。</li></ol><p>Java提供了相应的代理类<code>java.lang.reflect.Proxy</code>，通过这个类能够动态生成代理类对象，接下来我们来做一下演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理相关内容实现</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);</span><br><span class="line">System.out.println(<span class="string">"代理类名称："</span> + clazz.getName(System.out.println(<span class="string">"代理类类加载器："</span> + clazz.getClassLoader());</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor item : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名字："</span> + item.getName());</span><br><span class="line">Parameter[] parameters = item.getParameters();</span><br><span class="line"><span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数类型："</span> + parameter.getParameterizedType() + <span class="string">"参数名称："</span> + parameter.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取<code>Collection</code>的代理类，Proxy提供了<code>getProxyClass</code>方法来进行获取代理类，这个方法有两个参数，第一个参数是加载这个代理类对象的类加载器，第二个参数是代理类对象实现的接口。我们来看一下输出结果内容：</p><p>代理类名称：<code>com.sun.proxy.$Proxy0</code></p><p>代理类类加载器：<code>null</code></p><p>方法名字：<code>com.sun.proxy.$Proxy0</code> </p><p>参数类型：<code>interface java.lang.reflect.InvocationHandler</code> 参数名称：<code>arg0</code></p><p>分析一下上面代码内容，首先我们创建了实现<code>Collection</code>接口的动态代理类对象，并返回动态代理类的字节码，这时候我们用反射方式查看一下动态代理对象的构造方法以及动态代理对象的名称和动态代理构造器方法。<br>我们仔细看到加载<code>com.sun.proxy.$Proxy0</code>的类加载器是<code>Bootstrap</code>类加载器，由于<code>Collection</code>加载器就是<code>Bootstrap</code>类加载器。所以返回的是<code>null</code>，因为该类加载器不是java实现的。构造函数的参数类型是InvocationHandler这个接口类型主要是做什么呢？我们接下俩一步一步来进行解密，这里留一下一个小小的悬念。<br>接下来通过反射的方式获取下当前代理类所实现的方法有哪些：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名称："</span> + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">方法名称：add  </span><br><span class="line">方法名称：remove  </span><br><span class="line">方法名称：equals  </span><br><span class="line">方法名称：toString  </span><br><span class="line">方法名称：hashCode  </span><br><span class="line">方法名称：clear  </span><br><span class="line">方法名称：contains  </span><br><span class="line">方法名称：isEmpty  </span><br><span class="line">方法名称：iterator  </span><br><span class="line">方法名称：size  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：spliterator  </span><br><span class="line">方法名称：addAll  </span><br><span class="line">方法名称：stream  </span><br><span class="line">方法名称：forEach  </span><br><span class="line">方法名称：containsAll  </span><br><span class="line">方法名称：removeAll  </span><br><span class="line">方法名称：removeIf  </span><br><span class="line">方法名称：retainAll  </span><br><span class="line">方法名称：parallelStream  </span><br><span class="line">方法名称：isProxyClass</span><br><span class="line">方法名称：getInvocationHandler  </span><br><span class="line">方法名称：newProxyInstance  </span><br><span class="line">方法名称：getProxyClass  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：getClass    </span><br><span class="line">方法名称：notify  </span><br><span class="line">方法名称：notifyAll</span><br></pre></td></tr></table></figure></p><p>由于代理类实现了Collection接口，所以接口中所有类方法都会被继承，还有Object中的方法，当然Object中不是所有方法都会交给代理类来执行，只有<code>hashCode,equals和toString方法</code>会交给代理类处理。也就是说当我们调用collection.getClass()会输出com.sun.proxy.$Proxy0而不是输出目标对象ArrayList，这就说明Object中的方法不是所有方法都派发给目标对象来执行，只有上面说的三个方法才会委托给InvocationHandler中的invoke方法来进行执行。而其他的方法有自己的实现。<br>  到这里我们的动态代理对象字节码分析完毕，这时候我们要创建动态代理的对象实例。<br>我们上面了解到动态代理对象是只有一个构造函数，这个构造函数传递参数是InvocationHandler接口，这时候我们就需要创建一个自己MyInvocationHandler对象实现InvocationHandler接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line">ArrayList target = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用前:"</span> + method.getName());</span><br><span class="line"><span class="comment">//代理对象方法调用</span></span><br><span class="line">Object o = method.invoke(target, args);</span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用后:"</span> + method.getName());</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来详细分析下这个接口中的方法，该接口中只有一个方法，也就是invoke方法，这个方法主要是什么作用呢？当我们调用代理类的方法是首先会调用MyInvocationHandler中invoke方法，通过调用这个方法来调用目标对象的方法体。实际上动态代理类实现的方法如下所示，例如我们现在实现的Collection接口的size方法，代理类对象的方法大致实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  $Proxy0  implements Collection&#123;</span><br><span class="line"></span><br><span class="line">InvocationHandler hander;</span><br><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler  handler)&#123;</span><br><span class="line"><span class="keyword">this</span>.handler=handler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> handler.invoke(<span class="keyword">this</span>,<span class="keyword">this</span>.getClass().getMethod(“size”),<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Handler的invoke 方法三要素：代理对象，代理对象方法，代理对象参数。<br>也就是说代理对象首先先调用我们构造函数中传递的handler对象的invoke方法，通过调用invoke方法来调用目标对象中存在的size方法。这也是Aop的原理，AOP的实现就是用了动态代理的方式进行操作的，目标对象返回的结果就是代理类返回的结果。<br>创建动态代理对象如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getConstructor(InvocationHandler.class);</span><br><span class="line">Collection collection = (Collection) constructor.newInstance(<span class="keyword">new</span> MyInvocationHandler());</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br></pre></td></tr></table></figure></p><p>这时候输出结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:size  </span><br><span class="line">方法调用后:size  </span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>正如我们上面分析的内容，我们来看一下动态代理类内部结构图：<br><img src="/2018/09/20/how-dynamic-agents-work/./pic1.png" alt="代理内部结构图" title="动态代理类内部结构图">  </p><p>当客户端调用代理对象的方法时，首先先经过InvocationHandler的invoke方法，这个方法体中可以扩充我们想要的内容，比如前置通知，后置通知，参数过滤等一系列操作，然后再通过该方法传入的method调用目标对象的方法，达到代理的作用。  </p><h2 id="实现AOP功能的封装和配置"><a href="#实现AOP功能的封装和配置" class="headerlink" title="实现AOP功能的封装和配置"></a>实现AOP功能的封装和配置</h2><p>实现思路是我们在配置文件中配置我们需要代理的目标对象，通知对象，通过配置文件进行切换是否生成代理对象，通过代理对象工厂进行判断是否生成代理类。工厂类BeanFactory负责创建目标类或代理类的实例对象，其getBean方法根据参数字符串返回一个响应的实例对象，也就是上面是通过ProxyFactoryBean进行判断是否生成代理对象，如果配置文件中配置的对象为ProxyFactoryBean的话，通过调用ProxyFactoryBean中的getProxy生成代理对象并返回，反之直接创建该对象实例并返回。<br>直接上代码首先看一下BeanFactory，主要是创建代理对象或者非代理对象实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//从配置文件中读取相应配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanFactory</span><span class="params">(InputStream ips)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   properties.load(ips);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String className = properties.getProperty(name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object bean = clazz.newInstance();</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ProxyFactoryBean) &#123;</span><br><span class="line">ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean) bean;</span><br><span class="line">String tagertClassName = properties.getProperty(name + <span class="string">".target"</span>);</span><br><span class="line">Class tagertClazz = Class.forName(tagertClassName); String adviceClassName = properties.getProperty(name + <span class="string">".advice"</span>);Class adviceClazz = Class.forName(adviceClassName); proxyFactoryBean.setAdvice((Advice)adviceClazz.newInstance());</span><br><span class="line">proxyFactoryBean.setTarget(tagertClazz.newInstance());</span><br><span class="line"><span class="keyword">return</span> proxyFactoryBean.getProxy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line"> System.out.println(ex.getMessage()); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码主要内容是首先构造函数是InputStream流用来加载properties配置文件的内容，配置相关内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean</span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice</span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>xxx也就是我们要获取的bean对象，如果对象类型为ProxyFactoryBean的话，就给该对象设置代理对象和通知对象。接下来我们看看ProxyFactoryBean中到底做了什么东西？前面我们已经提到了ProxyFactoryBean主要是创建代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得代理类</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Advice通知</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">                getTarget().getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        getAdvice().before();</span><br><span class="line">                        Object result = method.invoke(getTarget(), args);</span><br><span class="line">                        getAdvice().after();</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>target主要是目标代理对象，也就是我们要代理的目标对象，Advice对象主要是我们的通知对象，通知对象中只包含前置通知和后置通知这两个。主要是getProxy获取代理对象这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">getTarget().getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">getAdvice().before();</span><br><span class="line">Object result = method.invoke(getTarget(), args);</span><br><span class="line">getAdvice().after();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中我们可以看到直接调用了Proxy.newProxyInstance方法，而不再是调用Proxy.getClassProxy这个方法获取字节码的方式，这就告诉我们Proxy的创建可以分为两种方式进行创建，这种方式比较简便，方法中有三个参数第一个参数指定类加载器，第二个参数是代理对象要实现的接口有哪些，第三个方法就是InvocationHandler，这里我们传入的参数目标类的加载器，以及目标类实现的接口，第三个参数我们这边才用的是匿名内部类的方式传递。其中Invoke方法中要调用目标对象的方法，也就是method.invoke(target,args);<br>接下来我们看一下通知类Advice中写了什么内容。<br>首先我们声明了接口Advice<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又写了MyAdvice类继承并实现Advice接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通知方法中没有写太多东西就是输出一些信息表示已经应用了通知内容。<br>接下来就是调用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream ips = TestApplication.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">Object bean = <span class="keyword">new</span> com.test.Aop.BeanFactory(ips).getBean(<span class="string">"xxx"</span>);</span><br><span class="line">Collection collection = (Collection) bean;</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">collection.add(<span class="string">"444"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br><span class="line">System.out.println(bean.getClass().getName());</span><br></pre></td></tr></table></figure></p><p>由于我是用Spring boot 搭建的项目所以配置文件名称为application.properties，这个不重要，重要的是配置文件内容，上面我已经提到了第一种配置内容为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean  </span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice  </span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>当我们调用getBean获取xxx时，如果xxx配置为ProxyFactoryBean的话就会创建代理类我们看一下输出内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">4</span><br><span class="line">com.sun.proxy.<span class="variable">$Proxy0</span></span><br></pre></td></tr></table></figure></p><p>最后输出内容为￥Proxy0表示创建代理对象成功，并调用了通知方法，如果配置文件修改为如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx= java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>输出内容则为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>因为没有创建代理对象所以获取类型是返回ArrayList类型。完结  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的blog之旅又要开始了</title>
      <link href="/2018/09/18/hello-world/"/>
      <url>/2018/09/18/hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">距离我的个人博客服务器到期到现在也有一段时间了，这段时间里面已经停止了些东西，最近要把写文章这件事慢慢的拾起来，制定写作计划。</span><br></pre></td></tr></table></figure><h2 id="博客主要内容"><a href="#博客主要内容" class="headerlink" title="博客主要内容"></a>博客主要内容</h2><p>博客主要内容是针对技术的分享与交流，主要技术有spring，spring boot，spring cloud，java，mybatis等技术框架的技术分享，也业余分享python等，大数据相关技术的内容的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
