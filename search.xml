<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>LinkedBlockingQueue原理解析</title>
      <link href="/2019/04/07/LinkedBlockingQueue-Principle/"/>
      <url>/2019/04/07/LinkedBlockingQueue-Principle/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedBlockingQueue原理详解"><a href="#LinkedBlockingQueue原理详解" class="headerlink" title="LinkedBlockingQueue原理详解"></a>LinkedBlockingQueue原理详解</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>前面已经介绍过关于ArrayBlockingQueue相关原理性内容，我们前面讲过ArrayBlockingQueue是基于数组的方式实现的，那么LinkedBlockingQueue是基于链表的形式实现。先来看一下LinkedBlockingQueue的UML，如下所示：</p><p><img src="/2019/04/07/LinkedBlockingQueue-Principle/1.png" alt="image-20190407143028626"></p><p>通过上面的UML可以看到，他也是BlockingQueue的实现，也就是他的核心在于Blocking（阻塞）这个上面，在讲解ArrayBlockingQueue的时候，可以清晰的得出ArrayBlockingQueue是使用了独占锁的方式，要求两个操作进行时获得当先队列的独占锁，那么take()和put()操作就不可能真正的并发。它们会彼此等待对方释放资源，在这种情况下所竞争会比较激励，从而会影响到高并发的效率，而LinkedBlockingQueue为了解决这一问题，采用<code>锁分离</code>的方式进行实现，take()函数和put()函数分别实现了从队列中取得数据和往队列天价收的功能，换句话说就会说take()方法有专门的锁进行控制，而put()方法也有专门的锁进行控制，由于take()方法是操作队尾，put()方法操作队首，又因为LinkedBlockingQueue是基于链表的方式实现，因此两个操作不受影响。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>首先看一下LinkedBlockingQueue中的字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的Node节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点，如果节点为Null代表最后一个节点</span></span><br><span class="line"><span class="comment">     * - the real successor Node</span></span><br><span class="line"><span class="comment">     * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">     * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 容量限制,如果没有指定则为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前队列的元素个数，原子操作 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头结点</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾节点</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**take, poll的重入锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 不为空的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** put, offer的重入锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队满条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><ol><li>Node节点维护链表的信息。</li><li>最大容量限制，用户可自己指定，如果没有指定则代表Integer的最大值。</li><li>包含了head头结点，tail尾节点。</li><li>takeLock代表的是take，poll等出队列操作的锁。</li><li>putLock代表是put，offer等入队列的操作的锁。</li></ol><p>接下来看一下put方法是如何进行入队操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此队列的尾部, 等待队列空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// 保持计数为负，表示失败，除非设定。</span></span><br><span class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">  <span class="comment">// putLock锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">  <span class="comment">// 链表长度，原子操作。</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="comment">// 获得锁，并且响应中断，put操作只有一个线程操作。</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表长度等着capacity，代表队列已满，则等待队列为空。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 将元素插入队列末尾。</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">      <span class="comment">// c为count加1前的值，这里是原子操作，它会进行CAS，因为现在是两个线程进行操作，有可能put的时候也进行take操作，所以要保证原子性。</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">      <span class="comment">// 当c+1不是最大值时，通知notFull，队列未满可继续添加元素，通知其他线程。</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// c代表插入前的的值，所以队列为空的时候c=0，此时已经插入了数据所以c本来应该不为0，所以需要通知队列元素插入成功。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以清晰得到put方法是如何进行操作的，首先获取putLock锁，获取队列的原子类型的长度，如果当前队列的长度与队列最大长度相等说明队列未满，则等待队列为空的时候插入数据，当队列未满时，可直接插入数据到队尾，c存放的事count元素加1前的值，也就是谁队列为空的时候c的长度是为0，当执行完了put方法后，实际的count为1，但是这里因为存放的是加1前的值，所有c=0，代表队列中有数据通知notEmpty可以进行take了。</p><p>enqueue方法源码很简单，就是将node节点插入到队尾，将last节点指向当前队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说一下take方法的源码是如何实现的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队头获取元素，等待队列有数据可读。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">  <span class="comment">// 本地保存变量。</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 队列长度。</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">  <span class="comment">// 获取take重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">  <span class="comment">// 获得锁，并且响应中断操作，并且只有一个线程进入take方法。</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果队列为空则等待队列不为空时进行获取操作。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 出队列操作。</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">      <span class="comment">// c保存减1前的值。</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">      <span class="comment">// 如果队列还有元素则可通知其他线程进行take操作。</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// c如果是capacity的时候代表之前队列存在过满的情况，进行take方法后则表示队列有空间可用可进行put操作，通知notFull进行put操作。</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码可以看到，take方法获取的是takeLock重入锁，并且当前线程进入到take方法后，其他线程是不允许同时进入到take方法中，首先判断队列的长度是不是为0，如果队列为0则代表队列中无数据可消费，则进行等待，等待队列中有元素时进行take后的操作，如果队列长度不为0，则进行dequeue方法，出队列操作，将head节点指向下一个节点，将当前head值返回，当c大于1时，代表还有元素可以take，通知其他线程进行take操作，c如果是capacity的时候，代表之前队列存在过满的情况，进行这次take方法后队列有空间可用，所以可以通知notFull进行put操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// 帮助GC进行垃圾回收。</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LinkedBlockingQueue是通过锁分离的方式进行控制，减少了take和put之间的锁竞争。</li><li>LinkedBlockingQueue是通过链表的方式实现，所以进行锁分离时不会冲突，因为入队和出队分别作用于队尾和队首。</li><li>内部采用了原子操作类（CAS）进行控制链表长度。</li><li>入队后，如果之前队列为空时，会通知take方法，队列已有数据可进行take，反之，出队后，队列之前已满，则通知put方法，队列已有空闲位置可进行put操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayBlockingQueue原理详解</title>
      <link href="/2019/04/06/arrayblockingqueue-principle/"/>
      <url>/2019/04/06/arrayblockingqueue-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayBlockingQueue原理详解"><a href="#ArrayBlockingQueue原理详解" class="headerlink" title="ArrayBlockingQueue原理详解"></a>ArrayBlockingQueue原理详解</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ArrayBlockingQueue是基于数组实现的共享通道，为什么说是共享通道，假说线程A希望给线程B发一个消息，用什么方式来告知线程B是比较合适的呢？可以使用BlockingQueue来实现。</p><p><img src="/2019/04/06/arrayblockingqueue-principle/1554447867621.jpg" alt=""></p><p>通过上图中的继承关系我们可以清晰的发现ArrayBlockingQueue是BlockingQueue接口的实现，通过名称可以得出它是基于数组实现的，所以更适合做有界的队列。</p><p>​    刚才也提到过它是作为数据共享来进行的线程间数据的传递，那么问题来了，当队列中为空的时候消费队列的线程如何知道队列中有新的元素添加进去，队列满的时候又如何进行处理？我们带着上面的疑问来进行下面的分析。</p><p>主要的队列的入队、出队操作如下表所示：</p><h3 id="插入队列方法"><a href="#插入队列方法" class="headerlink" title="插入队列方法"></a>插入队列方法</h3><table><thead><tr><th>方法名称</th><th>参数描述</th><th>返回值</th><th>异常信息</th></tr></thead><tbody><tr><td>add</td><td>插入对象</td><td>ture代表插入成功，如果队列已满，抛出异常</td><td>IllegalStateException(“Queue full”)异常——AbstractQueue</td></tr><tr><td>offer</td><td>插入对象</td><td>true代表插入成功，队列已满直接返回false</td><td>无</td></tr><tr><td>offer</td><td>插入对象，等待时间</td><td>true代表插入成功，队列已满等待一段时间后仍没有空间则返回false</td><td>无</td></tr><tr><td>put</td><td>插入对象</td><td>true代表插入成功，如果队列已满则阻塞线程等待队列为空的时候插入</td></tr></tbody></table><h3 id="获取队列内容"><a href="#获取队列内容" class="headerlink" title="获取队列内容"></a>获取队列内容</h3><table><thead><tr><th>方法名称</th><th>参数描述</th><th>返回值</th><th>异常信息</th></tr></thead><tbody><tr><td>remove</td><td>无</td><td>返回队首数据并移除，队列已空则抛出异常信息</td><td>NoSuchElementException()异常——AbstractQueue</td></tr><tr><td>poll</td><td>无</td><td>列不为空时返回队首值并移除；队列为空时返回null。非阻塞立即返回。</td><td></td></tr><tr><td>poll</td><td>等待时间</td><td>设定等待的时间，如果在指定时间内队列还未孔则返回null，不为空则返回队首值</td><td></td></tr><tr><td>take</td><td>无</td><td>队列不为空返回队首值并移除；当队列为空时会阻塞等待，一直等到队列不为空时再返回队首值。</td></tr></tbody></table><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>上面的方法中重点的内容在于put和take方法，我们以一个实例来看一下这个队列的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayBlockingQueue内容测试demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href="mailto:dwlsxj@126.com"&gt;battleheart&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">"预备入队"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    arr.put(i);</span><br><span class="line">                    System.out.println(i + <span class="string">"入队成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"进入消费队列"</span>);</span><br><span class="line">                    System.out.println(arr.take());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>开启了两个线程，一个是提供数据的线程，一个是消费数据的线程</li><li>入队操作之前进行了睡眠，目的是先让消费线程进行消费队列，然后队列数据提供线程再往线程中提供数据。</li><li>出队的操作中添加了sleep方法，目的是为了能让入队的内容多一些。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">进入消费队列</span><br><span class="line"><span class="number">0</span>预备入队</span><br><span class="line"><span class="number">0</span>入队成功</span><br><span class="line"><span class="number">1</span>预备入队</span><br><span class="line"><span class="number">1</span>入队成功</span><br><span class="line"><span class="number">2</span>预备入队</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span>入队成功</span><br><span class="line"><span class="number">3</span>预备入队</span><br><span class="line"><span class="number">3</span>入队成功</span><br><span class="line"><span class="number">4</span>预备入队</span><br><span class="line"><span class="number">4</span>入队成功</span><br><span class="line"><span class="number">5</span>预备入队</span><br><span class="line"><span class="number">5</span>入队成功</span><br><span class="line"><span class="number">6</span>预备入队</span><br><span class="line"><span class="number">6</span>入队成功</span><br><span class="line"><span class="number">7</span>预备入队</span><br><span class="line"><span class="number">7</span>入队成功</span><br><span class="line"><span class="number">8</span>预备入队</span><br><span class="line"><span class="number">8</span>入队成功</span><br><span class="line"><span class="number">9</span>预备入队</span><br><span class="line"><span class="number">9</span>入队成功</span><br><span class="line"><span class="number">10</span>预备入队</span><br><span class="line"><span class="number">10</span>入队成功</span><br><span class="line"><span class="number">11</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">11</span>入队成功</span><br><span class="line"><span class="number">12</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">12</span>入队成功</span><br><span class="line"><span class="number">13</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">13</span>入队成功</span><br><span class="line"><span class="number">14</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">14</span>入队成功</span><br><span class="line"><span class="number">15</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">15</span>入队成功</span><br><span class="line"><span class="number">16</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">16</span>入队成功</span><br><span class="line"><span class="number">17</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">17</span>入队成功</span><br><span class="line"><span class="number">18</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">18</span>入队成功</span><br><span class="line"><span class="number">19</span>预备入队</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">19</span>入队成功</span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">10</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">11</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">12</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">13</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">14</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">15</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">16</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">17</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">18</span></span><br><span class="line">进入消费队列</span><br><span class="line"><span class="number">19</span></span><br><span class="line">进入消费队列</span><br></pre></td></tr></table></figure><p>分析上述输出内容：</p><p><code>进入消费队列</code>文字输出出来说明数据提供者线程在休眠状态，而消费者线程在执行任务，在等待100ms后，<code>0</code>入队成功，<code>1</code>入队成功，当<code>2</code>准备入队时，这时候消费者线程获得了锁，消费了队列中的<code>0</code>,以此类推，最有一个<code>进入消费队列</code>说明队列为空等待队列不为空时，take方法进行消费。</p><p>通过输出结果可以得出以下内容：</p><ol><li>消费线程先进入，但是并没有执行完，也就是说消费线程一直等待的状态。</li><li>入队和出队只能同步进行一项，也就是入队操作会阻止出队操作，出队操作也会阻止入队操作。</li></ol><h2 id="内部原理解析"><a href="#内部原理解析" class="headerlink" title="内部原理解析"></a>内部原理解析</h2><p>ArrayBlockingQueue内部定义了以下的字段信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列元素数组 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下一个被take，poll，peek，remove的元素位置 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 插入位置包含put，offer，add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列元素的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 重入锁 */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列不为空的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列满时的条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p>当执行take()操作的时候，如果队列为空，则在notEmpty出等待，同时也会进行notFull的通知，通知notFull队列已经有位置可以进行入队操作了。新元素入队时，调用put方法时，如果队列满了，则当前线程暂停在notFull上，同时会进行一次notEmpty的通知，通知notEmpty队列已经有内容可，可以进行下面的内容了。</p><p>put方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素插入到队尾, 并且当队列中满的进行等待操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">  <span class="comment">//获得重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">//这里可以相应中断操作。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断队列是否已经满了。</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">          <span class="comment">//如果满了就在这里等待，等待通知队列为空时，进行相应。</span></span><br><span class="line">            notFull.await();</span><br><span class="line">      <span class="comment">//入队操作。</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源代码可以得到以下内容：</p><ol><li>获得重入锁进行入队同步操作，这也说明入队和出队只能同时进行一种操作的原因。</li><li>判断队列元素是否已经达到了队列的长度，也就是队列是否已经装满，如果装满则进行等待队列中有空余位置为止。</li><li>入队操作。</li></ol><p>接下来详细看一下入队操作是如何进行的,enqueue源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前putIndex位置插入元素, 并且通知notEmpty队列已经有内容.</span></span><br><span class="line"><span class="comment"> * 只有在获得锁的情况下执行.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">  <span class="comment">// 队列数组。</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">  <span class="comment">// 在putIndex的位置插入x。</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 进行循环操作，如果putIndex到了队尾则将putIndex索引指向队头。</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列数量加1</span></span><br><span class="line">    count++;</span><br><span class="line">  <span class="comment">// 通知notEmpty队列已经有内容可以进行消费。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下take方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * take方法从队列中获取元素，并且如果队列为空时进行notEmpty等待。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获得重入锁。</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 响应中断请求。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果队列为空，则进行notEmpty等待。</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">      <span class="comment">// 出队操作。</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面源码我们也可以看到如下内容：</p><ol><li>出队前必须先获得锁，才能进行操作。</li><li>队列为空时，进行notEmpty等待。</li></ol><p>dequeue方法源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出takeIndex元素信息,并且通知notFull队列已经有空余位置。</span></span><br><span class="line"><span class="comment"> * 执行必须先获得锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">  <span class="comment">// 队列元素。</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="comment">// 获取takeIndex索引信息。</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将takeIndex标记为null，方便GC进行回收。</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 循环进行操作。</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列元素数量减1</span></span><br><span class="line">    count--;</span><br><span class="line">  <span class="comment">// 迭代器进行take</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 通知notFull队列已经不再满，可进行put操作。</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对源码put和take 的分析总结一下几点：</p><ol><li>ArrayBlockingQueue是采用数组进行实现队列，通过putIndex和takeIndex来控制队列的队头和队尾。</li><li>内部使用ReentrantLock进行同步操作，并配合Condition处理等待操作。</li><li>总结成下面的图片内容：</li></ol><p><img src="/2019/04/06/arrayblockingqueue-principle/2.png" alt=""></p><p>下面来用图示法讲解下ArrayBlockingQueue的工作原理</p><p>首先将元素1进行入队操作，如下图所示：</p><p><img src="/2019/04/06/arrayblockingqueue-principle/1.png" alt=""></p><p>putIndex和takeIndex在同一个位置，因为他只有一个元素，当再依次入队8个元素后内容如下所示</p><p><img src="/2019/04/06/arrayblockingqueue-principle/3.png" alt=""></p><p>此时putIndex就到了最后一个数组的元素的索引上，当再向数组元素中添加元素时，就会进行notFull的等待操作</p><p><img src="/2019/04/06/arrayblockingqueue-principle/4.png" alt=""></p><p>当调用take方法后，队列中出现了空余位置，并且通知了notFull，嘿，伙计你可以将你的东西添加到队列中了。</p><p><img src="/2019/04/06/arrayblockingqueue-principle/5.png" alt=""></p><p>可以清晰的看到putIndex变到了数组索引0的位置，就是下面的代码导致的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>并且此时的takeIndex便到了数组索引1的位置，持续进行take方法，队列内容全部出队列：</p><p><img src="/2019/04/06/arrayblockingqueue-principle/6.png" alt=""></p><p>当take方法走到数组的末尾时，它会将takeIndex值设置为0，进行从新开始take。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">    takeIndex = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>并且当队列为空时，会进行notEmpty等待，等待队列中存在元素，当调用put方法后，它会通知notEmpty，兄弟你可以取队列消息了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阻塞算法和非阻塞算法</title>
      <link href="/2019/03/28/block-and-lock-free/"/>
      <url>/2019/03/28/block-and-lock-free/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞算法和非阻塞算法"><a href="#阻塞算法和非阻塞算法" class="headerlink" title="阻塞算法和非阻塞算法"></a>阻塞算法和非阻塞算法</h1><h2 id="阻塞算法"><a href="#阻塞算法" class="headerlink" title="阻塞算法"></a>阻塞算法</h2><p><strong>阻塞算法步骤</strong>：</p><ol><li>执行线程请求的操作。</li><li>阻塞争抢资源的线程，直到线程资源被释放，才有机会执行线程请求操作。</li></ol><p><img src="/2019/03/28/block-and-lock-free/1.png" alt="阻塞算法"></p><p>​    上图表明了阻塞算法的流程，线程A和线程B同时争抢临界区资源，线程A优先争抢到资源，这时候线程B争抢资源时，发现临界区资源已经被其他线程占用，线程B只能等待线程A释放资源后才能获取资源，阻塞线程B执行，阻塞的线程不会执行任何内容，等待线程A执行结束，当线程A执行结束释放资源后，线程B争抢到资源执行下面的流程。</p><h2 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h2><p><strong>非阻塞算法步骤</strong></p><ol><li>执行线程请求参数。</li><li>其他线程可以进入临界区，并且通知请求不能被执行，一直请求执行操作，直到执行线程操作。</li></ol><p><img src="/2019/03/28/block-and-lock-free/2.png" alt="非阻塞算法"></p><p>​    线程A和线程B申请临界区资源，线程A优先申请到资源，线程A正常执行，线程B申请临界区资源时，发现线程B正在执行操作，线程B直接被驳回申请，线程B进入下一轮的申请操作，直到申请成功。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你必须知道的多线程几个概念</title>
      <link href="/2019/03/28/you-have-to-know-the-concept-of-multithreading/"/>
      <url>/2019/03/28/you-have-to-know-the-concept-of-multithreading/</url>
      
        <content type="html"><![CDATA[<h1 id="你必须知道多线程几个概念"><a href="#你必须知道多线程几个概念" class="headerlink" title="你必须知道多线程几个概念"></a>你必须知道多线程几个概念</h1><h2 id="同步（Synchronous）、异步（Asynchronous）"><a href="#同步（Synchronous）、异步（Asynchronous）" class="headerlink" title="同步（Synchronous）、异步（Asynchronous）"></a>同步（Synchronous）、异步（Asynchronous）</h2><ol><li>同步方法调用一旦开始，就必须等待方法执行完之后，才能继续后续的行为。</li><li>异步方法更像是消息传递，一旦开始，方法调用就会返回结果，调用者就可以继续后续的行为。</li></ol><p><img src="/2019/03/28/you-have-to-know-the-concept-of-multithreading/image-20190308223510003.png" alt="image-20190308223510003"></p><h2 id="并发（Concurrency）和并行"><a href="#并发（Concurrency）和并行" class="headerlink" title="并发（Concurrency）和并行"></a>并发（Concurrency）和并行</h2><ol><li>并发：指的是多个任务交替执行，而多个任务之间有可能还是串行的。</li><li>并行：并行多个任务之间是真实同时执行。</li></ol><p><img src="/2019/03/28/you-have-to-know-the-concept-of-multithreading/image-20190308225730993.png" alt="image-20190308225730993"></p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程必须等待。</p><h2 id="阻塞（Blocking）和非阻塞（Non-Blocking）"><a href="#阻塞（Blocking）和非阻塞（Non-Blocking）" class="headerlink" title="阻塞（Blocking）和非阻塞（Non-Blocking）"></a>阻塞（Blocking）和非阻塞（Non-Blocking）</h2><p>阻塞和非阻塞用来形容多线程之间的相互影响。</p><p>阻塞：指的是资源占用的情况下，其他线程想要获取资源，此时必须阻塞其他线程访问。</p><p>非阻塞：强调没有一个线程可以妨碍其他线程执行。</p><h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><p>死锁：谁都不愿意释放自己，这个状态一直维持下去，谁都别想争抢到资源。</p><p>饥饿：指某一个或者多个线程因为种种原因无法或得所需要的资源，导致一直无法执行。（比如线程优先级低，每次要执行时，都被线程优先级高的先执行，一直执行不了）</p><p>活锁：指的是线程都秉承“谦让”的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot快速整合dubbo</title>
      <link href="/2019/02/25/spring-boot-and-dubbo-starter/"/>
      <url>/2019/02/25/spring-boot-and-dubbo-starter/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot与Dubbo进行整合"><a href="#Spring-Boot与Dubbo进行整合" class="headerlink" title="Spring Boot与Dubbo进行整合"></a>Spring Boot与Dubbo进行整合</h1><h2 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="服务提供端-provider"><a href="#服务提供端-provider" class="headerlink" title="服务提供端-provider"></a>服务提供端-provider</h2><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboProviderApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .listeners((ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt;) event -&gt; &#123;</span><br><span class="line">                    Environment environment = event.getEnvironment();</span><br><span class="line">                    <span class="keyword">int</span> port = environment.getProperty(<span class="string">"embedded.zookeeper.port"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                    <span class="keyword">new</span> EmbeddedZooKeeper(port, <span class="keyword">false</span>).start();</span><br><span class="line">                &#125;)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ApplicationEnvironmentPreparedEvent</code>监听环境变量预处理事件</li><li>通过事件方式连接Zk</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Demo Service实现层。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, loadbalance = <span class="string">"roundrobin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务提供端通过dubbo的<code>@Service</code>注解进行服务的提供</li></ol><h3 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># SpringBoot应用名称</span><br><span class="line">spring.application.name=dubbo-registry-zookeeper-provider-sample</span><br><span class="line"># 扫描的Service包地址</span><br><span class="line">dubbo.scan.base-packages=com.battleheart.dubboprovider</span><br><span class="line"># Zookeeper的端口号</span><br><span class="line">embedded.zookeeper.port=2181</span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Dubbo注册地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">## dubbo服务版本号</span><br><span class="line">demo.service.version=1.0.0</span><br><span class="line"># 服务端口</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><h2 id="服务消费端-customer"><a href="#服务消费端-customer" class="headerlink" title="服务消费端-customer"></a>服务消费端-customer</h2><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=annotation-consumer</span><br><span class="line">embedded.zookeeper.port=2181</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">dubbo.consumer.timeout=3000</span><br></pre></td></tr></table></figure><h1 id="EmbeddedZooKeeper"><a href="#EmbeddedZooKeeper" class="headerlink" title="EmbeddedZooKeeper"></a>EmbeddedZooKeeper</h1><p><code>EmbeddedZooKeeper</code>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedZooKeeper</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Logger.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EmbeddedZooKeeper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZooKeeper client port. This will be determined dynamically upon startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> clientPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether to auto-start. Default is true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> autoStartup = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle phase. Default is 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread for running the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread zkServerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ZooKeeperServerMain zkServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked if an Exception is thrown from the ZooKeeper server thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ErrorHandler errorHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct an EmbeddedZooKeeper with a random port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedZooKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clientPort = SocketUtils.findAvailableTcpPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct an EmbeddedZooKeeper with the provided port.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientPort port for ZooKeeper server to bind to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmbeddedZooKeeper</span><span class="params">(<span class="keyword">int</span> clientPort, <span class="keyword">boolean</span> daemon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientPort = clientPort;</span><br><span class="line">        <span class="keyword">this</span>.daemon = daemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the port that clients should use to connect to this embedded server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> dynamically determined client port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getClientPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clientPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify whether to start automatically. Default is true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoStartup whether to start automatically</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoStartup</span><span class="params">(<span class="keyword">boolean</span> autoStartup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.autoStartup = autoStartup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autoStartup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify the lifecycle phase for the embedded server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phase the lifecycle phase</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phase = phase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (zkServerThread != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start the ZooKeeper server in a background thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Register an error handler via &#123;<span class="doctag">@link</span> #setErrorHandler&#125; in order to handle</span></span><br><span class="line"><span class="comment">     * any exceptions thrown during startup or execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkServerThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zkServerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerRunnable(), <span class="string">"ZooKeeper Server Starter"</span>);</span><br><span class="line">            zkServerThread.setDaemon(daemon);</span><br><span class="line">            zkServerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shutdown the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zkServerThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The shutdown method is protected...thus this hack to invoke it.</span></span><br><span class="line">            <span class="comment">// This will log an exception on shutdown; see</span></span><br><span class="line">            <span class="comment">// https://issues.apache.org/jira/browse/ZOOKEEPER-1873 for details.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method shutdown = ZooKeeperServerMain.class.getDeclaredMethod(<span class="string">"shutdown"</span>);</span><br><span class="line">                shutdown.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                shutdown.invoke(zkServer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// It is expected that the thread will exit after</span></span><br><span class="line">            <span class="comment">// the server is shutdown; this will block until</span></span><br><span class="line">            <span class="comment">// the shutdown is complete.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zkServerThread.join(<span class="number">5000</span>);</span><br><span class="line">                zkServerThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                logger.warn(<span class="string">"Interrupted while waiting for embedded ZooKeeper to exit"</span>);</span><br><span class="line">                <span class="comment">// abandoning zk thread</span></span><br><span class="line">                zkServerThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop the server if running and invoke the callback when complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide an &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked if an Exception is thrown from the ZooKeeper server thread. If none</span></span><br><span class="line"><span class="comment">     * is provided, only error-level logging will occur.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorHandler the &#123;<span class="doctag">@link</span> ErrorHandler&#125; to be invoked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorHandler = errorHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnable implementation that starts the ZooKeeper server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                File file = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)</span><br><span class="line">                        + File.separator + UUID.randomUUID());</span><br><span class="line">                file.deleteOnExit();</span><br><span class="line">                properties.setProperty(<span class="string">"dataDir"</span>, file.getAbsolutePath());</span><br><span class="line">                properties.setProperty(<span class="string">"clientPort"</span>, String.valueOf(clientPort));</span><br><span class="line"></span><br><span class="line">                QuorumPeerConfig quorumPeerConfig = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">                quorumPeerConfig.parseProperties(properties);</span><br><span class="line"></span><br><span class="line">                zkServer = <span class="keyword">new</span> ZooKeeperServerMain();</span><br><span class="line">                ServerConfig configuration = <span class="keyword">new</span> ServerConfig();</span><br><span class="line">                configuration.readFrom(quorumPeerConfig);</span><br><span class="line"></span><br><span class="line">                zkServer.runFromConfig(configuration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    errorHandler.handleError(e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Exception running embedded ZooKeeper"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解synchronized</title>
      <link href="/2019/02/22/how-use-synchronized/"/>
      <url>/2019/02/22/how-use-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解synchronized"><a href="#深入理解synchronized" class="headerlink" title="深入理解synchronized"></a>深入理解synchronized</h1><h2 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h2><p>synchronized是java的关键字，用于修饰方法、代码块，能够保证同一时刻最多只有一个线程执行这段代码，通过上述描述可以清晰告诉我们synchronized的作用，也就是同步操作，同步是围绕称为<em>内部锁</em>或<em>监视器锁</em>的内部实体构建的。内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>在方法内部使用synchronized来进行代码块的同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        lastName = name;</span><br><span class="line">        nameCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    nameList.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>直接在方法上使用synchronized进行修饰即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程调用synchronized方法时，它会自动获取该方法对象的内部锁，并在方法返回时释放它。即使返回是由未捕获的异常引起的，也会发生锁定释放，可能想知道在调用静态同步方法时会发生什么，因为静态方法与类关联，而不是与对象关联。在这种情况下，线程获取<code>Class</code>与类关联的对象的内部锁。因此，对类的静态字段的访问由与该类的任何实例的锁不同的锁控制。</p><h2 id="内部锁或监视器锁"><a href="#内部锁或监视器锁" class="headerlink" title="内部锁或监视器锁"></a>内部锁或监视器锁</h2><p>同步是围绕称为<em>内部锁</em>或<em>监视器锁</em>的内部实体构建的。内部锁在同步的两个方面都发挥作用：强制对对象状态进行独占访问，并建立对可见性至关重要的先发生关系。每个对象都有一个与之关联的内在锁，按照惯例，需要对对象字段进行独占和一致访问的线程必须在访问对象之前<em>获取</em>对象的内部锁，然后在完成它们时<em>释放</em>内部锁。据说一个线程在获得锁定和释放锁定之间<em>拥有</em>内在锁定。只要一个<code>线程</code>拥有一个内部锁，没有<code>其他线程</code>可以获得相同的锁。另一个线程在尝试获取锁时将阻塞。当线程释放内部锁时，在该操作与同一锁的任何后续获取之间建立先发生关系。</p><ol><li><p>当使用synchronized修饰非静态方法是，内置锁就是对象本身（this）</p></li><li><p>当使用synchronized修饰静态方法是，内置锁就是该方法的所在的<strong>类对象</strong>的内置锁</p></li></ol><p>通过一张图来描述一下synchronized的运行过程：</p><p><img src="/2019/02/22/how-use-synchronized/lock.png" alt="Synchronized运行"></p><ol><li><p>当线程1获取到拥有一个内部锁，没有其他线程可以获得相同的锁。</p></li><li><p>线程2只能等到线程1释放内部锁，线程2处于Blocked阻塞状态，被阻塞的线程将等待。</p></li><li><p>当线程1方法执行完释放内部锁之后，线程2获取内部锁，执行相应的方法。</p></li></ol><h2 id="内部锁可重入"><a href="#内部锁可重入" class="headerlink" title="内部锁可重入"></a>内部锁可重入</h2><p><strong>重入性</strong>指的是同一线程中，线程不需要再次获取同一把锁，内部锁是基于<code>每个线程</code>而不是基于每个方法的调用获取的。一旦线程获得了锁，它就可以在内部调用其他方法而无需重新获取锁。只有在使用entry方法调用完成线程时才会释放Lock。</p><p>下面结合例子进行分析锁的重入性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantDemo demo = <span class="keyword">new</span> ReentrantDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1调用前 "</span>+ LocalDateTime.now());</span><br><span class="line">            demo.syncMethod1(<span class="string">"执行线程1的方法"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1调用后 "</span>+LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程2调用前 "</span>+LocalDateTime.now());</span><br><span class="line">            demo.syncMethod2(<span class="string">"执行线程2的方法"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程2调用后 "</span>+LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod1</span> <span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入同步方法1syncMethod1 "</span>+msg+<span class="string">" "</span>+LocalDateTime.now());</span><br><span class="line">        syncMethod2(<span class="string">"重入同步方法syncMethod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod2</span> <span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入到同步方法2syncMethod2 "</span>+msg+<span class="string">" "</span>+LocalDateTime.now());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程2调用前 2019-02-22T15:33:43.963</span><br><span class="line">进入同步方法1syncMethod1 执行线程1的方法 2019-02-22T15:33:43.964</span><br><span class="line">进入到同步方法2syncMethod2 重入同步方法syncMethod2 2019-02-22T15:33:43.964</span><br><span class="line">线程1调用后 2019-02-22T15:33:46.969</span><br><span class="line">进入到同步方法2syncMethod2 执行线程2的方法 2019-02-22T15:33:46.969</span><br><span class="line">线程2调用后 2019-02-22T15:33:49.973</span><br></pre></td></tr></table></figure><p>代码解析：</p><ol><li><code>syncMethod1</code>和<code>syncMethod2</code>都用synchronized进行修饰。</li><li><code>syncMethod1</code>调用了<code>syncMethod2</code>方法，这时候会产生重入的问题</li><li>线程1当调用<code>syncMethod1</code>时，获取当前对象的内部锁</li><li>线程1调用<code>syncMethod2</code>时，发现当前线程拥有当前对象的内部锁，直接重入<code>syncMethod2</code>中</li><li>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</li></ol><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>我们当使用synchronized修饰代码块或者方法时内部实现了什么操作？我们通过下面例子来进行揭露真面目</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.syncMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap -v Test.class查看字节码文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  public com.example.demo.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/demo/Test;</span><br><span class="line">  public synchronized void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String testing</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lcom/example/demo/Test;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #5                  // class com/example/demo/Test</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #6                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokevirtual #7                  // Method syncMethod:()V</span><br><span class="line">        12: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 8</span><br><span class="line">        line 12: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            8       5     1  test   Lcom/example/demo/Test;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>syncMethod</code>的synchronized修饰在方法上</li><li><code>syncMethod</code>的flag中存在ACC_SYNCHRONIZED进行修饰，标识是否为synchronized</li></ol><p>实例二：</p><p>通过synchronized方法修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> battleheart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            syncMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap -v Test.class查看字节码文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.example.demo.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/demo/Test;</span><br><span class="line"></span><br><span class="line">  public static void syncMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String testing</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: ldc           #5                  // class com/example/demo/Test</span><br><span class="line">         2: dup</span><br><span class="line">         3: astore_1</span><br><span class="line">         4: monitorenter</span><br><span class="line">         5: invokestatic  #6                  // Method syncMethod:()V</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: monitorexit</span><br><span class="line">        10: goto          18</span><br><span class="line">        13: astore_2</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit</span><br><span class="line">        16: aload_2</span><br><span class="line">        17: athrow</span><br><span class="line">        18: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             5    10    13   any</span><br><span class="line">            13    16    13   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 12: 5</span><br><span class="line">        line 13: 8</span><br><span class="line">        line 14: 18</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      19     0  args   [Ljava/lang/String;</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 13</span><br><span class="line">          locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Exception</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>执行同步代码块首先执行<strong>monitorenter</strong>指令，退出时候执行<strong>monitorexit</strong>指令</li><li>同步时必须要获取对象的监视器monitor，获取monitor后才能执行下面逻辑，否则只能等待。</li><li>经过<strong>monitorenter</strong>指令和<strong>monitorexit</strong>指令修饰的部分代码是互斥的，仅有一个线程持有内部锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot自动装配详解</title>
      <link href="/2019/01/24/spring-boot-autoconfiguration-fashion/"/>
      <url>/2019/01/24/spring-boot-autoconfiguration-fashion/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot自动装配"><a href="#Spring-Boot自动装配" class="headerlink" title="Spring Boot自动装配"></a>Spring Boot自动装配</h1><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><ol><li><p><code>@Import</code>注解<br>如果我们在项目中不同的模块提供多个spring bean配置，则@Import注释将非常有用。在这种情况下，最好将所有这些配置导入到单个配置类中，以便通过引用多个配置类来创建bean时不会产生任何混淆。Spring中的<code>@Import</code>注释允许从另一个配置类加载bean定义，将多个配置类导入单个应用程序配置非常容易，这里不过多篇幅讲解<code>@Import</code>。</p></li><li><p><code>@Enable</code>注解驱动，对配置进行自动配置。</p><ul><li>通过<code>ConfigurationClassParser</code>类对标记为<code>@Configuration</code>注解的类进行解析。</li><li>然后通过解析<code>@Import</code>注解进行自动导入配置，<code>@Import</code>支持以下三种方式解析。<ul><li>直接解析配置类<code>@Configuraion</code></li><li><code>ImportSelector</code>接口（<code>Spring 4.0</code>后增加了<code>DeferredImportSelector</code>继承自<code>ImportSelector</code>，两者的区别是<code>ImportSelector</code>在<code>DeferredImportSelector</code>先执行解析）</li><li><code>ImportBeanDefinitionRegistrar</code>动态注册Bean的方式</li></ul></li></ul></li><li><p><code>@Conditional</code>条件注解，以及常见的Spring Boot常见条件注解</p></li><li><p>源码分析</p></li></ol><h2 id="引用例子抛出问题"><a href="#引用例子抛出问题" class="headerlink" title="引用例子抛出问题"></a>引用例子抛出问题</h2><p><code>@SpringBootApplication</code>中包括<code>@EnableAutoConfiguration</code>注解，@Enable驱动，此时我们可能会想以下几个问题：</p><ol><li>@Enbale的主要作用是什么？</li><li>配置类是如何导入的？</li><li>配置类又是如何被解析的？</li><li>配置类导入方式是以什么方式进行导入的？</li></ol><p>接下来我们带着问题看以下内容</p><h2 id="Enable-模块驱动"><a href="#Enable-模块驱动" class="headerlink" title="@Enable 模块驱动"></a>@Enable 模块驱动</h2><p>通过观察这些<code>@Enable*</code>的源码，我们发现所有注解都有一个<code>@Import</code>注解，<code>@Import</code>是用来导入配置类的，这就意味着这些自动开启的实现其实是导入一些自动配置的Bean。</p><ol><li>直接导入配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(SchedulingConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>直接导入配置类<code>SchedulingConfiguration</code>，这个类注解了<code>@Configuration</code>注解，且注册了一个<code>scheduledAnnotationProcessor</code>的Bean，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line">    <span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p><code>ImportSelector</code>接口，实现该接口。</p><p>根据条件选择配置类，通过选择的方式进行选择配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AsyncConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>AsyncConfigurationSelector</code>通过条件来选择需要导入的配置类，<code>AsyncConfigurationSelector</code>实现了<code>ImportSelector</code>，这个接口需要重写<code>selectImports</code>方法，在此方法内进行事先条件判断。此例中，若<code>adviceMode</code>为PROXY，则返回<code>ProxyAsyncConfiguration</code>这个配置类；若为ASPECTJ则返回<code>AspectJAsyncConfiguration</code>配置类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableAsync</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">            <span class="string">"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;ProxyAsyncConfiguration.class.getName()&#125;;</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><code>ImportBeanDefinitionRegistrar</code>接口,动态注册Bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>AspectJAutoProxyRegistrar</code>实现了<code>ImportBeanDefinitionRegistrar</code>接口，<code>ImportBeanDefinitionRegistrar</code>接口的作用是在运行时自动添加Bean到已有的配置类，通过重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span></span><br></pre></td></tr></table></figure><p>其中，<code>AnnotationMetadata</code>参数用来获取当前配置类上的注解，<code>BeanDefinitionRegister</code>参数用来注册Bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：通过上述内容的描述可以清晰的看到@Enable注解回答了以下两个问题</p><ol><li>@Enable主要作用是导入配置</li><li>@Enable导入配置的方式<ul><li>直接导入配置类，通过<code>@Configuraion</code>注解加持的配置类</li><li>继承ImportSelector接口</li><li>继承ImportBeanDefinitionRegistrar接口</li></ul></li><li>配置类是通过上述三种方式进行导入<ul><li>直接导入配置类的方式很容易理解</li><li>ImportSelector接口方式程序又是如何进行解析的呢？请看下文内容。</li><li>ImportBeanDefinitionRegistrar接口又是如何进行解析？</li></ul></li></ol><h2 id="Spring-Boot条件注解讲解"><a href="#Spring-Boot条件注解讲解" class="headerlink" title="Spring Boot条件注解讲解"></a>Spring Boot条件注解讲解</h2><ol><li><p>常用相关条件注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span>              <span class="comment">// 配置了某个特定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>       <span class="comment">// 没有配置特定Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>             <span class="comment">// classpath有指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>      <span class="comment">// classpath没有指定类</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span>        <span class="comment">// 给定的Spring Expression Language（SpEL）表达式计算结果为true</span></span><br><span class="line"><span class="meta">@ConditionalOnJava</span>              <span class="comment">// Java的版本匹配特定值或某一个范围值</span></span><br><span class="line"><span class="meta">@ConditionalOnJndi</span>              <span class="comment">// 参数中给定的JNDI位置必须存在一个，如果没有给参数，则要有JNDI InitialContext</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>          <span class="comment">// 指定的配置属性要有一个明确的值</span></span><br><span class="line"><span class="meta">@ConditionalOnResource</span>          <span class="comment">// Classpath里有指定资源</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>    <span class="comment">// 这是个Web应用程序</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span> <span class="comment">// 这不是个Web应用程序</span></span><br></pre></td></tr></table></figure></li><li><p>条件注解<code>@Conditional</code>   </p><p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。通过一个源码我可以清晰的看到上面Spring Boot的源码都是采用条件注解。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(OnBeanCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] type() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>;</span><br><span class="line">    Class&lt;?&gt;[] parameterizedContainer() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@Conditional</code>中有一个<code>OnBeanCondition</code>的条件类，条件类最终继承关系如下图所示：<br><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/1.png" alt="OnBeanCondition继承关系" title="OnBeanCondition继承关系"><br>可以清晰的看到他最后继承自Condition接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中包含一个matches方法，有两个参数一个是ConditionContext包含了获取环境变量信息，Bean信息，类加载器的贵相关信息，AnnotatedTypeMetadata获取注解的信息。通过该方法返回true和false来表明是否加载当前Bean信息。</p><p>Spring Boot添加了很多注解，主要分类以下六大类内容：</p><ol><li><code>Class条件</code></li><li><code>Bean条件</code></li><li><code>Property条件</code></li><li><code>Resource条件</code></li><li><code>Web应用程序条件</code></li><li><code>SpEL表达式条件</code> </li></ol><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><ol><li><p>resource下添加META-INF文件，文件下添加spring.factories文件，如下图所示：  </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/2.png" alt="spring.factories" title="spring.factories">   </p><p>以Mybatis自动配置为主进行讲解，里面内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure></li></ol><p>我们可以看到里面是通过<code>EnableAutoConfiguration</code>这个注解来进行自动装配，也就是说添加了当前注解的类它会扫面spring.factorie文件下所有关于<code>EnableAutoConfiguration</code>指定类的全名称，然后进行自动化配置。</p><ol><li><code>EnableAutoConfiguration</code>注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">    <span class="comment">//排除Class类对象。</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//排除类名称。</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>EnableAutoConfiguration</code>中添加了<code>@Import</code>注解，注解中包含<code>AutoConfigurationImportSelector</code>类，这个类继承自<code>DeferredImportSelector</code>接口,而它又继承自<code>ImportSelector</code>接口，这就说明他是通过<code>ImportSelector</code>的方式来完成自动化配置。   </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/4.png" alt="AutoConfigurationImportSelector继承关系" title="AutoConfigurationImportSelector继承关系"></p><ol start="3"><li><p><code>ConfigurationClassParser</code>类解析@Configuration标记的类   </p><ul><li><p>主要作用：首先为什么要先说<code>ConfigurationClassParser</code>类，因为<code>Spring的</code>工具类<code>ConfigurationClassParser</code>用于分析<code>@Configuration</code>注解的配置类，产生一组<code>ConfigurationClass</code>对象。</p></li><li><p>分析过程：</p><ul><li><code>ConfigurationClassParser</code>类的调用是由<code>ConfigurationClassPostProcessor</code>，而<code>ConfigurationClassPostProcessor</code>是继承自<code>BeanDefinitionRegistryPostProcessor</code>接口，它又继承自<code>BeanFactoryPostProcessor</code>接口，它会在容器启动过程中，应用上下文执行各个<code>BeanFactoryPostProcessor</code>时被执行。</li><li><code>BeanFactoryPostProcessor</code>调用过程：Spring Boot 应用中在<code>ApplicationContext</code>对象创建时，会调用 <code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code> 注册这个<code>BeanFactoryPostProcessor</code>。执行时会调用<code>postProcessBeanDefinitionRegistry</code>方法，该方法中调用了该类中的<code>processConfigBeanDefinitions</code>方法来调用<code>ConfigurationClassPostProcessor</code>类的<code>parse</code>方法来进行解析<code>@Configuration</code>注解加载的类信息,以及调用<code>BeanFactoryPostProcessor</code>的<code>postProcessBeanFactory()</code>方法。   </li><li>分析过程会接受一组配置类(调用者已知其是配置类，通常就一个)，从它开始分析所有关联的配置类</li><li>分析过程主要是递归分析配置类的注解<code>@Import</code>，配置类内部嵌套类，找出其中所有的配置类，然后返回这组配置类</li></ul></li></ul><p><code>ConfigurationClassPostProcessor</code>继承关系：  </p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/3.jpg" alt="ConfigurationClassPostProcessor继承关系" title="ConfigurationClassPostProcessor继承关系">   </p><p><code>ConfigurationClassPostProcessor</code>类的<code>postProcessBeanDefinitionRegistry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">//处理Config配置Bean。</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>processConfigBeanDefinitions</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记为@Configuration候选类</span></span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//从容器中获取已经标记为Bean的候选配置类名称。</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            <span class="comment">//如果当前类标记为@Configuration注解添加到候选类集合中。</span></span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有@Configuration注解的类直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据@Order的value来进行排序。</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取生成策略包括@ComponentScan和@Import的范围。</span></span><br><span class="line">    SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">                <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析每一个标记@Configuration注解的类。</span></span><br><span class="line">    <span class="comment">//首先构造ConfigurationClassParser类。</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为不清楚候选是否确实是配置类，所以使用BeanDefinitionHolder类型记录</span></span><br><span class="line">    <span class="comment">// 这里初始化为方法开始时容器中注解了@Configuration的Bean定义的集合</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    <span class="comment">// 这里记录已经解析的类。</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//解析配置文件，如果是标记为@Component注解的直接解析成bean，如果标记为@Import注解的将解析三种类型的类文件进行循环解析，解析成ConfigurationClass类添加到ConfigurationClassParser属性configurationClasses中。</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        parser.validate();</span><br><span class="line">        <span class="comment">// 获取ConfigurationClassParser中的ConfigurationClass对象集合。</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 去除已经解析的Bean对象。</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取模型并根据其上下文创建bean定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 ConfigurationClassBeanDefinitionReader reader 从 configClasses 中加载Bean定义并加载到容器中。</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        <span class="comment">//处理完的添加到已处理类中。</span></span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空候选配置类集合，为下一轮do循环做初始化准备</span></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            <span class="comment">// 经过一轮do循环,现在容器中Bean定义数量超过了该次循环开始时的容器内Bean定义数量，</span></span><br><span class="line">            <span class="comment">// 说明在该次循环中发现并注册了更多的Bean定义到容器中去，这些新注册的Bean定义</span></span><br><span class="line">            <span class="comment">// 也有可能是候选配置类，它们也要被处理用来发现和注册Bean定义</span></span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty()); <span class="comment">//循环到没有配置类为止。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ConfigurationClassParser</code>的<code>parse</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据不同的类型来进行解析。</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">//bd是AnnotateBeanDefinition</span></span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                <span class="comment">//bd是AbstractBeanDefinition,并且指定 beanClass 属性</span></span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他情况</span></span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后处理DeferredImportSelector接口内容。</span></span><br><span class="line">    <span class="comment">// DeferredImportSelector继承自ImportSelector接口。</span></span><br><span class="line">    <span class="comment">// ImportSelector 被设计成其实和@Import注解的类同样的导入效果，但是实现 ImportSelector的类可以条件性地决定导入哪些配置。</span></span><br><span class="line">    <span class="comment">// DeferredImportSelector的设计目的是在所有其他的配置类被处理后才处理。这也正是该语句被放到本函数最后一行的原因。</span></span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看一下第一种情况，其实不管是三个中的任何情况，最后都会调用<code>processConfigurationClass</code>方法来进行处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processConfigurationClass</code>方法，主要是对解析的ConfigurationClass进行处理，如果已经处理过则合并importBy属性，反之，循环解析配置类并且向上沿着类的接口逐层执行doProcessConfigurationClass方法，直到java提供的类结束循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先获取当前ConfigurationClass，检测是否已经被解析了。</span></span><br><span class="line">    ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">//如果已经解析了，合并二者的importedBy属性</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line">            <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前配置类configClass开始向上沿着类继承结构逐层执行doProcessConfigurationClass,</span></span><br><span class="line">    <span class="comment">// 直到遇到的父类是由Java提供的类结束循环</span></span><br><span class="line">    <span class="comment">// 将类封装成SourceClass类</span></span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置configurationClasses属性添加当前configuClass对象，用于上一步中的获取当前属性来注册到上下文中。</span></span><br><span class="line">    <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>doProcessConfigurationClass</code>方法内部实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//如果是@Component注解优先处理内部类/内部成员。</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@PropertySource注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() + <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理@ComponentScan注解</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理@Import注解，这里才是真正的主题。</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理@ImportResource注解</span></span><br><span class="line">    AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">                configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Bean@Bean的方法。</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有父类处理父类。</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有父类则代表处理完成。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看一下<code>processImports</code>方法，看一下是如何处理<code>@Import</code>注解的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,Collection&lt;SourceClass&gt; importCandidates, <span class="keyword">boolean</span> checkForCircularImports)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要处理的SourceClass是否为空，如果为空直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测循环引用问题。</span></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.problemReporter.error(<span class="keyword">new</span> CircularImportProblem(configClass, <span class="keyword">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="comment">//1.检测是否继承自ImportSelector接口。</span></span><br><span class="line">                <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="comment">//创建ImportSelectord对象。</span></span><br><span class="line">                    ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(selector, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">                    <span class="comment">//这里判断selector是否是DeferredImportSelector实现。</span></span><br><span class="line">                    <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                        <span class="comment">//将调用ConfigurationClassParser内部类DeferredImportSelectorHandler的handle方法，将该类添加到DeferredImportSelectorHandler的属性</span></span><br><span class="line">                        <span class="comment">//deferredImportSelectors等到后面的最后ConfigurationClassParser类的parse方法的最后执行的方法this.deferredImportSelectorHandler.process()。</span></span><br><span class="line">                        <span class="keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//这里是直接继承ImportSelector接口,并且执行selector的selectImports方法,获取需要解析的类，</span></span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                        <span class="comment">// 这里会循环解决配置中内容。</span></span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是动态注册Bean。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                    <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    ImportBeanDefinitionRegistrar registrar =</span><br><span class="line">                            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            registrar, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//直接处理@Configuration注解的类。</span></span><br><span class="line">                    <span class="keyword">this</span>.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    <span class="comment">// 从新开始又来处理ConfigurationClass，详细可以看上面的介绍该方法的地方。</span></span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Failed to process import candidates for configuration class ["</span> +</span><br><span class="line">                    configClass.getMetadata().getClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个Spring Boot的运行调用过程如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--SpringApplication.run()</span><br><span class="line">----refreshContext(context);</span><br><span class="line">------SpringApplication.refresh(context);</span><br><span class="line">--------ServletWebServerApplicationContext.refresh();</span><br><span class="line">----------AbstractApplicationContext.refresh()</span><br><span class="line">------------invokeBeanFactoryPostProcessors(beanFactory); <span class="comment">//这里就会继承自BeanFactoryPostProcessor接口的方法。</span></span><br><span class="line">--------------PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());<span class="comment">//第二个参数传递的就是BeanFactoryPostProcessor的list集合。</span></span><br><span class="line">----------------invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<span class="comment">//处理BeanDefinitionRegistryPostProcessors,继承自BeanFactoryPostProcessor接口</span></span><br><span class="line">------------------postProcessor.postProcessBeanDefinitionRegistry(registry);<span class="comment">//这里会调用ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法来进行处理Bean内容。</span></span><br><span class="line">--------------------ConfigurationClassPostProcessor.processConfigBeanDefinitions(registry);<span class="comment">//解析待处理的Bean。</span></span><br><span class="line">----------------------ConfigurationClassParser.parse(candidates);<span class="comment">//这里就是正式的将待处理的holder解析成ConfigurationClass。</span></span><br></pre></td></tr></table></figure></p><p>到上面最后一步其实就是已经到了我们上面源码分析的内容位置。</p><p>整体流程图大致如下图所示：</p><p><img src="/2019/01/24/spring-boot-autoconfiguration-fashion/5.png" alt="处理流程"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><code>JavaEE开发的颠覆者: Spring Boot实战</code>书籍,其中@Enable*驱动的三种方式摘抄本书</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring-boot与thymeleaf模板整合shiro标签内容</title>
      <link href="/2019/01/24/spring-boot-thymeleaf-and-shiro/"/>
      <url>/2019/01/24/spring-boot-thymeleaf-and-shiro/</url>
      
        <content type="html"><![CDATA[<h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="添加Bean对象"><a href="#添加Bean对象" class="headerlink" title="添加Bean对象"></a>添加Bean对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * shiro 标签的Bean。</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ShiroDialect shiroDialect() &#123;</span><br><span class="line">    return new ShiroDialect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面添加对标签的引用，添加方式如下："><a href="#页面添加对标签的引用，添加方式如下：" class="headerlink" title="页面添加对标签的引用，添加方式如下："></a>页面添加对标签的引用，添加方式如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;zh_CN&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="上述配置成功后即可使用shiro相关的标签"><a href="#上述配置成功后即可使用shiro相关的标签" class="headerlink" title="上述配置成功后即可使用shiro相关的标签"></a>上述配置成功后即可使用shiro相关的标签</h2><ol><li><p>直接对代码块进行控制 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;P0101&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">      &lt;a data-href=&quot;/ticket/spot/view/list&quot; data-title=&quot;景点&quot; href=&quot;javascript:void(0)&quot;&gt;景点&lt;/a&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过html属性方式进行控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a data-href=&quot;/ticket/spot/view/list&quot; data-title=&quot;景点&quot; href=&quot;javascript:void(0)&quot; shiro:hasPermission name=&quot;P0101&quot;&gt;景点&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Hexo搭建博客</title>
      <link href="/2018/10/26/use-hexo-to-build-a-blog/"/>
      <url>/2018/10/26/use-hexo-to-build-a-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>需要安装的内容如下：</p><ol><li>git 仓库（<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>）下载并安装</li><li>node.js（<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node官网</a>）下载并安装</li><li>hexo安装</li></ol><p>输入以下命令安装hexo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p><p>安装成功后，新建一个喜欢的文件夹，进入文件夹中执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install（用于安装依赖包）</span><br></pre></td></tr></table></figure></p><p>执行完成后，输入以下命令，然后通过访问:<a href="http://localhost:4000，来访问，一个本地博客就搭建完了。" target="_blank" rel="noopener">http://localhost:4000，来访问，一个本地博客就搭建完了。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><h2 id="常用命令如下"><a href="#常用命令如下" class="headerlink" title="常用命令如下"></a>常用命令如下</h2><blockquote><p>hexo g #完整命令为hexo generate,生成静态文件<br>hexo s #完整命令为hexo server,启动服务器,本地可以测试<br>hexo d #完整命令为hexo deploy,将本地编译好的静态文件发布到github上<br>hexo n #完整命令为hexo new,新建一篇文章<br>hexo clean #清除当前项目的静态文件  </p></blockquote><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><p>博主可根据自己的需求去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>中找寻自己喜欢的主题，并且将主题的仓库内容复制到themes目录下。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx.git  themes/xxx</span><br></pre></td></tr></table></figure></p><p>我们到themes目录下查看后可清楚看到我们download下的xxx文件夹内的主题信息，修改根目录的_config.yml（注意不是主题下的config.yml，而是hexo根目录下的配置文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></p><h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><ol><li>github仓库中新建一个git仓库，仓库的名字叫做<code>github账户名.github.io</code>(必须这样起名字)，例如我的账户名为dwlsxj，则仓库的名称是<code>dwlsxj.github.io</code></li><li>接下来配置SSH，自己的邮箱地址， 在git bash 中执行命令，连续回车三次不需要输入任何内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxx@126.com&quot;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/26/use-hexo-to-build-a-blog/1.jpg" alt="图片1" title="图片1"></p><p>从图中我们可以清晰的看到生成到了C盘Users/BattleHeart/.ssh/下，打开id_rsa.pub文件，copy文件中的内容。</p><ol start="3"><li>将复制的key设置到github中，用户-&gt;setting-SSH and GPG keys   </li></ol><p><img src="/2018/10/26/use-hexo-to-build-a-blog/2.png" alt="图片2" title="图片2"></p><ol start="4"><li>打开hexo目录下的_config.yml,找到deploy，添加git地址，保存后使用deploy d进行上传私服。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  #repository: https://github.com:xxxx/xxxx.github.io.git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:xxx/xxxx.github.io.git,master</span><br></pre></td></tr></table></figure><h1 id="个人域名绑定"><a href="#个人域名绑定" class="headerlink" title="个人域名绑定"></a>个人域名绑定</h1><ol><li>在source文件下新建一个CNAME文件（）没有后缀</li><li>将个人域名<code>www.battleheart.cn</code>添加到CNAME文件中</li><li>修改域名解析，添加两天CNAME的解析，解析到<code>dwlsxj.github.io</code>,也就是自己的仓库下。  </li></ol><p><img src="/2018/10/26/use-hexo-to-build-a-blog/3.png" alt="图片3" title="图片3"></p><ol start="4"><li>将CNAME文件deploy到github仓库中即可访问。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot Admin监控系统搭建</title>
      <link href="/2018/10/01/spring-boot-admin-monitor/"/>
      <url>/2018/10/01/spring-boot-admin-monitor/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-Admin监控系统搭建"><a href="#Spring-Boot-Admin监控系统搭建" class="headerlink" title="Spring Boot Admin监控系统搭建"></a>Spring Boot Admin监控系统搭建</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring Boot Admin是对Spring Boot的管理和监控的一个开源框架，支持Eureka服务注册列表状态监控，JMX监控，日志监控，JVM信息，垃圾信息，内存情况的监控，还可以设置日志的level级别。Spring Boot Admin UI 采用AngularJs将数据展示在前端。Spring Boot Admin分为服务端和客户端。</p><h2 id="Spring-Boot-Admin-Server端搭建"><a href="#Spring-Boot-Admin-Server端搭建" class="headerlink" title="Spring Boot Admin Server端搭建"></a>Spring Boot Admin Server端搭建</h2><ol><li><p>添加依赖项，依赖项内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot主类上添加对Spring Boot Admin Server启动的注解@EnableAdminServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableDiscoveryClient # 开启服务注册。</span><br><span class="line">@EnableTurbineStream # 开启Turbine服务监控。</span><br><span class="line">@EnableAdminServer # 开启Spring Boot Admin Server功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudMonitorApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudMonitorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">            http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 设置登出页面地址。</span> http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line">            <span class="comment">// 设置目前不支持csrf。</span> http.csrf().disable();</span><br><span class="line">            <span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>).permitAll();</span><br><span class="line">            <span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">            http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line">            <span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">            http.httpBasic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们看到上面其实还添加对Eureka的注解以及对Turbine Stream的注解功能，需要添加Turbine Stream注解相关与Spring boot Admin Server ui相关依赖项，为了安全起见导入了安全相关依赖项。依赖项内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—spring boot admin server ui支持登录页面依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-login&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成Hystrix监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">&lt;!--Spring Boot 后台管理系统集成turbine--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-admin-server-ui-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--对Turbine Stream支持，使用RabbitMQ的方式对Hystrix数据进行收集分析。--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-codec-http&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Eureka支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!—安全支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>其实Spring Boot Admin Server依赖中包含对Zuul和Hystrix以及Eureka核心包的依赖整合，所以我们看到上面只是整合了UI相关的依赖项。而针对Eureka和Turbine Stream以及安全方面的依赖需要额外导入进去，依赖项也导入进去后需要对端点进行权限安全控制，我们可以看到上面内部类中对安全进行控制，通过继承WebSecurityConfigurerAdapter对安全进行配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有登录表单的页面作为/login.html提供，并在/ login上执行POST。</span></span><br><span class="line">http.formLogin().loginPage(<span class="string">"/login.html"</span>).loginProcessingUrl(<span class="string">"/login"</span>).permitAll();</span><br><span class="line"><span class="comment">// 设置登出页面地址。</span></span><br><span class="line">http.logout().logoutUrl(<span class="string">"/logout"</span>);</span><br><span class="line"><span class="comment">// 设置目前不支持csrf。</span></span><br><span class="line">http.csrf().disable();</span><br><span class="line"><span class="comment">// 允许静态页面，静态数据的访问。</span></span><br><span class="line">http.authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/login.html"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/img/**"</span>, <span class="string">"/third-party/**"</span>)</span><br><span class="line">    .permitAll();</span><br><span class="line"><span class="comment">// 除了授权的页面所有内容都要进行授权访问。</span></span><br><span class="line">http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).authenticated();</span><br><span class="line"><span class="comment">// 启用安全认证，以便客户端可以通过HTTP basic进行身份验证以进行注册。</span></span><br><span class="line">http.httpBasic();</span><br></pre></td></tr></table></figure></p><p>也就是说对那些内容页面进行授权访问，那些页面是可以直接访问，对安全的开启等等一系列操作。</p><ol start="3"><li>修改配置文件信息，配置文件信息如下所示：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">    level:</span><br><span class="line">        org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter: error</span><br><span class="line">server: </span><br><span class="line">    port: <span class="number">8040</span></span><br><span class="line">turbine:</span><br><span class="line">    stream:</span><br><span class="line">        port: 8041    # 收集地址。</span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">boot:</span><br><span class="line">    admin:</span><br><span class="line">        routes:</span><br><span class="line">            endpoints: env,metrics,trace,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream</span><br><span class="line">        turbine:</span><br><span class="line">            clusters: <span class="keyword">default</span></span><br><span class="line">            location: http:<span class="comment">//localhost:$&#123;turbine.stream.port&#125;</span></span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;MONITOR_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：</p><ul><li>turbine.stream.port: 对Turbine支持，turbine服务端口号。</li><li>boot.admin.routes.endpoints: Spring Boot Admin暴露的EndPoint端点</li><li>spring.boot.admin.routes.turbine.clusters: 集群的名称</li><li>spring.boot.admin.routes.turbine.location: 集成Turbine服务数据收集的地址。  </li></ul><p>这里的地址就是为了收集是需要访问地址，我们之前在Turbine章节中说过这里不在多阐述。<br>Eureka中的metadataMap是专门用来存放一些自定义的数据，当注册中心或者其他服务需要此服务的某些配置时可以在metadataMap里取。实际上，每个instance都有各自的metadataMap，map中存放着需要用到的属性。例如，上面配置中的eureka.instance.metadata-map.user.name，当这个服务成功注册到Eureka上，SpringBootAdmin就会取拿到这个instance，进而拿到metadataMap里的属性，然后放入请求头，向此服务发送请求，访问此服务的actuator开放的端点。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>需要添加对安全保护的依赖项，以及对Turbine Stream注解。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>以上对Turbine Stream的支持请参考Spring Cloud Turbine相关文章内容。  </p><ol start="2"><li>修改配置文件信息，添加对Turbine Stream 消息队列的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span> </span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        hostname: localhost</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        metadata-map:</span><br><span class="line">            user.name: $&#123;security.user.name&#125;</span><br><span class="line">            user.password: $&#123;security.user.password&#125;</span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/</span></span><br><span class="line">        healthcheck:</span><br><span class="line">            enabled: <span class="keyword">true</span></span><br><span class="line"># Hystrix超时时间。</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                        timeoutInMilliseconds: <span class="number">5000</span></span><br><span class="line">spring:</span><br><span class="line">    abbitmq:</span><br><span class="line">        port: <span class="number">5672</span></span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        host: localhost</span><br><span class="line"></span><br><span class="line"># Spring Boot Admin配置相关 # SpringBoot 1.5以后的版本都默认开启端点保护</span><br><span class="line">management:</span><br><span class="line">    security:</span><br><span class="line">        enabled: <span class="keyword">false</span></span><br></pre></td></tr></table></figure></li></ol><p>最主要的是management.security.enabled：关闭管理安全。<br>下面是Spring Boot Admin相关监控信息。</p><p><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片1" title="图片1"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片2" title="图片2"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片3" title="图片3"><br><img src="/2018/10/01/spring-boot-admin-monitor/pic1.png" alt="图片4" title="图片4">  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Logback输出日志到ELK</title>
      <link href="/2018/10/01/logback-with-elk/"/>
      <url>/2018/10/01/logback-with-elk/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Logback输出日志到ELK"><a href="#使用Logback输出日志到ELK" class="headerlink" title="使用Logback输出日志到ELK"></a>使用Logback输出日志到ELK</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>前两篇文章中我们介绍了windows上如何搭建ELK日志收集系统，那么问题来了，日志系统搭建完成后如何使用java代码直接输出日志到ELK系统中？</p><h2 id="logback支持ELK"><a href="#logback支持ELK" class="headerlink" title="logback支持ELK"></a>logback支持ELK</h2><p>我们带着背景中的问题进行下面的开始思路整理，其实在ELK文章中我们已经说了两种方案，其实ELK中logstash支持的日志收集的方式有很多种，下面说一下logstash收集其中方法：  </p><ol><li>使用logstash对文件进行检测  </li><li>使用TCP协议，logstash开放对TCP协议端口的监听。  </li><li>使用UDP协议，logstash开放对UDP协议端口的监听。  </li></ol><p>我们本章节中使用的是TCP协议的方式进行日志输出，下面看一下logback的配置文件。  </p><ol><li><p>引入依赖项logstash-logback-encoder</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- logback和logstash结合 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改logback的配置文件信息。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=<span class="string">"LOGSTASH"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span><br><span class="line">    &lt;destination&gt;192.168.1.107:9250&lt;/destination&gt;</span><br><span class="line">    &lt;!-- encoder必须配置,有多种可选 --&gt;</span><br><span class="line">    &lt;encoder charset=<span class="string">"UTF-8"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span>/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">&lt;root level=<span class="string">"ERROR"</span>&gt;</span><br><span class="line">    &lt;appender-ref ref=<span class="string">"LOGSTASH"</span>/&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>appender</code>的name属性使用的是net.logstash.logback.appender.LogstashTcpSocketAppender<br><code>destination</code>属性：tcp的IP地址和端口号<br><code>encoder</code>：编码格式  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows环境下搭建ELK环境</title>
      <link href="/2018/10/01/elk-environment-construction-in-windows/"/>
      <url>/2018/10/01/elk-environment-construction-in-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows环境下搭建ELK环境"><a href="#Windows环境下搭建ELK环境" class="headerlink" title="Windows环境下搭建ELK环境"></a>Windows环境下搭建ELK环境</h1><h2 id="搭建Elastic-Stack环境"><a href="#搭建Elastic-Stack环境" class="headerlink" title="搭建Elastic Stack环境"></a>搭建Elastic Stack环境</h2><ol><li>通过官网下载相关包，网址：<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic1.png" alt="Elastic Stack" title="Elastic Stack">  </p><ol start="2"><li><p>运行<code>bin/elasticsearch</code> (or <code>bin\elasticsearch.bat on Windows</code>)  </p></li><li><p>在浏览器上访问<a href="http://localhost:9200，出现如下截图内容代表ES部署成功。" target="_blank" rel="noopener">http://localhost:9200，出现如下截图内容代表ES部署成功。</a>  </p></li></ol><p><img src="/2018/10/01/elk-environment-construction-in-windows/pic2.png" alt="运行情况" title="运行情况">  </p><h2 id="搭建Logstash环境"><a href="#搭建Logstash环境" class="headerlink" title="搭建Logstash环境"></a>搭建Logstash环境</h2><ol><li>下载logstash文件，网址：<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic3.png" alt="logstash" title="logstash"><br>下载Zip将Zip解压到本地。  </li><li>新建Logstash.conf文件，将logstash.conf文件复制到bin文件夹下。  </li></ol><ul><li><p>通过检测文件的方式输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     file &#123;</span><br><span class="line">        path =&gt; [&quot;D:/Log/*.log&quot;]   检测文件，通过检测文件变化输出到ES中。</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]  ES地址</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过TCP方式进行监听日志信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     tcp &#123;</span><br><span class="line"></span><br><span class="line">port =&gt; 9250   TCP端口号</span><br><span class="line">codec =&gt; json_lines</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">      date &#123;</span><br><span class="line">         match =&gt; [ &quot;timestamp&quot; , &quot;YYYY-MM-dd HH:mm:ss&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">          codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>运行<code>bin/logstash -f logstash.conf –t</code>  -t代表检测文件语法格式是否有误。<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic4.png" alt="运行结果" title="运行结果"><br>通过访问9600可以得到如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"host"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"6.4.1"</span>,  </span><br><span class="line">    <span class="string">"http_address"</span>: <span class="string">"127.0.0.1:9600"</span>,  </span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"bbb75ede-2654-4312-a80b-77d2c431ee73"</span>,  </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"DESKTOP-AVNGAHE"</span>,  </span><br><span class="line">    <span class="string">"build_date"</span>: <span class="string">"2018-09-13T23:17:51Z"</span>,  </span><br><span class="line">    <span class="string">"build_sha"</span>: <span class="string">"cee0d74663380e80c2a38cf5a9ccffb9a0cfa215"</span>,  </span><br><span class="line">    <span class="string">"build_snapshot"</span>: <span class="keyword">false</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="搭建Kibana环境"><a href="#搭建Kibana环境" class="headerlink" title="搭建Kibana环境"></a>搭建Kibana环境</h2><ol><li>下载Kibana，选择Windows版本。地址：<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a><br><img src="/2018/10/01/elk-environment-construction-in-windows/pic5.png" alt="下载地址" title="下载地址">  </li><li>打开config/kibana.yml文件，设置elasticsearch.url  为<a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a>  </li><li>运行bin/kibana或者bin/kiana.bat（在windows下运行）。  </li><li>访问地址localhost://5601<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic6.png" alt="访问的地址" title="访问的地址">  </li><li>配置日志打开Discover菜单，创建索引<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic7.png" alt="创建索引" title="创建索引">  </li><li>创建筛选器–根据时间筛选<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic8.png" alt="创建筛选器–根据时间筛选" title="创建筛选器–根据时间筛选">  </li><li>再次返回到 Discover<br><img src="/2018/10/01/elk-environment-construction-in-windows/pic9.png" alt="Discover" title="下载地Discover址">  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式服务跟踪之Spring Cloud Sleuth快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-sleuth/"/>
      <url>/2018/10/01/quick-start-spring-cloud-sleuth/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着业务的发展，系统规模也会变得越来越大，微服务之前的关系也会变得越来越复杂，客户端发起请求后通过一些列的微服务返回的结果，则会形成一个复杂的链路，在每个链路中如果有一个以来服务出现延迟或错误都会引发请求最后的失败，这时候对于整个链路的跟踪极为重要，通过实现队请求调用的跟踪可以帮助我们快速发现错误根源以及监控分析每条请求链路上的性能瓶颈等。<br>接下来我们要使用Spring Cloud Sleuth与Zipkin进行整合。</p><h1 id="Spring-Cloud-Sleuth使用。"><a href="#Spring-Cloud-Sleuth使用。" class="headerlink" title="Spring Cloud Sleuth使用。"></a>Spring Cloud Sleuth使用。</h1><ol><li>需要准备两个服务，service1与service2，service1调用service2的方法。</li><li>添加依赖项spring-cloud-starter-sleuth。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-sleuth它会自动为当前应用构建起各通信通道跟踪机制。比如：</p><ul><li>通过诸如RabbitMQ、Kafaka（或者其他任何Spring Cloud Stream绑定器实现的消息中间件）传递的请求。</li><li>通过Zuul代理传递的请求。</li><li>通过RestTemplate发起的请求。</li></ul><p>通过上面的配置即可对链路数据的监控，当我们访问service1和service2接口时会在控制台中输出相应的信息，例如：  </p><blockquote><p>INFO [servce1,f410a57afd5c145,a9f2118fa201984,false]25028—call servce1<br>INFO [servce1,f410a57afd5c145,e9a377dc2268bc29,false]25028—call servce2</p></blockquote><p><code>中括号</code>中的元素是实现分布式服务跟踪的重要组成部分，主要是：<br>第一个值：service1代表的是应用的名称，也就是spring.application.name参数属性值。<br>第二个值：Spring Cloud Sleuth生成的一个ID，称之为Trace ID，它用来标识是一条链路。一个请求链路中包含一个Trace ID，多个Span ID。<br>第三个值：也是Spring Cloud Sleuth生成的一个ID，代表的是Span ID,他表示一个基本的工作单位，比如发送一个Http请求。<br>也就是说同一个TranceID代表是一条链路，而不同的SpanID代表不同的Http请求和业务访问操作。  </p><h1 id="整合Zipkin"><a href="#整合Zipkin" class="headerlink" title="整合Zipkin"></a>整合Zipkin</h1><ol><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;    </span><br><span class="line">    &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>其中包括：spring-cloud-sleuth-zipkin-stream、spring-cloud-stream-binder-rabbit表示使用RabbitMQ的方式对链路进行传递请求。<br>zipkin-autoconfigure-ui依赖是通过页面的展示链路的情况。<br>客户端中需要添加对RabbitMQ注解的支持，主要是spring-cloud-stream-binder-rabbit或者spring-cloud-starter-stream-rabbit，我可以清晰的发现前后两者内容其实是一样后者内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;parent&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-stream-binder-rabbit-parent&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">   &lt;/parent&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">   &lt;description&gt;Spring Cloud Starter Stream Rabbit&lt;/description&gt;</span><br><span class="line">   &lt;url&gt;http:<span class="comment">//projects.spring.io/spring-cloud&lt;/url&gt;</span></span><br><span class="line">   &lt;organization&gt;</span><br><span class="line">      &lt;name&gt;Pivotal Software, Inc.&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http:<span class="comment">//www.spring.io&lt;/url&gt;</span></span><br><span class="line">   &lt;/organization&gt;</span><br><span class="line">   &lt;properties&gt;</span><br><span class="line">      &lt;main.basedir&gt;$&#123;basedir&#125;/../..&lt;/main.basedir&gt;</span><br><span class="line">   &lt;/properties&gt;    &lt;dependencies&gt;       &lt;dependency&gt;          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在Spring Boot主类上添加@EnableZipkinStreamServer注解开启Zipkin功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZipkinStreamServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudSluethZipkinApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(SpringCloudSluethZipkinApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudsluethzipkin</span><br><span class="line">rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">9411</span></span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: admin</span><br><span class="line">    password: $&#123;ZIPKIN_SERVER_PASSWORD:admin&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过RabbitMQ对消息进行传递，将链路信息传递给RabbitMQ，Zipkin对消息队列消息进行收集分析得出实际的访问链路。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控Spring Cloud Turbine消息队列篇</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>上一篇文章中我们介绍了Turbine简单的通过服务名称的方式构建监控聚合服务，这一章中我们将要讲一下使用消息队列的方式对集群信息进行收集，监控，我们可以将所有需要收集的监控信息都输出到消息代理中，然后turbine订阅消息代理中的消息，通过异步的方式读取消息，最后将读取出来的监控指标输出到Hystrix Dashboard中。</p><h1 id="Turbine与消息代理结合"><a href="#Turbine与消息代理结合" class="headerlink" title="Turbine与消息代理结合"></a>Turbine与消息代理结合</h1><ol><li>首先需要一个重要的东西就是消息代理，这里我们使用的是RabbitMQ来进行消息的传递与收集。（环境搭建省略）</li><li>添加依赖项<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者是<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-stream-rabbit &lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为我们可以看到spring-cloud-starter-turbine-amqp实际上是包装了spring-cloud-starter-turbine-stream和spring-cloud-starter-turbine-stream依赖。  </p><ol start="3"><li><p>在Spring Boot主类上添加@EnableTurbineStream注解来启用Turbine Stream的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTurbineStream</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">TurbineApplication</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SpringApplication.run(TurbineApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件信息中添加RabbitMq的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">   application: </span><br><span class="line">       name: springCloudMonitor</span><br><span class="line">server: </span><br><span class="line">  port: <span class="number">8040</span> </span><br><span class="line">eureka: # 注册为eureka服务。</span><br><span class="line">  instance:</span><br><span class="line">    hostname: registry</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">        user.name: $&#123;security.user.name&#125;</span><br><span class="line">        user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@localhost:8761/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        host: localhost</span><br><span class="line">        username: guest</span><br><span class="line">        password: guest</span><br><span class="line">        port: <span class="number">5672</span></span><br></pre></td></tr></table></figure></li></ol><p>对于Turbine的配置已经完成，还需要对服务消费者做一些修改，修改如下：  </p><ol><li>添加对RabbitMQ支持依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>或者添加如下依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>因为第一个依赖项是对下面两个依赖项的整合，所以下面的和上面的效果是以昂的。</p><ol start="2"><li>添加对RabbitMQ配置信息的支持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    host: localhost</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以通过消息队列的方式进行系统监控。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群监控之Spring Cloud Turbine快速入门</title>
      <link href="/2018/10/01/quick-start-spring-cloud-turbine/"/>
      <url>/2018/10/01/quick-start-spring-cloud-turbine/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Spring Cloud Turbine是对集群中微服务信息的统一监控收集监控信息，我们在每个微服务中添加了对Hystrix熔断器功能的支持，可以通过/hystrix.stream对每个微服务的运行状况进行监控，如果在集群中去对每一个微服务去进行单个访问是行不通的，这时候turbine就发挥了它的优势，他可以将多个微服务的hystrix.stream聚合到一起使用turbine.stream进行聚合监控。  </p><h1 id="Spring-Cloud-Turbine快速入门"><a href="#Spring-Cloud-Turbine快速入门" class="headerlink" title="Spring Cloud Turbine快速入门"></a>Spring Cloud Turbine快速入门</h1><ol><li><p>添加依赖项，spring-cloud-starter-turbine，使用HystrixDashboard对Hystrix熔断进行图形化监控。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Spring Boot的主类上添加@EnableTurbine注解开启Turbine功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTurbine</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudHystrixTurbineApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudHystrixTurbineApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，修改如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8031</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springhystrixturbine</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http:<span class="comment">//admin:password@localhost:8761/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: <span class="keyword">default</span></span><br><span class="line">  #turbine.app-config指定了要收集监控信息的服务名</span><br><span class="line">  appConfig: spring-cloud-user,spring-cloud-service</span><br><span class="line">    #turbine.cluster-name-expression 指定集群名称</span><br><span class="line">  clusterNameExpression: <span class="string">"'default'"</span></span><br><span class="line">  combine-host-port: true #使同一主机上的多个服务实例可以通过主机名和端口号的组合来进行区分</span><br></pre></td></tr></table></figure></li></ol><p>配置信息参数描述：  </p><ul><li>turbine.appConfig：制定要收集监控信息的服务名，意思就是代表这些服务的hystrix.stream由turbine来进行收集监控。</li><li>turbine.cluster-name-expression：指定集群的名称。</li><li>combine-host-port：默认是true，代表同一台主机上多个服务实例可通过主机名和端口号组合来进行区分，因为同一个服务器可能部署多台微服务实例。</li></ul><ol start="4"><li>集群监控，可以通过访问<a href="http://localhost:8031/hystrix" target="_blank" rel="noopener">http://localhost:8031/hystrix</a> 对单个服务进行监控<br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic1.png" alt="turbine页面" title="turbine主页面"><br>可以清晰的看到下面的需要进行turbine监控的url的写法<a href="http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：" target="_blank" rel="noopener">http://localhost:8031/turbine.stream?cluster=default，其中cluster是我们在指定集群的名称。可以看到如下页面进行集群监控：</a><br><img src="/2018/10/01/quick-start-spring-cloud-turbine/pic2.png" alt="turbine页面" title="turbine主页面"><br>这说明我们集群监控配置成功。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API网关服务-Spring Cloud Zuul快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-zuul/"/>
      <url>/2018/09/27/quick-start-spring-cloud-zuul/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#简介">简介</a></li><li><a href="#Spring-Cloud-Zuul使用">Spring Cloud Zuul使用</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Api网关是一个更为只能的应用服务器，他的定义类似面向对象设计模式中的Façade模式，它的存在就像是整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过它来进行调度和过滤。他除了要实现请求路由、负载均衡、校验过滤等功能外，还需要更多的能力，比如与服务治理框架的结合，请求转发是的熔断机制，服务的聚合等一些列高级功能。</p><h2 id="Spring-Cloud-Zuul使用"><a href="#Spring-Cloud-Zuul使用" class="headerlink" title="Spring Cloud Zuul使用"></a>Spring Cloud Zuul使用</h2><ol><li>添加依赖项<code>spring-cloud-starter-zuul</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>spring-cloud-starter-zuul包下不仅仅包含zuul-core包，还包含了spring-cloud-starter-hystrix、spring-cloud-starter-ribbon、spring-boot-starter-autuator，提供了负载均衡以及熔断器的支持。  </p><ol start="2"><li>Spring Boot主类添加@EnableZuulProxy注解开启Zuul的API网关功能。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 网关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们可以看到@EnableZuulProxy注解其实是一个组合注解，它包含了开启Hystrix熔断技术的功能以及对Eureka注册中心的功能的开启。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker    # 开启Hystrix熔断器功能。</span><br><span class="line">@EnableDiscoveryClient   # 开启Eureka客户端功能。</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(&#123;ZuulProxyMarkerConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>修改配置文件信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloudzuul</span><br><span class="line">server:</span><br><span class="line">  port: 8050</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://admin:password@localhost:8761/eureka</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">zuul:</span><br><span class="line">  ignoredServices: springcloudservice    # 取消对服务路由机制列表</span><br><span class="line">  routes:</span><br><span class="line">    springclouduser: /user/**     # 指定服务路径。</span><br><span class="line"># Hystrix超时等到时间。</span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 20000</span><br><span class="line"># ribbon超时等待时间。</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: 10000</span><br><span class="line">  ConnectTimeout: 10000</span><br></pre></td></tr></table></figure></li></ol><p>理由规则配置讲解：</p><ul><li><code>zuul.ignoredServices</code>：取消路由机制的服务名称列表。</li><li><code>zuul.routes.name</code>: 我们可以看到name被标记为红色字体，代表的是注册到erueka服务中的服务名称，例如上面是springclouduser服务的路由规则是通过/user进行访问该服务的所有接口信息。</li><li><code>zuul.routes.xxx.path=/xxx/**</code><br><code>zuul.routes.xxx.url=http://localhost:8080/</code><br>该配置的表示所有符合/xxx/**规则的访问都将转发到<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 地址上，例如：访问服务中的<a href="http://localhost:8081/xxx/getUserList" target="_blank" rel="noopener">http://localhost:8081/xxx/getUserList</a> 接口时，API网关服务会将该请求路由到<a href="http://localhost:8080/getUserList" target="_blank" rel="noopener">http://localhost:8080/getUserList</a> 提供的服务接口上。其中红色部分为路由的名称，可以任意定义，但是一组path和url映射关系的路由名称要相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置管理中心Spring Cloud Config快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-config/"/>
      <url>/2018/09/27/quick-start-spring-cloud-config/</url>
      
        <content type="html"><![CDATA[<h1 id="配置管理中心-Spring-Cloud-Config"><a href="#配置管理中心-Spring-Cloud-Config" class="headerlink" title="配置管理中心-Spring Cloud Config"></a>配置管理中心-Spring Cloud Config</h1><h2 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h2><p>Spring Cloud Config是用为分布式系统中的基础设施和服务应用提供集中化的外部配置支持，它分为服务端和客户端两个部分。服务端是一个独立的服务，用来连接配置仓库并为客户端提供获取配置信息、加密、解密信息等访问接口，客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关配置内容，并在启动时候从配置中心获取和加载配置信息。Spring Cloud Config默认是git仓库进行存储配置信息，同时也支持其他方式进行存储，例如数据库，文件系统等。  </p><h2 id="Spring-Cloud-Config使用"><a href="#Spring-Cloud-Config使用" class="headerlink" title="Spring Cloud Config使用"></a>Spring Cloud Config使用</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol><li><p>添加依赖项<code>spring-cloud-stater-config-server</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置相关信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableConfigServer    # 开启Spring Cloud Config功能。</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件信息，添加配置服务的基本信息以及git仓库相关信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/dwlsxj/spring-cloud-test.git  # 配置仓库地址。</span></span><br><span class="line">          search-paths: git-repo # 仓库文件夹地址。</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: $&#123;security.user.name&#125;</span><br><span class="line">      user.password: $&#123;security.user.password&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">    defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password@localhost:8761/eureka/# Eureka地址。</span></span><br><span class="line"># 安全验证。</span><br><span class="line">security:</span><br><span class="line">  user:</span><br><span class="line">    name: user</span><br><span class="line">    password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中配置信息分别如下所示：<br><code>spring.cloud.config.server.git.uri</code>：git仓库的地址。<br><code>spring.cloud.config.server.search-paths</code>：对应仓库下相对所搜的位置，可以配置多个，其实就是存储配置信息的具体位置，例如如果仓库中存放了其他的内容并不是单纯存储配置信息，可通过该参数对配置信息进行搜索，定位。<br><code>spring.cloud.config.server.git.username</code>：访问git仓库的用户名。<br><code>spring.cloud.config.server.git.password</code>：访问git仓库的密码。</p><ol start="4"><li>配置规则详解,我们可以通过浏览器、postman、curl等工具直接访问配置相关信息，访问配置信息的URL与配置文件的映射关系如下所示：</li></ol><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties  </li></ul><p>访问地址：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic2.png" alt="配置信息" title="配置信息"><br>当我们通过URL访问配置信息时，我们发现控制台出现如下内容：<br><img src="/2018/09/27/quick-start-spring-cloud-config/pic3.png" alt="本地存储信息" title="本地存储信息"></p><p>配置服务实际是从Git仓库获取配置信息后，会存储一份在config-server的文件系统中，实质上config-server是通过git clone命令将配置内容复制一份在本地存储，然后读取本地内容返回给客户端，通过本地仓库暂存，可以有效的放置当git仓库出现故障而引起的无法加载的问题。  </p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p>添加依赖项<code>spring-cloud-starter-config</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>对配置文件进行添加配置中心服务地址，以及安全访问的用户名密码等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springclouduser</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">        uri: http:<span class="comment">//localhost:8080</span></span><br><span class="line">        fail-fast: <span class="keyword">true</span></span><br><span class="line">        username: user</span><br><span class="line">        password: $&#123;CONFIG_SERVER_PASSWORD:password&#125;</span><br><span class="line">        profile: dev</span><br><span class="line">        label: master</span><br><span class="line">        retry:  # 重试机制。</span><br><span class="line">            initial-interval: <span class="number">2000</span></span><br><span class="line">            max-interval: <span class="number">10000</span></span><br><span class="line">            multiplier: <span class="number">2</span></span><br><span class="line">            max-attempts: <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol><p>主要配置信息讲解：<br><code>spring.application.name</code>：服务名称，对应配置文件规则中的{application}部分。<br><code>spring.cloud.config.uri</code>:配置中心服务地址。<br><code>spring.cloud.config.username</code>:访问服务注册中心用户名。<br><code>spring.cloud.config.password</code>:访问注册中心密码。<br><code>spring.cloud.config.profile</code>:应用的环境信息，对应配置规则中的{profile}部分。<br><code>spring.cloud.config.label</code>:主要是分支，对应配置文件规则中的{label}部分。<br>需要注意的是这些配置信息必须配置到<code>bootstrap.yml</code>或<code>bootstrap.properties</code>文件中，因为配置信息<code>application.yml</code>和<code>bootstrap.yml</code>是有加载顺序的，首先程序启动时先加载的是<code>bootstrap.yml</code>文件，其次是<code>application.yml</code>配置信息，因为jar包之外的配置信息优先于jar包之内的配置信息，所以需要首先加载外部的配置信息。  </p><ol start="3"><li>对配置信息的读取和使用，首先需要添加配置类，对配置信息通过EL表达式的方式进行注入。<br>读取方式有两种方式：  </li></ol><ul><li><p>通过@Value(“${profile}”)方式绑定参数到属性中。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;profile&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Environment对象来获取配置属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="meta">@GetMapping</span>(“/getProfile”)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(“profile”,“<span class="keyword">null</span>”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务容错保护Spring Cloud Hystrix之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-hystrix/"/>
      <url>/2018/09/27/quick-start-spring-cloud-hystrix/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#Spring-Cloud-Hystrix介绍">Spring Cloud Hystrix介绍</a></li><li><a href="#Spring-Cloud-Hystrix整合">Spring Cloud Hystrix整合</a><ul><li><a href="#常用配置">常用配置</a>  </li></ul></li></ul><h2 id="Spring-Cloud-Hystrix介绍"><a href="#Spring-Cloud-Hystrix介绍" class="headerlink" title="Spring Cloud Hystrix介绍"></a>Spring Cloud Hystrix介绍</h2><p>Spring Cloud Hystrix实现了断路器、线程隔离等一系列服务保护功能。它是基于Netflix的开源框架Hystrix实现，该框架的目标在于通过控制那些访问远程系统，服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级，服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等功能。<br>场景描述：如果我们在微服务中进行通信时，发现其中微服务宕机了，这时候另外一个服务调用了宕机的服务，如果在没有断路器机制的前提下访问，这时候会一直等待，一直等待到服务达到超时的点，会使得线程因调用故障服务被长时间占用不能释放，通过断路器的故障监控，如果发现故障时，会向调用者返回一个错误相应，这样就不用长时间等待。</p><h2 id="Spring-Cloud-Hystrix整合"><a href="#Spring-Cloud-Hystrix整合" class="headerlink" title="Spring Cloud Hystrix整合"></a>Spring Cloud Hystrix整合</h2><ol><li>添加依赖项。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId &gt;</span><br><span class="line">&lt;/denpendecy&gt;</span><br></pre></td></tr></table></figure></li></ol><p>同时需要添加<code>spring-boot-starter-actuator</code>，这是Spring Boot对监控的依赖项，只有添加了这些东西后监控相关的endpoint才会被注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解<code>@EnableCircuitBreaker</code>，对Hystrix进行开启功能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">@EnableEurekaClient#开启Eureka客户端注册</span><br><span class="line">@EnableCircuitBreaker #开启Hystrix功能</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudUserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造服务消费方式，通过添加@HystrixCommod注解对服务接口的熔断技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TestController.class);    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getHelloWorld的熔断机制。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 熔断信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>代码分析：</p><ol><li>通过依赖注入RestTemplate，该Bean主要是对Rest Api进行访问，可以裂解调用服务接口的封装。</li><li>定义了getHelloWorld去访问另外一个服务springcloudservice的getHelloWorld方法</li><li>对该接口上添加了@HystrixCommod注解，通过制定fallbackMethod对出现问题接口进行错误转向</li><li>定义错误转向方法：fallback()</li><li>当springcloudservice服务宕机后，可以快速返回“error“字样。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommod</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HystrixCommand &#123;</span><br><span class="line"><span class="comment">// HystrixCommand 命令所属的组的名称：默认注解方法类的名称</span></span><br><span class="line"><span class="function">String <span class="title">groupKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// HystrixCommand 命令的key值，默认值为注解方法的名称</span></span><br><span class="line"><span class="function">String <span class="title">commandKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 线程池名称，默认定义为groupKey</span></span><br><span class="line"><span class="function">String <span class="title">threadPoolKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 定义回退方法的名称, 此方法必须和hystrix的执行方法在相同类中</span></span><br><span class="line"><span class="function">String <span class="title">fallbackMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">// 配置hystrix命令的参数</span></span><br><span class="line">HystrixProperty[] commandProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 配置hystrix依赖的线程池的参数</span></span><br><span class="line">HystrixProperty[] threadPoolProperties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。我们也可以通过此方法定义哪些需要忽略的异常</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] ignoreExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义执行hystrix observable的命令的模式，类型详细见ObservableExecutionMode</span></span><br><span class="line"> <span class="function">ObservableExecutionMode <span class="title">observableExecutionMode</span><span class="params">()</span> <span class="keyword">default</span> ObservableExecutionMode.EAGER</span>;</span><br><span class="line"> <span class="comment">// 如果hystrix方法抛出的异常包括RUNTIME_EXCEPTION，则会被封装HystrixRuntimeException异常。此方法定义需要抛出的异常</span></span><br><span class="line">HystrixException[] raiseHystrixExceptions() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义回调方法：但是defaultFallback不能传入参数，返回参数和hystrix的命令兼容</span></span><br><span class="line"><span class="function">String <span class="title">defaultFallback</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Hystrix超时时间</span><br><span class="line">hystrix:</span><br><span class="line">    command:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            execution:</span><br><span class="line">                isolation:</span><br><span class="line">                    thread:</span><br><span class="line">                       timeoutInMilliseconds: <span class="number">5000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端负载均衡Spring Cloud Ribbon之快速入门</title>
      <link href="/2018/09/27/quick-start-spring-cloud-ribbon/"/>
      <url>/2018/09/27/quick-start-spring-cloud-ribbon/</url>
      
        <content type="html"><![CDATA[<h1 id="客户端负载均衡-Spring-Cloud-Ribbon"><a href="#客户端负载均衡-Spring-Cloud-Ribbon" class="headerlink" title="客户端负载均衡-Spring Cloud Ribbon"></a>客户端负载均衡-Spring Cloud Ribbon</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#客户端负载均衡-Spring-Cloud-Ribbon">客户端负载均衡-Spring Cloud Ribbon</a><ul><li><a href="#Spring-Cloud-Ribbon介绍">Spring Cloud Ribbon介绍</a></li><li><a href="#Spring-Cloud-Ribbon使用">Spring Cloud Ribbon使用</a></li></ul></li></ul><h2 id="Spring-Cloud-Ribbon介绍"><a href="#Spring-Cloud-Ribbon介绍" class="headerlink" title="Spring Cloud Ribbon介绍"></a>Spring Cloud Ribbon介绍</h2><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它是基于Netflix的Ribbon的实现。通过Spring Cloud的封装可以轻松的将面向服务的Rest模板请求自动转化成客户端负载均衡的服务调用。它是一个工具类框架，不能像服务注册中心、配置中心、API网关单独部署，但是可以存在每一个Spring Cloud构建的微服务和基础设施中。<br>负载均衡模块都会维护一个可用的服务列表，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。客户端负载均衡和服务端负载均衡唯一的区别是客户端负载均衡中，所有客户端负载均衡都会自己维护服务清单，而这些服务清单是由服务注册中心获取得到。  </p><h2 id="Spring-Cloud-Ribbon使用"><a href="#Spring-Cloud-Ribbon使用" class="headerlink" title="Spring Cloud Ribbon使用"></a>Spring Cloud Ribbon使用</h2><p>1．    添加依赖项<code>spring-cloud-starter-ribbon</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加注解对负载均衡支持<code>@LoadBalanced</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 服务配置信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务之间调用通过服务名称的方式进行调用而不是通过ip地址的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用Service来获取内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hello world。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@GetMapping</span>(value = <span class="string">"getHelloWorld"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://springcloudservice/getHelloWorld"</span>, String.class);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的springcloudservice是注册到Eureka的服务，服务名称为springcloudservice，可以通过加了@LoadBalanced修饰过的RestTemplate来实现面向服务的接口调用。之前调用方式如下代码所示：restTemplate.getForObject(“<a href="http://localhost:8888/getHelloWorld&quot;" target="_blank" rel="noopener">http://localhost:8888/getHelloWorld&quot;</a>, String.class);</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务治理-Spring Cloud Eureka</title>
      <link href="/2018/09/26/spring-cloud-tutorial-eureka/"/>
      <url>/2018/09/26/spring-cloud-tutorial-eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka介绍"><a href="#Eureka介绍" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h1><p>Eureka是Spring Cloud Netflix的微服务套件的一部分，它是基于Netflix Eureka的二次开发，主要负责完成微服务架构中的服务治理功能。而且可以与Spring boot很容易的整合进行开发，使得开发变得简单，Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端，也被称为服务消费者与服务的生产者，服务启动时向服务注册中心（服务端）进行注册自己，并通过定时心跳检测的方式告诉服务端存活状态，更新服务续约，同时也可以将服务端的服务列表缓存到本地并周期性刷新服务列表的状态。</p><h1 id="Eureka的使用"><a href="#Eureka的使用" class="headerlink" title="Eureka的使用"></a>Eureka的使用</h1><p>服务端</p><ol><li>在pom文件中添加依赖项。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>添加配置信息，在application.yml或application.properties中添加如下内容  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springcloudeurekaserver   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: 8761  # 端口号</span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        registerWithEureka: false # 是否注册自己，不注册</span><br><span class="line">        fetchRegistry: false   # 禁止检测服务</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//$&#123;security.user.name&#125;:$&#123;security.user.password&#125;@localhost:$&#123;server.port&#125;/eureka/   #Eureka服务地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 处于安全考虑需要对用户进行登录。</span><br><span class="line">security:</span><br><span class="line">    user:</span><br><span class="line">        name: admin</span><br><span class="line">        password: $&#123;REGISTRY_SERVER_PASSWORD:password&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaServer注解，开启对Eureka服务的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行Eureka服务，通过访问<a href="http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：" target="_blank" rel="noopener">http://localhost:8761/eureka/进行访问Eureka注册中心，查看Eureka有哪些服务注册上，下图是Eureka主界面展示：</a><br><img src="/2018/09/26/spring-cloud-tutorial-eureka/pic1.png" alt="Eureka服务" title="Eureka服务"></p><h2 id="页面描述"><a href="#页面描述" class="headerlink" title="页面描述"></a>页面描述</h2></li><li>nstances currently registered with Eureka：服务注册列表信息。</li><li>DS Replicas代表的集群部署时，server地址。<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1></li><li><p>在pom文件中添加依赖项。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!- - 处于安全考虑 - -&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"># 需要添加对Spring Cloud版本的控制，这里我们使用的事Dalston.SR4版本，要求Spring boot版本号低于2.0版本。</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; Dalston.SR4&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息，在application.yml或application.properties中添加如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: springclouduser   # 注册到微服务中的服务名称。</span><br><span class="line">server:</span><br><span class="line">    port: <span class="number">8889</span></span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">    client:</span><br><span class="line">        service-url:</span><br><span class="line">            defaultZone: http:<span class="comment">//admin:$&#123;REGISTRY_SERVER_PASSWORD:password&#125;@$&#123;eureka.instance.hostname&#125;:8761/eureka/#Eureka服务地址。</span></span><br></pre></td></tr></table></figure></li><li><p>添加@EnableEurekaClient注解或@ EnableDiscoveryClient，开启对Eureka客户端的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEruekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEruekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样三步骤就讲微服务注册到服务中心中，可以看到服务中心已经获取到当前服务信息。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载器详解</title>
      <link href="/2018/09/23/java-class-loader/"/>
      <url>/2018/09/23/java-class-loader/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#类加载器详解">类加载器详解</a><ul><li><a href="#一、类加载器5大部分">一、类加载器5大部分</a><ul><li><a href="#加载">加载</a></li><li><a href="#验证">验证</a></li><li><a href="#准备">准备</a></li><li><a href="#解析">解析</a></li><li><a href="#初始化">初始化</a></li></ul></li><li><a href="#二、类加载器">二、类加载器</a></li><li><a href="#三、自定义类加载器">三、自定义类加载器</a>  </li></ul></li></ul><h1 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h1><h2 id="一、类加载器5大部分"><a href="#一、类加载器5大部分" class="headerlink" title="一、类加载器5大部分"></a>一、类加载器5大部分</h2><p>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。<br><img src="/2018/09/23/java-class-loader/./pic1.png" alt="加载机制" title="JVM类加载机制">  </p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;</code>方法之中，这里我们后面会解释。<br>但是注意如果声明为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info</span><br><span class="line">CONSTANT_Field_info</span><br><span class="line">CONSTANT_Method_info</span><br></pre></td></tr></table></figure></p><p>等类型的常量。<br>下面我们解释一下符号引用和直接引用的概念：<br>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。<br>初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>方法的过程。<code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;clinit&gt;</code>方法执行之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。（clinit初始化是对类成员信息进行初始化，init是对对象实例进行初始化操作）<br>注意以下几种情况不会执行类初始化：<br>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>定义对象数组，不会触发该类的初始化。<br>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。<br>通过类名获取Class对象，不会触发类的初始化。<br>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。  </p><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：  </p><ol><li>启动类加载器(<code>Bootstrap ClassLoader</code>)：负责加载 JAVA_HOME\lib（JRE/lib/rt.jar） 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。  </li><li>扩展类加载器(<code>Extension ClassLoader</code>)：负责加载 JAVA_HOME\lib\ext（JRE/lib/ext/*.jar） 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。  </li><li>应用程序类加载器(<code>Application ClassLoader</code>)：负责加载用户路径（classpath）上的类库。</li><li>自定义的类加载器（<code>User ClassLoader</code>）：负责加载用户自定义的路径上的类库。<br>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承<code>java.lang.ClassLoader</code>实现自定义的类加载器。</li></ol><p><img src="/2018/09/23/java-class-loader/./pic2.png" alt="委托图" title="委托图"><br>类加载器的委托机制：  </p><ol><li>首先当前线程去加载线程中的第一个类  </li><li>如果A中引用了B，java虚拟机将使用加载类A的类加载取来加载B  </li><li>还可以直接使用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。   </li></ol><p>每个类加载器加载类时，又先委托给其上级类加载器。   </p><ol><li>当所有祖先类加载器没有加载到类，回到发起者类加载器，还加载不了就抛出异常<code>ClassNotFoundException</code>，不是再去找发起类加载器的儿子节点，因为没有getChild方法。  </li></ol><p>eg.比如说我们自定义一个类A，当我们去获取当前类加载器的名称时，肯定是AppClassLoader加载器，因为我们当前类只有CLASSPATH路径下有没如果我们将当前的项目打包成test.jar将jar包放入到JRE/lib/ext路径下，这时候我们在CLASSPATH中类就不会被加载，首先加载的是ext下的类A。这时候我们输出类A加载器名称的时就会输出ExtClassLoader。下面做演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.printf(ClassLoaderTest.class.getClassLoader().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClassLoaderTest是我们新建立的类，获取当前类的加载器时输出内容为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br></pre></td></tr></table></figure></p><p>如果打包成jar包放到，ext文件下我们来看一下内容：<br><img src="/2018/09/23/java-class-loader/./pic.png" alt="ext目录结构" title="ext目录结构"></p><p>这是输出一下内容查看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = com.classloadertest.ClassLoaderTest.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(classLoader.getClass().getName()); </span><br><span class="line">    classLoader=classLoader.getParent();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure><p>循环输出类加载器结构的时候会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>因为Bootstrap类加载器实现不是由Java实现所以获取不到字节码，也就是为null的时候意味着是树状结构的顶层。</p><h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><p>有些时候我们需要实现自定义的类加载器来加载一些类，这时候我们可以继承ClassLoader来进行实现自定义的类加载器。我们先看一下jdk中的ClassLoader的源码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 递归先父类进行尝试加载。</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>首先检测当前类有没有加载，如果加载在就不需要加载直接返回字节码</li><li>如果没有被加载，这时候会委托加载机制，通过递归从父加载器开始找，直到父类加载器为bootstrap ClassLoader为止，如果父类加载器找到了该字节码后没直接返回如果没有就返回让子类加载器加载，当子类加载器时，</li><li>如果还没有找到，这时候调用findClass方法进行查找。</li><li>最后根据resolve的值，判断这个class是否需要解析。<br><img src="/2018/09/23/java-class-loader/./pic3.png" alt="流程图" title="流程图"></li></ol><p>首先类加载器进行加载时当前线程的上线文的<code>ClassLoader</code>也就是<code>APPClassLoader</code>，当加载类时调用<code>LoadClass</code>方法，当调用的时候会检测当前类有没有被加载如果被加载了，就不需要在加载了直接返回，反之调用父类加载器的<code>LoadClass</code>方法，当父类加载器的父加载器不是null的时候就再去调用<code>LoadClass</code>方法，这时候的类加载器是<code>ExtClassLoader</code>加载器，父类加载是<code>BootStrap ClassLoader</code>，这时候继续递归调用<code>LoadClass</code>方法，这时候类加载器为<code>BootStrap ClassLoader</code>， 这时候就不需要再往下寻找了， <code>parent ClassLoader</code>为null。这是调用<code>findBootstrapClassOrNull(name)</code>方法，如果c不为null，这时候就直接返回，但是如果为null就调用<code>findClass</code>进行查询加载，如果还为null，这时候就会调用父类加载器<code>ExtClassLoader</code>的<code>findClass</code>方法，如果还是没有找到，则调用线程本身的类加载器调用findClass方法返回相应字节码，如果还没有找到抛出异常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载器采用了设计模式是模板方法，也就是LoadClass方法是不需要进行改变的，我们需要关注的就是findClass()方法就好了。所以我们写自己的ClassLoader只需要继承ClassLoader并重写findClass方法即可。</span><br></pre></td></tr></table></figure></p><p>参考地址：<br><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a><br><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一文搭建Maven骨架</title>
      <link href="/2018/09/23/maven-skeleton-generation/"/>
      <url>/2018/09/23/maven-skeleton-generation/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#Maven骨架介绍">Maven骨架介绍</a><ul><li><a href="#Maven-archetype">Maven archetype</a></li></ul></li><li><a href="#maven骨架创建过程">Maven骨架创建过程</a><ul><li><a href="#使用archetype创建项目">使用archetype创建项目</a></li></ul></li><li><a href="#使用本地Maven骨架">使用本地Maven骨架</a></li></ul><h1 id="Maven骨架介绍"><a href="#Maven骨架介绍" class="headerlink" title="Maven骨架介绍"></a>Maven骨架介绍</h1><h2 id="Maven-archetype"><a href="#Maven-archetype" class="headerlink" title="Maven archetype"></a>Maven archetype</h2><p>Archetype是一个Maven项目模板工具包，通过Archetype我们可以快速搭建Maven项目，通俗理解就是项目的基础架构，项目初始化的过程。我们在使用Idea开发工具的时候会有如下图操作：<br><img src="/2018/09/23/maven-skeleton-generation/./pic.png" alt="IDEA" title="IDEA"><br>在这里选择的Maven进行生成的项目都是利用Maven骨架来进行生成的，通过选择骨架生成项目结构的方式方便了我们手动去搭建相关项目内容。可以直接通过自带骨架或自己构建的骨架进行项目的快速搭建，节约成本。<br>我们构建一个完整的骨架整体的操作逻辑如下图所示：<br><img src="/2018/09/23/maven-skeleton-generation/./pic1.png" alt="Maven archetype" title="Maven archetype"><br>接下来将详细剖析每一步内容。  </p><h1 id="Maven骨架创建过程"><a href="#Maven骨架创建过程" class="headerlink" title="Maven骨架创建过程"></a>Maven骨架创建过程</h1><h2 id="使用archetype创建项目"><a href="#使用archetype创建项目" class="headerlink" title="使用archetype创建项目"></a>使用archetype创建项目</h2><ol><li>第一步建立Maven的项目，其实就是我们想要生成骨架的项目结构。  </li><li><p>在pom.xml中添加插件maven-archetype-plugin。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开命令行进入到项目主目录中，运行如下命令：<font style="color:red"><code>mvn archetype:create-from-project</code></font><br>此时会在该项目的target目录下发现如下文件：<br><img src="/2018/09/23/maven-skeleton-generation/./pic2.png" alt="maven骨架目录" title="maven骨架目录"><br>我们可以清晰的发现archetype目录下是我们的项目结构，项目结构下面src/main/resources/META-INF/包含archetype-metadata.xml，这个文件是用来自定义骨架内容的，接下内容中会对信息进行详细的说明。</p></li><li>进入到target/generated-sources/archetype目录下，使用mvn clean install进行打包到本地文件中。<br>这时候你会在maven的本地仓库中多出一个文件archetype-catalog.xml<br><img src="/2018/09/23/maven-skeleton-generation/./pic3.png" alt="archetype-catalog.xml" title="archetype-catalog.xml"><br>打开文件发现这里面有我们添加的Maven骨架信息。<br><img src="/2018/09/23/maven-skeleton-generation/./pic4.png" alt="maven骨架目录" title="maven骨架目录"><br><em><code>注意：如果想要删除本地的内容就直接删除archetype节点即可。</code></em><h1 id="使用本地Maven骨架"><a href="#使用本地Maven骨架" class="headerlink" title="使用本地Maven骨架"></a>使用本地Maven骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>          禁止询问，如果不加命令行会询问你填写版本号等信息是否正确。  </span><br><span class="line">-DarchetypeCatalog=local         生成项目解析方式，local=本地骨架 internal=内部的  remote=这是Maven中央存储库或其镜像的捷径  </span><br><span class="line">-DgroupId=com.jtech.wpark.test   生成项目的groupId  </span><br><span class="line">-DartifactId=tetetetetet         生成项目的artifactId  </span><br><span class="line">-DarchetypeGroupId=com.jtech     骨架的groupId  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT 骨架版本号  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype   骨架的artifactId</span><br></pre></td></tr></table></figure></li></ol><p><code>archetypeCatalog</code>如果想要来自不同仓库的骨架信息，可以在maven的Setting.xml中设置如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;</span><br><span class="line">  &lt;url&gt;https://repository.domain.com/path/to/repo/&lt;/url&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- in case of a repository with authentication --&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;archetype&lt;/id&gt;          // 私服的Id</span><br><span class="line">  &lt;username&gt;xxxx&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;xxxx&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></p><p>如果Maven中央存储库目录文件是空的，则使用内部目录。  </p><h1 id="Maven私服上传"><a href="#Maven私服上传" class="headerlink" title="Maven私服上传"></a>Maven私服上传</h1><p>使用mvn clean deploy对骨架上传到私服中，这里会存在一个问题，也就是上传的地址需要在pom.xml配置下，pom.xml文件路径为<code>target/generated-sources/archetype/pom.xml</code>文件。<br><img src="/2018/09/23/maven-skeleton-generation/./pic5.png" alt="配置上传路径" title="配置上传路径"><br>需要对该pomw文件添加distributionManagement节点，节点内容主要是私服地址信息，配置之后使用mvn clean deplod会将骨架上传到私服中去。</p><h1 id="使用私服服务器骨架"><a href="#使用私服服务器骨架" class="headerlink" title="使用私服服务器骨架"></a>使用私服服务器骨架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate  </span><br><span class="line">-DinteractiveMode=<span class="keyword">false</span>  </span><br><span class="line">-DarchetypeCatalog=internal,remote            类型改变  </span><br><span class="line">-DarchetypeRepository=http:<span class="comment">//xxxxxx:8181/nexus/content/groups/public 私服地址  </span></span><br><span class="line">-DarchetypeGroupId=com.jtech  </span><br><span class="line">-DarchetypeArtifactId=yaoyuan-archetype  </span><br><span class="line">-DarchetypeVersion=<span class="number">0.0</span>.1-SNAPSHOT  </span><br><span class="line">-DgroupId=com.jtech.wpark.test  </span><br><span class="line">-DartifactId=tetetetetet  </span><br><span class="line">-Dversion=<span class="number">0.1</span>-SNAPSHOT</span><br></pre></td></tr></table></figure><p>这里需要注意一下,我们发现修改了远程私服进行构建项目时，指定了Repository为什么没有下载下来反而会出现如下错误信息：<br><img src="/2018/09/23/maven-skeleton-generation/./pic6.png" alt="错误信息" title="错误信息"><br>解决方案是：<br>修改maven的setting.xml文件，将文件修改为如下：  </p><ol><li><p>添加repository</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;snapshot&lt;/id&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">      &lt;repository&gt;</span><br><span class="line">        &lt;snapshots /&gt;</span><br><span class="line">          &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">          &lt;name&gt;my-snapshot&lt;/name&gt;</span><br><span class="line">          &lt;url&gt;http:<span class="comment">//127.0.0.1:8181/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">      &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">  &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;snapshot&lt;/activeProfile&gt;</span><br><span class="line">  &lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加server</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;   </span><br><span class="line">    &lt;id&gt;my-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li></ol><p>需要添加对私服的repository，以及Server，这里的Server ID和对应的archetype repository的Id是一致的。这样才会在私服中下载下来相应的archetype文件。 </p><h1 id="自定义骨架内容"><a href="#自定义骨架内容" class="headerlink" title="自定义骨架内容"></a>自定义骨架内容</h1><p>当我们按照上面步骤走完之后发现项目中多出了不需要的文件，这时候我们就需要对骨架的内容进行自定义。<br><img src="/2018/09/23/maven-skeleton-generation/./pic7.png" alt="多余内容" title="多余内容"><br>这里面.idea和yaoyuan.iml文件都不是我们想要的，这时候我们想到之前说过的一个文件archetype-metadata.xml，我们打开这个文件看一下。  （这里的xml指的是target生成的文件目录下的）<br><img src="/2018/09/23/maven-skeleton-generation/./pic8.png" alt="xml内容" title="xml内容"><br>包含了一堆没用的文件进来了，这时候我们将这些东西删除掉，在mvn install一下。<br><img src="/2018/09/23/maven-skeleton-generation/./pic9.png" alt="生成内容" title="生成内容">  </p><p><code>注意：这个文件很重要，主要是如果文件夹为空的时候当我们生成骨架的时候是不会包含当前文件的，你需要对上面xml进行配置包含当前文件即可。</code></p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态代理的工作原理简要分析</title>
      <link href="/2018/09/20/how-dynamic-agents-work/"/>
      <url>/2018/09/20/how-dynamic-agents-work/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#动态代理的工作原理">1. 动态代理的工作原理</a><ul><li><a href="#什么是代理">1.1. 什么是代理</a></li><li><a href="#什么是动态代理">1.2. 什么是动态代理</a></li><li><a href="#动态代理的原理">1.3. 动态代理的原理</a></li><li><a href="#实现AOP功能的封装和配置">1.4. 实现AOP功能的封装和配置</a></li></ul></li></ul><h1 id="动态代理的工作原理"><a href="#动态代理的工作原理" class="headerlink" title="动态代理的工作原理"></a>动态代理的工作原理</h1><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>比如说我们去租房子，需要通过中介代理来进行看房子，由于代理的手中有大量资源，有大部分房源都在代理手中掌握，所以不需要我们自己去一个一个去找寻，通过这样我们无需知道房东是谁就可以租到合适的房子，这就是代理，代理模式两个优点一是可以隐藏委托类的实现，二是可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><h2 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h2><p>代理类在运行时创建的过程叫做动态代理。也就是说这个代理类不是我们是事先写好的，而是由程序运行时自动生成的代理类，比如我们举一个静态代理例子：<br>我们首先定义一个接口<code>ISayHello</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个被代理对象：<code>SayHello</code>，并且继承自上面的接口，并实现接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> <span class="keyword">implements</span> <span class="title">ISayHello</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"hello world proxy！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是重点我们接下来要写代理类，代理类和被代理类之间是依赖组合关系，也就是说被代理类和代理类是同时存在的，也就是生命周期是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayProxy</span> <span class="keyword">implements</span> <span class="title">ISayHello</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> SayHello sayHello;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SayProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sayHello=<span class="keyword">new</span> SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">before();</span><br><span class="line">sayHello.sayHello();</span><br><span class="line">after();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello Before"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">"Say Hello After"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以达到动态扩充被代理类的内容，上面的内容是静态的动态代理，也就是代理类是我们已经写好的，接下来我们就要演示如何实现动态代理类。</p><h2 id="动态代理的原理"><a href="#动态代理的原理" class="headerlink" title="动态代理的原理"></a>动态代理的原理</h2><ol><li>JVM可以在运行期动态生成出类的字节码，这种动态生成的类往往被用作代理类，即动态代理。</li><li>JVM生成的代理类必须实现一个或多个接口，所以JVM生成的动态代理类只能用作具有相同接口的目标类代理。</li><li>CGLIB库可以生成一个类的子类，一个类的子类也可以用作该类的代理，所以如果要为一个没有实现接口的类生成动态代理类那么可使用CGLIB。</li></ol><p>Java提供了相应的代理类<code>java.lang.reflect.Proxy</code>，通过这个类能够动态生成代理类对象，接下来我们来做一下演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理相关内容实现</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);</span><br><span class="line">System.out.println(<span class="string">"代理类名称："</span> + clazz.getName(System.out.println(<span class="string">"代理类类加载器："</span> + clazz.getClassLoader());</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor item : constructors) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名字："</span> + item.getName());</span><br><span class="line">Parameter[] parameters = item.getParameters();</span><br><span class="line"><span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数类型："</span> + parameter.getParameterizedType() + <span class="string">"参数名称："</span> + parameter.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先获取<code>Collection</code>的代理类，Proxy提供了<code>getProxyClass</code>方法来进行获取代理类，这个方法有两个参数，第一个参数是加载这个代理类对象的类加载器，第二个参数是代理类对象实现的接口。我们来看一下输出结果内容：</p><p>代理类名称：<code>com.sun.proxy.$Proxy0</code></p><p>代理类类加载器：<code>null</code></p><p>方法名字：<code>com.sun.proxy.$Proxy0</code> </p><p>参数类型：<code>interface java.lang.reflect.InvocationHandler</code> 参数名称：<code>arg0</code></p><p>分析一下上面代码内容，首先我们创建了实现<code>Collection</code>接口的动态代理类对象，并返回动态代理类的字节码，这时候我们用反射方式查看一下动态代理对象的构造方法以及动态代理对象的名称和动态代理构造器方法。<br>我们仔细看到加载<code>com.sun.proxy.$Proxy0</code>的类加载器是<code>Bootstrap</code>类加载器，由于<code>Collection</code>加载器就是<code>Bootstrap</code>类加载器。所以返回的是<code>null</code>，因为该类加载器不是java实现的。构造函数的参数类型是InvocationHandler这个接口类型主要是做什么呢？我们接下俩一步一步来进行解密，这里留一下一个小小的悬念。<br>接下来通过反射的方式获取下当前代理类所实现的方法有哪些：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">System.out.println(<span class="string">"方法名称："</span> + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">方法名称：add  </span><br><span class="line">方法名称：remove  </span><br><span class="line">方法名称：equals  </span><br><span class="line">方法名称：toString  </span><br><span class="line">方法名称：hashCode  </span><br><span class="line">方法名称：clear  </span><br><span class="line">方法名称：contains  </span><br><span class="line">方法名称：isEmpty  </span><br><span class="line">方法名称：iterator  </span><br><span class="line">方法名称：size  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：toArray  </span><br><span class="line">方法名称：spliterator  </span><br><span class="line">方法名称：addAll  </span><br><span class="line">方法名称：stream  </span><br><span class="line">方法名称：forEach  </span><br><span class="line">方法名称：containsAll  </span><br><span class="line">方法名称：removeAll  </span><br><span class="line">方法名称：removeIf  </span><br><span class="line">方法名称：retainAll  </span><br><span class="line">方法名称：parallelStream  </span><br><span class="line">方法名称：isProxyClass</span><br><span class="line">方法名称：getInvocationHandler  </span><br><span class="line">方法名称：newProxyInstance  </span><br><span class="line">方法名称：getProxyClass  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：<span class="built_in">wait</span>  </span><br><span class="line">方法名称：getClass    </span><br><span class="line">方法名称：notify  </span><br><span class="line">方法名称：notifyAll</span><br></pre></td></tr></table></figure></p><p>由于代理类实现了Collection接口，所以接口中所有类方法都会被继承，还有Object中的方法，当然Object中不是所有方法都会交给代理类来执行，只有<code>hashCode,equals和toString方法</code>会交给代理类处理。也就是说当我们调用collection.getClass()会输出com.sun.proxy.$Proxy0而不是输出目标对象ArrayList，这就说明Object中的方法不是所有方法都派发给目标对象来执行，只有上面说的三个方法才会委托给InvocationHandler中的invoke方法来进行执行。而其他的方法有自己的实现。<br>  到这里我们的动态代理对象字节码分析完毕，这时候我们要创建动态代理的对象实例。<br>我们上面了解到动态代理对象是只有一个构造函数，这个构造函数传递参数是InvocationHandler接口，这时候我们就需要创建一个自己MyInvocationHandler对象实现InvocationHandler接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line">ArrayList target = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用前:"</span> + method.getName());</span><br><span class="line"><span class="comment">//代理对象方法调用</span></span><br><span class="line">Object o = method.invoke(target, args);</span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line">System.out.println(<span class="string">"方法调用后:"</span> + method.getName());</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来详细分析下这个接口中的方法，该接口中只有一个方法，也就是invoke方法，这个方法主要是什么作用呢？当我们调用代理类的方法是首先会调用MyInvocationHandler中invoke方法，通过调用这个方法来调用目标对象的方法体。实际上动态代理类实现的方法如下所示，例如我们现在实现的Collection接口的size方法，代理类对象的方法大致实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  $Proxy0  implements Collection&#123;</span><br><span class="line"></span><br><span class="line">InvocationHandler hander;</span><br><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler  handler)&#123;</span><br><span class="line"><span class="keyword">this</span>.handler=handler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> handler.invoke(<span class="keyword">this</span>,<span class="keyword">this</span>.getClass().getMethod(“size”),<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Handler的invoke 方法三要素：代理对象，代理对象方法，代理对象参数。<br>也就是说代理对象首先先调用我们构造函数中传递的handler对象的invoke方法，通过调用invoke方法来调用目标对象中存在的size方法。这也是Aop的原理，AOP的实现就是用了动态代理的方式进行操作的，目标对象返回的结果就是代理类返回的结果。<br>创建动态代理对象如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getConstructor(InvocationHandler.class);</span><br><span class="line">Collection collection = (Collection) constructor.newInstance(<span class="keyword">new</span> MyInvocationHandler());</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br></pre></td></tr></table></figure></p><p>这时候输出结果如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:add  </span><br><span class="line">方法调用后:add  </span><br><span class="line">方法调用前:size  </span><br><span class="line">方法调用后:size  </span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>正如我们上面分析的内容，我们来看一下动态代理类内部结构图：<br><img src="/2018/09/20/how-dynamic-agents-work/./pic1.png" alt="代理内部结构图" title="动态代理类内部结构图">  </p><p>当客户端调用代理对象的方法时，首先先经过InvocationHandler的invoke方法，这个方法体中可以扩充我们想要的内容，比如前置通知，后置通知，参数过滤等一系列操作，然后再通过该方法传入的method调用目标对象的方法，达到代理的作用。  </p><h2 id="实现AOP功能的封装和配置"><a href="#实现AOP功能的封装和配置" class="headerlink" title="实现AOP功能的封装和配置"></a>实现AOP功能的封装和配置</h2><p>实现思路是我们在配置文件中配置我们需要代理的目标对象，通知对象，通过配置文件进行切换是否生成代理对象，通过代理对象工厂进行判断是否生成代理类。工厂类BeanFactory负责创建目标类或代理类的实例对象，其getBean方法根据参数字符串返回一个响应的实例对象，也就是上面是通过ProxyFactoryBean进行判断是否生成代理对象，如果配置文件中配置的对象为ProxyFactoryBean的话，通过调用ProxyFactoryBean中的getProxy生成代理对象并返回，反之直接创建该对象实例并返回。<br>直接上代码首先看一下BeanFactory，主要是创建代理对象或者非代理对象实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//从配置文件中读取相应配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanFactory</span><span class="params">(InputStream ips)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   properties.load(ips);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String className = properties.getProperty(name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object bean = clazz.newInstance();</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ProxyFactoryBean) &#123;</span><br><span class="line">ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean) bean;</span><br><span class="line">String tagertClassName = properties.getProperty(name + <span class="string">".target"</span>);</span><br><span class="line">Class tagertClazz = Class.forName(tagertClassName); String adviceClassName = properties.getProperty(name + <span class="string">".advice"</span>);Class adviceClazz = Class.forName(adviceClassName); proxyFactoryBean.setAdvice((Advice)adviceClazz.newInstance());</span><br><span class="line">proxyFactoryBean.setTarget(tagertClazz.newInstance());</span><br><span class="line"><span class="keyword">return</span> proxyFactoryBean.getProxy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line"> System.out.println(ex.getMessage()); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码主要内容是首先构造函数是InputStream流用来加载properties配置文件的内容，配置相关内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean</span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice</span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>xxx也就是我们要获取的bean对象，如果对象类型为ProxyFactoryBean的话，就给该对象设置代理对象和通知对象。接下来我们看看ProxyFactoryBean中到底做了什么东西？前面我们已经提到了ProxyFactoryBean主要是创建代理对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得代理类</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Advice通知</span></span><br><span class="line">    <span class="keyword">private</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">                getTarget().getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        getAdvice().before();</span><br><span class="line">                        Object result = method.invoke(getTarget(), args);</span><br><span class="line">                        getAdvice().after();</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> advice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = advice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>target主要是目标代理对象，也就是我们要代理的目标对象，Advice对象主要是我们的通知对象，通知对象中只包含前置通知和后置通知这两个。主要是getProxy获取代理对象这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object proxy = (Object) Proxy.newProxyInstance(getTarget().getClass().getClassLoader(),</span><br><span class="line">getTarget().getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">getAdvice().before();</span><br><span class="line">Object result = method.invoke(getTarget(), args);</span><br><span class="line">getAdvice().after();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中我们可以看到直接调用了Proxy.newProxyInstance方法，而不再是调用Proxy.getClassProxy这个方法获取字节码的方式，这就告诉我们Proxy的创建可以分为两种方式进行创建，这种方式比较简便，方法中有三个参数第一个参数指定类加载器，第二个参数是代理对象要实现的接口有哪些，第三个方法就是InvocationHandler，这里我们传入的参数目标类的加载器，以及目标类实现的接口，第三个参数我们这边才用的是匿名内部类的方式传递。其中Invoke方法中要调用目标对象的方法，也就是method.invoke(target,args);<br>接下来我们看一下通知类Advice中写了什么内容。<br>首先我们声明了接口Advice<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又写了MyAdvice类继承并实现Advice接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by battleheart on 2017/6/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通知方法中没有写太多东西就是输出一些信息表示已经应用了通知内容。<br>接下来就是调用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream ips = TestApplication.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">Object bean = <span class="keyword">new</span> com.test.Aop.BeanFactory(ips).getBean(<span class="string">"xxx"</span>);</span><br><span class="line">Collection collection = (Collection) bean;</span><br><span class="line">collection.add(<span class="string">"111"</span>);</span><br><span class="line">collection.add(<span class="string">"222"</span>);</span><br><span class="line">collection.add(<span class="string">"333"</span>);</span><br><span class="line">collection.add(<span class="string">"444"</span>);</span><br><span class="line">System.out.println(collection.size());</span><br><span class="line">System.out.println(bean.getClass().getName());</span><br></pre></td></tr></table></figure></p><p>由于我是用Spring boot 搭建的项目所以配置文件名称为application.properties，这个不重要，重要的是配置文件内容，上面我已经提到了第一种配置内容为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.test.Aop.ProxyFactoryBean  </span><br><span class="line">xxx.advice=com.test.Aop.MyAdvice  </span><br><span class="line">xxx.target=java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>当我们调用getBean获取xxx时，如果xxx配置为ProxyFactoryBean的话就会创建代理类我们看一下输出内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">前置通知</span><br><span class="line">后置通知</span><br><span class="line">4</span><br><span class="line">com.sun.proxy.<span class="variable">$Proxy0</span></span><br></pre></td></tr></table></figure></p><p>最后输出内容为￥Proxy0表示创建代理对象成功，并调用了通知方法，如果配置文件修改为如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx= java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>输出内容则为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure></p><p>因为没有创建代理对象所以获取类型是返回ArrayList类型。完结  </p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的blog之旅又要开始了</title>
      <link href="/2018/09/18/hello-world/"/>
      <url>/2018/09/18/hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">距离我的个人博客服务器到期到现在也有一段时间了，这段时间里面已经停止了些东西，最近要把写文章这件事慢慢的拾起来，制定写作计划。</span><br></pre></td></tr></table></figure><h2 id="博客主要内容"><a href="#博客主要内容" class="headerlink" title="博客主要内容"></a>博客主要内容</h2><p>博客主要内容是针对技术的分享与交流，主要技术有spring，spring boot，spring cloud，java，mybatis等技术框架的技术分享，也业余分享python等，大数据相关技术的内容的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-工作区、暂存区、分支</title>
      <link href="/2016/01/13/git-study-2/"/>
      <url>/2016/01/13/git-study-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h1><ol><li>初始化一个仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git  init</span><br><span class="line">git  clone</span><br></pre></td></tr></table></figure></li></ol><p>git仓库分为两种情况：<br>第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  init  –bare  git 创建一个裸仓库</span><br></pre></td></tr></table></figure></p><ol start="2"><li>git仓库有三个区域</li></ol><ul><li>工作区working directory日常编辑代码的地方</li><li>历史仓库history repository是commit指向的一个树形结构</li><li>暂存区Staging area相当于是工作区与历史提交中间的缓存，它代表着是你要提交代码的一个工作状态，它维护的是一个虚拟的树形结构<br><img src="/2016/01/13/git-study-2/1.png" alt="图片1" title="图片1"></li></ul><p>讲述完了git的区域，接下来讲解下git文件的状态，其实git的状态无外乎两种：已跟踪和未跟踪，已跟踪的文件说明的是被纳入版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p><img src="/2016/01/13/git-study-2/2.png" alt="图片2" title="图片2"></p><p>讲解下文件变化周期，比如我们在项目中添加了一个文件a,这时候文件a处于的状态则是Untracked未跟踪状态，当我们git add的时候这时候就会将文件放到暂存区中这时候状态变为Stage，当我们commit这个暂存区的文件后这个文件就变成未修改状态，因为没有进行修改过了相对于版本控制中的文件，当我们修改了a文件后这时候从unmodified变成modified（修改状态），这是再git add的时候就会将修改的文件变成stage，放入暂存区用于等待commit。</p><p>接下来就详细讲解下这些命令：<br>往暂存区里面添加东西使用如下git指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  add</span><br></pre></td></tr></table></figure></p><p>从暂存区提交到历史记录使用如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  commit</span><br></pre></td></tr></table></figure></p><p>查看工作区和暂存区之间的区别，来确保提交时我们所需要的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  status</span><br></pre></td></tr></table></figure></p><p>从暂存区里面删除内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm</span><br></pre></td></tr></table></figure></p><p>工作区内重命名文件或者移动文件，然后再把他们添加到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  mv</span><br></pre></td></tr></table></figure></p><p>确保工作区内里面不需要的文件不被添加进去添加到暂存区和历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br></pre></td></tr></table></figure></p><h1 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h1><ol><li>新建一个仓库，并且新建一个文件a，将其添加到暂存区。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git  init  git_init</span><br><span class="line">cd  git_init</span><br><span class="line">touch a             //新建a文件</span><br><span class="line">git  add  a         //将a添加到暂存区</span><br></pre></td></tr></table></figure><p>git status会显示我们要提交的内容a文件，这时候a两个文件都是Changes to be committed也就是待commit的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      new file:   a</span><br><span class="line">git  commit  -m  “initial commit”//提交a文件到版本控制中。</span><br></pre></td></tr></table></figure></p><ol start="2"><li>touch b新建文件b，将其放入暂存区，观察git status返回的状态信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch b     //新建文件b</span><br><span class="line">git add b   //将b放入暂存区中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      new file:   b</span><br></pre></td></tr></table></figure><ol start="3"><li>编辑一下a文件，这时候在调用git status</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      modified:   a</span><br><span class="line">      new file:   bb</span><br></pre></td></tr></table></figure><p>这时候a文件是出于修改状态，那么如果我们在进行修改a文件时候，在调用下git status会发生什么奇怪的事呢？let’s  go。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">      modified:   a</span><br><span class="line">      new file:   bb</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) </span><br><span class="line">      modified:   a</span><br></pre></td></tr></table></figure></p><p>这时候我们会发现两个modified a，这是为什么呢？但是两个文件分别存在暂存区和非暂存区，实际上暂存区内只保存了git add的版本，而最新修改的一份没有提交到暂存区内还在工作区域中，所以我们会看到两个，如果这时候调用git commit的话就只会讲已经在暂存区的文件存入到版本控制中，而最新修改的那一次记录没有被提交。<br>当然这里还提供了跳过暂存区的方法就是git commit –a –m“注释内容”可以直接跳过暂存区直接提交到记录里面去。 </p><p>将a移除整个项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm  a</span><br></pre></td></tr></table></figure></p><p>清楚缓存中的内容，也就是已经暂存的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  rm  a  –cached</span><br></pre></td></tr></table></figure></p><p>给文件重命名将a文件名换成c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  mv  a  c</span><br></pre></td></tr></table></figure></p><h1 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a>Git暂存区</h1><p>假设工作区里面有这么一些文件如下图所示：</p><p><img src="/2016/01/13/git-study-2/3.png" alt="图片3" title="图片3"></p><p>在第一次add都还没有进行的时候，暂存区还没有被创建出来，当我们add的时候会创建一个暂存区出来（文件分开add产生两个数据对象），如下图所示：</p><p><img src="/2016/01/13/git-study-2/4.png" alt="图片4" title="图片4"></p><p>.git目录下面多了一个index的文件，那么这个index文件就是我们所说的暂存区的文件，那么每一条索引都是hash值表示以及它对应的文件名。每个索引还包含了他的文件模式权限还有status number来表示他的合并状态、时间戳等。每一个索引都是跟对象库的文件是对应的。比如说file.txt这里对应的是标号1，那么file2.txt对应的就是标号2(上图所示标号)，这个index里面除了维护了索引之外还维护了提前计算好的tree对象的内容，也就是我们的顶层的目录tree以及folder的tree对象内容，当我们提交的时候他可以迅速的根据我们已经计算好的内容生成一个tree对象，然后添加到历史记录里面。</p><p><img src="/2016/01/13/git-study-2/5.png" alt="图片5" title="图片5"></p><p>当我们修改了file2.txt的时候，这时候git add到暂存区时，发现对象库里面新创了一个对象，那么暂存区的这条索引就被指向新对象的索引替换掉。这时候git暂存区又从新计算了下顶层目录tree对象的一个内容。当我们提交的时候我们直接使用已经计算好的内容创建好一个新的tree对象，生成一个commit对象将master分支上面的HEAD指针指向当前commit对象上去。如下图所示：</p><p><img src="/2016/01/13/git-study-2/6.png" alt="图片6" title="图片6"></p><p>这里的标号8指向的就是新生成的commit对象。</p><h1 id="Git本地分支与合并"><a href="#Git本地分支与合并" class="headerlink" title="Git本地分支与合并"></a>Git本地分支与合并</h1><ol><li><p>创建分支git branch</p></li><li><p>给固定的commit做标记 git  tag</p></li><li><p>分支之间进行切换 git  checkout</p></li><li><p>切换分支之前保存本地修改 git  stash</p></li><li><p>合并分支 git  merge</p></li></ol><p>例子创建一个分支名字叫test并切换到当前的分支上去。</p><p><img src="/2016/01/13/git-study-2/7.png" alt="图片7" title="图片7"></p><p>这时候分支的名称不再是master而是改变成为test分支。编辑下a文件用test分支进行提交</p><p><img src="/2016/01/13/git-study-2/8.png" alt="图片8" title="图片8"></p><p>切换到master分支上面我们看一下a的内容</p><p><img src="/2016/01/13/git-study-2/9.png" alt="图片9" title="图片9"></p><p>并没有test分支在a中添加的内容这时候我们切换分支时会使用我们分支上最新的一个提交来还原我们的暂存区和工作区内容，那么可以让我们在不同的分支之间独立的做自己的工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  log  –oneline  –decorate  –graph  –all</span><br></pre></td></tr></table></figure></p><p>我们可以看到提交的记录或提交这些提交的引用</p><p><img src="/2016/01/13/git-study-2/10.png" alt="图片10" title="图片10"></p><p>给第一个提交加一个名称tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  tag  “v0”  f6699b3</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/11.png" alt="图片11" title="图片11"></p><p>在查看下git  log  –oneline  –decorate  –graph  –all</p><p><img src="/2016/01/13/git-study-2/12.png" alt="图片12" title="图片12"></p><p>多了一个tag：v0使用git show v0查看下内容，这是打的tag是一个轻量级的只是一个固定的引用。</p><p><img src="/2016/01/13/git-study-2/13.png" alt="图片13" title="图片13"></p><p>而使用git tag –a的方式进行添加时会是一个tag对象，他有tag的属性，包括提交人时间等信息。</p><p><img src="/2016/01/13/git-study-2/14.png" alt="图片14" title="图片14"></p><p><img src="/2016/01/13/git-study-2/15.png" alt="图片15" title="图片15"></p><p>Tag指向了一个提交commit</p><p>Tag也可以使用checkout进行操作</p><p><img src="/2016/01/13/git-study-2/16.png" alt="图片16" title="图片16"></p><p>但是它当前的没有指向一个分支而是指向了一个commit，这时候就会出现一个问题就是我们切换分支的时候这一部分内容就有可能被遗弃掉，也就是说head引用直接指向了一个commit而不是一个分支名，checkout提供了针对当前commit新建一个分支的方法并切换到当前分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  checkout  -b  “ttt_v0”</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/17.png" alt="图片17" title="图片17"></p><p>接下来切换master分支</p><p><img src="/2016/01/13/git-study-2/18.png" alt="图片18" title="图片18"></p><p>这时候会用的git  stash进行保存工作区，因为我们切换checkout的时候会覆盖掉当前的内容所以我们先将其保存起来。如果想要保存暂存区就可以使用-a来保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git  stash  save  -a   “stash1”</span><br></pre></td></tr></table></figure></p><p><img src="/2016/01/13/git-study-2/19.png" alt="图片19" title="图片19"></p><p>这时候我们来查看下缓存区状态git  status的时候是很干净的如下图：</p><p><img src="/2016/01/13/git-study-2/20.png" alt="图片20" title="图片20"></p><p>下面我们切换到master分之下，在切换会ttt_v0下时我们要还原stash里面的内容</p><p><img src="/2016/01/13/git-study-2/21.png" alt="图片21" title="图片21"></p><p>会有一个stash的缓存内容存在，下面我们来恢复stash里面的内容，并将缓存区内容还原。</p><p>git  stash   pop  –index  stash@{0}   这里的标记红色的表示stash里面的第0个stash</p><p><img src="/2016/01/13/git-study-2/22.png" alt="图片22" title="图片22"></p><p>我们会发现之前修改的a文件已经在暂存区内贮备提交了</p><p>使用git  stash  apply  –index  stash@{0}这种方式时git stash list里面的内容是不会被清理掉的这里–index是恢复暂存区内容</p><p>使用git  stash  drop  stash@{0}清除掉，如果不加stash@{0}引用的话他默认会清楚stash栈最上面的一个。</p><p>清楚多个stash的时候使用git  stash  clear</p><h1 id="查看与对比历史记录"><a href="#查看与对比历史记录" class="headerlink" title="查看与对比历史记录"></a>查看与对比历史记录</h1><ol><li><p>git show</p></li><li><p>git log</p></li><li><p>git diff</p></li></ol><p>输入git  log  –oneline  –decorate  –graph  –all查看完整的历史示意图。</p><p><img src="/2016/01/13/git-study-2/23.png" alt="图片23" title="图片23"></p><p>git  log  -p常用的选项是 -p，用来显示每次提交的内容差异， 你也可以加上 -2 来仅显示最近两次提交：</p><p><img src="/2016/01/13/git-study-2/24.png" alt="图片24" title="图片24"></p><p>我们可以根据查看git  show  f6699b3的信息</p><p><img src="/2016/01/13/git-study-2/25.png" alt="图片25" title="图片25"></p><p>最新的一次提交可以用git  show  master 或者git  show  HEAD，也可以使用git  show  master^表示master分支的第一次提交master^2表示第二次提交</p><p>通常我们会用git diff来回答两个问题：第一个就是当前做了什么还没有提交暂存区？第二个问题就是当前那些文件已经暂存了等待提交？</p><p>git  diff 这个命令是查看当前工作区与暂存区快照的差异，也就是那些还没有暂存起来。</p><p><img src="/2016/01/13/git-study-2/26.png" alt="图片26" title="图片26"></p><p>图中显示的是暂存区和工作区的区别在于a文件被修改了添加了next edit file。请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。</p><p>回顾：</p><p>所谓的分支就是一个commit记录的引用如下图所示：</p><p><img src="/2016/01/13/git-study-2/27.png" alt="图片27" title="图片27"></p><p>在这些分支上工作会产生各自的历史记录（commit记录）所谓的分支切换就是指的Head指针的切换以及暂存区和工作区的一个还原，比如说我们现在当前Head指向的位置处再建两个分支之后他们所指向的commit都是同一个如下图所示：</p><p><img src="/2016/01/13/git-study-2/28.png" alt="图片28" title="图片28"></p><p>分支切换后如下图所示：</p><p><img src="/2016/01/13/git-study-2/29.png" alt="图片29" title="图片29"></p><p>而tag指向了一个固定的commit记录，如下图所示：</p><p><img src="/2016/01/13/git-study-2/30.png" alt="图片30" title="图片30"></p><p>分为两种一种是轻量级的一种是标签对象，主要区别就是轻量级的tag只是一个固定的连接，但是标签对象就是创建标签的时候会产生一个标签对象，这个标签对象存储在.git/object目录里面，tag对象里面包括对数据对象的指向，以及创建时间数据对象类型和创建人等信息。</p><p><img src="/2016/01/13/git-study-2/31.png" alt="图片31" title="图片31"></p><p>举个例子来说明一下分支切换以及合并：</p><p>开始的状态是这样的，我们提交了三次commit后的示意图如下：</p><p><img src="/2016/01/13/git-study-2/32.png" alt="图片32" title="图片32"></p><p>当我们使用了git  branch test的时候，将会在当前位置处新建一个分支，分支的名称叫test，但是分支并没有切换依然是master分支（Head的指向）如下图所示：</p><p><img src="/2016/01/13/git-study-2/33.png" alt="图片33" title="图片33"></p><p>我们在master分支上面工作会产生master分支上面的commit记录如下图所示：</p><p><img src="/2016/01/13/git-study-2/34.png" alt="图片34" title="图片34"></p><p>这个时候我们是用git  checkout  test的时候HEAD指针就会指向test，并且还原暂存区和工作区内容。如下图所示：</p><p><img src="/2016/01/13/git-study-2/35.png" alt="图片35" title="图片35"></p><p>继续在test分支上面进行工作，会产生test对应分支上面的commit记录</p><p><img src="/2016/01/13/git-study-2/36.png" alt="图片36" title="图片36"></p><p>我们来说一下合并，合并分为两种一种是fast-farword  merge也就是说test所指向的commit记录他其实是master所指向的commit所衍生出来的如下图所示：</p><p><img src="/2016/01/13/git-study-2/37.png" alt="图片37" title="图片37"></p><p>蓝色部分是master分支，红色部分是master分支所衍生出来的分支。这时候我们在master分支上面进行合并git  merge  test不会产生新的commit记录出来，master分支指向test分支所指向的commit记录上去，然后把工作区和暂存区还原成了test的暂存区和工作区内容。如下图所示：</p><p><img src="/2016/01/13/git-study-2/38.png" alt="图片38" title="图片38"></p><p>另外一种就是non-fast-farword  merge也就是我们的三方合并。</p><p><img src="/2016/01/13/git-study-2/39.png" alt="图片39" title="图片39"></p><p>我们可以看到master指向的commit和test只想的commit有一个共同的父节点就是70e4d8这个节点。Master指向的commit和test指向的commit并没有一个衍生的关系，这时候我们在master分支上面git merge test，会生成一个新的commit来承载两个分支的历史内容</p><p><img src="/2016/01/13/git-study-2/40.png" alt="图片40" title="图片40"></p><p>五、结束语<br>这篇文章非一天写完的我也是在学习的过程中总结，以及参考大婶们写的文章加自己的理解写成的，如果这里有些错的或者有雷同的请各位大神指点一二。小丁谢过，写一篇文章确实不容易，能支持的就支持下不能支持的就当没看过这篇文章就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>带你走进git-基础配置</title>
      <link href="/2016/01/13/git-config/"/>
      <url>/2016/01/13/git-config/</url>
      
        <content type="html"><![CDATA[<h1 id="git的简单配置"><a href="#git的简单配置" class="headerlink" title="git的简单配置"></a>git的简单配置</h1><p>配置提交代码的信息，例如是谁提交的代码之类的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  –global user.name BattleHeaert 这里是设置提交代码的人的名称</span><br><span class="line">git config  –global user.email github@126.com 这里是设置提交代码的人的邮箱</span><br></pre></td></tr></table></figure></p><p>查看当前的用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  user.name</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config   –get  user.name</span><br></pre></td></tr></table></figure></p><p>这时候会显示BattleHeart这个用户名，但是如果我们再添加一个用户的名称的时候这时候就会显示最后一个添加的用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –add  user.name  BH</span><br></pre></td></tr></table></figure></p><p>当我们再次使用git  config  user.name时这时候显得是就是BH如下图所示<br><img src="/2016/01/13/git-config/1.png" alt="图片1" title="图片1"><br>我们可以使用如下指令来列出基本的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –list</span><br></pre></td></tr></table></figure></p><p>基本信息如下图所示（这里其实是有两个user.name的结果，只不过使用的是最后一个值）<br><img src="/2016/01/13/git-config/2.png" alt="图片2" title="图片1"><br>那么我们来取消一个user.name使用以下指令来进行操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –unset  user.name  BH</span><br></pre></td></tr></table></figure></p><p>这里user.name后面必须添加上取消的name的名称否则它是找不到你要取消那个名称的，会提示警告user.name有多个值。</p><p>如果只有一个键值对的时候就可以不用带后面name的名称直接使用如下方式即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  –unset  user.name</span><br></pre></td></tr></table></figure></p><p>修改一个键值对的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  user.name  BH</span><br></pre></td></tr></table></figure></p><p>修改后的结果如下图<br><img src="/2016/01/13/git-config/3.png" alt="图片3" title="图片3">  </p><h1 id="给git子命令的参数起别名"><a href="#给git子命令的参数起别名" class="headerlink" title="给git子命令的参数起别名"></a>给git子命令的参数起别名</h1><p>例如给checkout起别名叫co<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  alias.co  checkout</span><br></pre></td></tr></table></figure></p><p>设置带参数的命令别名给log  –online起别名如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  config  –global  alias.lol  “log  –online”</span><br></pre></td></tr></table></figure></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>献给所有新学Git的系列，这是文章的开篇，后续会陆陆续续将文章发布出来。如果文章用有不正确的地方请给我大神指点，小丁在此谢过了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
